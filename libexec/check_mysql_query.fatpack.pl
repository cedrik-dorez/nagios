#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"HariSekhon/Ambari.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_AMBARI';
  #
  #  Author: Hari Sekhon
  #  Date: 2014-07-27 15:20:09 +0100 (Sun, 27 Jul 2014)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  # Forked from check_ambari.pl from the Advanced Nagios Plugins Collection
  #
  # to share with other Ambari check programs
  
  package HariSekhon::Ambari;
  
  $VERSION = "0.4.0";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Carp;
  use Data::Dumper;
  use JSON 'decode_json';
  use LWP::UserAgent;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $api
                      $cluster
                      $node
                      $list_clusters
                      $list_hosts
                      $list_components
                      $list_services
                      $list_users
                      $protocol
                      $component
                      $service
                      $ua
                      $url_prefix
                      %ambari_options
                      %ambari_options_list
                      %ambari_options_node
                      %ambari_options_service
                      %service_map
                      cluster_required
                      component_required
                      node_required
                      service_required
                      curl_ambari
                      hadoop_service_name
                      list_ambari_components
                      list_clusters
                      list_hosts
                      list_components
                      list_services
                      list_users
                      validate_ambari_cluster
                      validate_ambari_cluster_options
                      validate_ambari_node
                      validate_ambari_component
                      validate_ambari_service
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  our $ua = LWP::UserAgent->new;
  
  our $protocol = "http";
  our $api      = "/api/v1";
  set_port_default(8080);
  
  our $url_prefix;
  
  our $cluster;
  our $node;
  our $component;
  our $service;
  
  our $list_nodes          = 0;
  our $list_clusters       = 0;
  our $list_svc_components = 0;
  our $list_svc_nodes      = 0;
  our $list_svcs           = 0;
  our $list_svcs_nodes     = 0;
  our $list_users          = 0;
  
  our %service_map = (
      #"GANGLIA"       => "Ganglia",
      #"FALCON"        => "Falcon",
      "HBASE"         => "HBase",
      "HCATALOG"      => "HCatalog",
      "HDFS"          => "HDFS",
      #"HIVE"          => "Hive",
      "MAPREDUCE"     => "MapReduce",
      "MAPREDUCE2"    => "MapReduce2",
      #"NAGIOS"        => "Nagios",
      #"OOZIE"         => "Oozie",
      #"PIG"           => "Pig",
      #"STORM"         => "Storm",
      #"TEZ"           => "Tez",
      "WEBHCAT"       => "WebHCat",
      #"YARN"          => "Yarn",
      "ZOOKEEPER"     => "ZooKeeper",
  );
  
  env_creds("Ambari");
  
  if($ENV{"AMBARI_CLUSTER"}){
      $cluster = $ENV{"AMBARI_CLUSTER"};
  }
  
  if($ENV{"AMBARI_SERVICE"}){
      $service = $ENV{"AMBARI_SERVICE"};
  }
  
  if($ENV{"AMBARI_COMPONENT"}){
      $component = $ENV{"AMBARI_COMPONENT"};
  }
  
  if($ENV{"AMBARI_NODE"}){
      $node = $ENV{"AMBARI_NODE"};
  }
  
  # Ambari REST API:
  #
  # /clusters                                                 - list clusters + version HDP-1.2.0
  # /clusters/$cluster                                        - list svcs + host in cluster
  # /clusters/$cluster/services                               - list svcs
  # /clusters/$cluster/services/$service                      - service state + components
  # /clusters/$cluster/services/$service/components/DATANODE  - state, hosts, TODO: metrics
  # /clusters/$cluster/hosts                                  - list hosts
  # /clusters/$cluster/host/$node                             - host_state, disks, rack, TODO: metrics
  # /clusters/$cluster/host/$node/host_components             - list host components
  # /clusters/$cluster/host/$node/host_components/DATANODE    - state + metrics
  
  our %ambari_options_list = (
      "list-users"                => [ \$list_users,          "List Ambari users" ],
  );
  
  our %ambari_options = (
      %tlsoptions,
      "C|cluster=s"               => [ \$cluster,             "Cluster Name as shown in Ambari or --list-clusters (\$AMBARI_CLUSTER)" ],
      "list-clusters"             => [ \$list_clusters,       "Lists all the clusters managed by the Ambari server" ],
      %ambari_options_list,
  );
  our %ambari_options_node = (
      %ambari_options,
      "N|node=s"                  => [ \$node,                "Node in cluster as shown in Ambari or --list-nodes (\$AMBARI_NODE)" ],
      "list-nodes"                => [ \$list_nodes,          "Lists all the nodes managed by the Ambari server for given --cluster" ],
  );
  our %ambari_options_service = (
      %ambari_options,
      "S|service=s"               => [ \$service,             "Service Name as shown in Ambari or --list-services (eg. HDFS, HBASE, usually capitalized, \$AMBARI_SERVICE). Requires --cluster" ],
      "O|component=s"             => [ \$component,           "Service component to check, see --list-service-components (eg. DATANODE, \$AMBARI_COMPONENT)" ],
      "list-services"             => [ \$list_svcs,           "Lists all services in the given --cluster" ],
      "list-service-components"   => [ \$list_svc_components, "Lists all components of a given service. Requires --cluster, --service" ],
      "list-service-nodes"        => [ \$list_svc_nodes,      "Lists all nodes for a given service. Requires --cluster, --service, --component" ],
  );
  
  splice @usage_order, 6, 0, qw/cluster service node component list-clusters list-nodes list-services list-service-nodes list-service-components list-users/;
  
  sub curl_ambari($){
      my $url = shift;
      # { status: 404, message: blah } handled in curl() in lib
      my $content = curl $url, ($debug ? "" : "Ambari"), $user, $password;
  
      my $json;
      try{
          $json = decode_json $content;
      };
      catch{
          quit "invalid json returned by Ambari at '$url_prefix', did you try to connect to the SSL port without --tls?";
      };
      return $json;
  }
  
  sub cluster_required(){
      $cluster or usage "--cluster required";
  }
  sub node_required(){
      $node or usage "--node required";
  }
  sub service_required(){
      $service or usage "--service required";
  }
  sub component_required(){
      $component or usage "--component required";
  }
  
  sub hadoop_service_name($){
      my $service = shift || code_error "no service name passed to hadoop_service_name()";
      if(grep { $service eq $_ } keys %service_map){
          $service = $service_map{$service};
      } else {
          $service = ucfirst lc $service;
      }
      return $service;
  }
  
  sub list_clusters(;$){
      my $quit = shift;
      my %clusters;
      $json = curl_ambari "$url_prefix/clusters";
      my @items = get_field_array("items");
      my $cluster_name;
      my $cluster_version;
      foreach(@items){
          $cluster_name    = get_field2($_, "Clusters.cluster_name");
          $cluster_version = get_field2($_, "Clusters.version");
          $clusters{$cluster_name} = $cluster_version;
          #vlog2   sprintf("%-19s %s\n", $cluster_name, $cluster_version);
          $msg .= sprintf("%s (%s), ",  $cluster_name, $cluster_version);
      }
      $msg =~ s/, $//;
      if($quit){
          my $num_clusters = scalar keys %clusters;
          plural $num_clusters;
          print "$num_clusters cluster$plural managed by Ambari:\n\n" . join("\n", sort keys %clusters) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
      return %clusters;
  }
  
  sub list_nodes(;$){
      my $quit = shift;
      cluster_required();
      $json = curl_ambari "$url_prefix/clusters/$cluster/hosts";
      my @items = get_field_array("items");
      my @nodes;
      my $node;
      foreach(@items){
          $node = get_field2($_, "Hosts.host_name");
          #vlog2 sprintf("node %s", $node);
          push(@nodes, $node);
      }
      @nodes = sort @nodes;
      if($quit){
          my $num_nodes = scalar @items;
          plural $num_nodes;
          print "$num_nodes node$plural in cluster '$cluster':\n\n" . join("\n", @nodes) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
      #return %nodes;
      return @nodes;
  }
  
  sub list_services(;$){
      my $quit = shift;
      cluster_required();
      $json = curl_ambari "$url_prefix/clusters/$cluster/services";
      my @items = get_field_array("items");
      my @services;
      foreach(@items){
          push(@services, get_field2($_, "ServiceInfo.service_name"));
      }
      # comes sorted
      #@services = sort @services;
      if($quit){
          print "cluster '$cluster' services:\n\n" . join("\n", @services) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
      return @services;
  }
  
  sub list_service_components(;$){
      my $quit = shift;
      cluster_required();
      service_required();
      $json = curl_ambari "$url_prefix/clusters/$cluster/services/$service";
      my @items = get_field_array("components");
      my @components;
      foreach(@items){
          push(@components, get_field2($_, "ServiceComponentInfo.component_name"));
      }
      @components = sort @components;
      if($quit){
          print "cluster '$cluster', service '$service' components:\n\n" . join("\n", @components) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
      return @components;
  }
  
  sub list_service_nodes(;$){
      my $quit = shift;
      $cluster   or usage "--cluster required";
      $service   or usage "--service required";
      $component or usage "--component required";
      $json = curl_ambari "$url_prefix/clusters/$cluster/services/$service/components/$component";
      my @nodes;
      my $host;
      foreach (get_field_array("host_components")){
          $host = get_field2($_, "HostRoles.host_name");
          push(@nodes, $host);
      }
      if($quit){
          my $num_nodes = scalar @nodes;
          plural $num_nodes;
          print "$num_nodes node$plural in cluster '$cluster' service '$service' component '$component':\n\n" . join("\n", @nodes) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
      return @nodes;
  }
  
  sub list_users(;$){
      my $quit = shift;
      $json = curl_ambari "$url_prefix/users?fields=*";
      my %users;
      my $user;
      # older Ambari called it roles
      my @roles;
      # newer Ambari 2.1.0 calls it groups
      my @groups;
      foreach(get_field_array("items")){
          #@users{get_field2($_, "Users.user_name")} = get_field2_array($_, "Users.roles");
          if(defined($_->{"Users"}->{"roles"})){
              @roles = get_field2_array($_, "Users.roles");
              @users{get_field2($_, "Users.user_name")} = @roles;
          } elsif(defined($_->{"Users"}->{"groups"})){
              @groups = get_field2_array($_, "Users.groups");
              @users{get_field2($_, "Users.user_name")} = @groups;
          } else {
              code_error("could not find Users.roles or Users.groups. $nagios_plugins_support_msg_api");
          }
      }
      if($quit){
          print "Ambari users:\n\n";
          foreach(sort keys %users){
              print $_;
              if($verbose){
                  if(@roles){
                      print " [roles: ";
                  } elsif(@groups){
                      print " [groups: ";
                  } else {
                      code_error("could not find Ambari roles or groups, caught late. $nagios_plugins_support_msg_api");
                  }
                  if($users{$_}){
                      print join(",", $users{$_})
                  } else {
                      print "<none>";
                  }
                  print "]";
              }
              print "\n";
          }
          exit $ERRORS{"UNKNOWN"};
      }
      return %users;
  }
  
  sub listing_ambari_components(){
      $list_clusters       +
      $list_nodes          +
      $list_svc_nodes      +
      $list_svc_components +
      $list_svcs           +
      $list_users;
  }
  
  sub list_ambari_components(){
      if(listing_ambari_components() > 1){
          usage "cannot specify more than one --list operation";
      }
      list_clusters(1)           if($list_clusters);
      list_nodes(1)              if($list_nodes);
      list_service_components(1) if($list_svc_components);
      list_service_nodes(1)      if($list_svc_nodes);
      list_services(1)           if($list_svcs);
      list_users(1)              if($list_users);
  }
  
  sub validate_ambari_cluster($){
      my $cluster = shift;
      defined($cluster) or usage "cluster not defined";
      $cluster =~ /^\s*([\w\s\.-]+)\s*$/ or usage "Invalid cluster name given, may only contain alphanumeric, space, dash, dots or underscores";
      $cluster = $1;
      vlog_option "cluster", $cluster;
      return $cluster;
  }
  
  sub validate_ambari_component($){
      my $component = shift;
      defined($component) or usage "component not defined";
      $component =~ /^\s*([\w-]+)\s*$/ or usage "Invalid component given, use --list-components to see available components for a given cluster service";
      $component = uc $1;
      vlog_option "component", $component;
      return $component;
  }
  
  sub validate_ambari_node($){
      my $node = shift;
      defined($node) or usage "node not defined";
      $node = isHostname($node) || usage "invalid node given";
      vlog_option "node", $node;
      return $node;
  }
  
  sub validate_ambari_service($){
      my $service = shift;
      defined($service) or usage "service not defined";
      $service    =~ /^\s*([\w-]+)\s*$/ or usage "Invalid service name given, must be alphanumeric with dashes";
      $service = uc $1;
      vlog_option "service", $service;
      return $service;
  }
  
  1;
HARISEKHON_AMBARI

$fatpacked{"HariSekhon/Cassandra.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_CASSANDRA';
  #
  #  Author: Hari Sekhon
  #  Date: 2013-11-03 03:58:28 +0000 (Sun, 03 Nov 2013)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  package HariSekhon::Cassandra;
  
  $VERSION = "0.2";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Carp;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      %DEFAULT_CASSANDRA_PORT
                      %cassandra_options
                      $cassandra_cql_port
                      $cassandra_jmx_port
                      $cassandra_thrift_port
                      set_cassandra_port
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  our %DEFAULT_CASSANDRA_PORT = (
      "CQL"    => 9042,
      "JMX"    => 7199,
      "THRIFT" => 9160,
  );
  
  env_creds("CASSANDRA");
  
  our %cassandra_options = (
      "H|host=s"         => [ \$main::host,         "Cassandra node         (\$CASSANDRA_HOST, \$HOST)" ],
  );
  
  sub set_cassandra_port($){
      my $type         = shift;
      defined($type) or code_error "no type passed to set_cassandra_port";
      defined($DEFAULT_CASSANDRA_PORT{$type}) or code_error "'$type' cassandra port not defined in HariSekhon::Cassandra::DEFAULT_CASSANDRA_PORT hash, passed in wrong type as arg?";
      %cassandra_options = (
          %cassandra_options,
          "P|port=s"         => [ \$main::port,         sprintf("Cassandra %s port     (\$CASSANDRA_PORT, \$PORT, default: %d)", $type, $DEFAULT_CASSANDRA_PORT{$type}) ],
          "u|user=s"         => [ \$main::user,         sprintf("Cassandra %s user     (optional, \$CASSANDRA_USERNAME, \$CASSANDRA_USER, \$USERNAME, \$USER)", $type) ],
          "p|password=s"     => [ \$main::password,     sprintf("Cassandra %s password (optional, \$CASSANDRA_PASSWORD, \$PASSWORD)", $type) ],
      );
      return $DEFAULT_CASSANDRA_PORT{$type};
  }
  
  1;
HARISEKHON_CASSANDRA

$fatpacked{"HariSekhon/Cassandra/Nodetool.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_CASSANDRA_NODETOOL';
  #
  #  Author: Hari Sekhon
  #  Date: 2013-11-03 03:58:28 +0000 (Sun, 03 Nov 2013)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  package HariSekhon::Cassandra::Nodetool;
  
  $VERSION = "0.2.12";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/../..";
  }
  use HariSekhonUtils;
  use HariSekhon::Cassandra;
  use Carp;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                          $nodetool
                          $nodetool_errors_regex
                          $nodetool_status_header_regex
                          %nodetool_options
                          check_nodetool_errors
                          die_nodetool_unrecognized_output
                          nodetool_options
                          skip_nodetool_output
                          validate_nodetool
                          validate_nodetool_options
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  $ENV{"PATH"} .= ":/usr/bin:/usr/sbin:/usr/local/cassandra/bin:/opt/cassandra/bin:/cassandra/bin";
  
  our $nodetool = "nodetool";
  
  sub validate_nodetool ($) {
      my $nodetool = shift;
      defined($nodetool) or usage "nodetool not defined";
      $nodetool = validate_filename($nodetool, "nodetool");
      $nodetool =~ /(?:^|\/)nodetool$/ or usage "invalid nodetool path given, must be the path to the nodetool command";
      $nodetool = which($nodetool, 1);
      return $nodetool;
  }
  
  $port = set_cassandra_port("JMX");
  
  our %nodetool_options = (
      %cassandra_options,
      "n|nodetool=s"     => [ \$nodetool, "Path to 'nodetool' command if not in \$PATH ($ENV{PATH})" ],
  );
  @usage_order = qw/nodetool host port user password warning critical/;
  
  sub nodetool_options(;$$$$){
      my $host            = shift;
      my $port            = shift;
      my $user            = shift;
      my $password        = shift;
      my $options         = "";
      # don't replace $host with IP as it can break load balancer routing with '503 Service Temporarily Unavailable'
      validate_resolvable($host)  if defined($host);
      $options .= "--host '$host' "           if defined($host);
      $options .= "--port '$port' "           if defined($port);
      $options .= "--username '$user' "       if defined($user);
      $options .= "--password '$password' "   if defined($password);
      return $options;
  }
  
  sub validate_nodetool_options($$$$$){
      my $nodetool = shift;
      my $host     = shift;
      my $port     = shift;
      my $user     = shift;
      my $password = shift;
      $nodetool = validate_nodetool($nodetool);
      $host     = validate_host($host)         if defined($host);
      $port     = validate_port($port)         if defined($port);
      $user     = validate_user($user)         if defined($user);
      $password = validate_password($password) if defined($password);
      return ($nodetool, $host, $port, $user, $password);
  }
  
                                  #You must set the CASSANDRA_CONF and CLASSPATH vars
  our $nodetool_errors_regex = qr/
                                  You\s+must\s+set |
                                  Cannot\s+resolve |
                                  unknown\s+host   |
                                  connection\s+refused  |
                                  failed\s+to\s+connect |
                                  error |
                                  user  |
                                  password |
                                  Exception(?!s\s*:\s*\d+) |
                                  in thread
                               /xi;
  
  sub check_nodetool_errors($){
      @_ or code_error "no input passed to check_nodetool_errors()";
      my $str = join(" ", @_);
      quit "CRITICAL", $str if $str =~ /$nodetool_errors_regex/;
  }
  
  sub skip_nodetool_output($){
      @_ or code_error "no input passed to skip_nodetool_output()";
      my $str = join(" ", @_);
      return 1 if $str =~ /^\s*$/;
      if(skip_java_output($str)){
          return 1;
      }
      return 0;
  }
  
  # Cassandra 2.0 DataStax Community Edition (nodetool version gives 'ReleaseVersion: 2.0.2')
  our $nodetool_status_header_regex = qr/
                                         ^Note |
                                         ^Datacenter |
                                         ^========== |
                                         ^Status=Up\/Down |
                                         ^\|\/\s+State=Normal\/Leaving\/Joining\/Moving |
                                         ^--\s+Address\s+
                                      /xi;
  sub die_nodetool_unrecognized_output($){
      @_ or code_error "no input passed to die_nodetool_unrecognized_output to check";
      my $str = join(" ", @_);
      quit "UNKNOWN", sprintf("unrecognized output '%s', nodetool output format may have changed, aborting, $nagios_plugins_support_msg", $str);
  }
  
  1;
HARISEKHON_CASSANDRA_NODETOOL

$fatpacked{"HariSekhon/ClouderaManager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_CLOUDERAMANAGER';
  #
  #  Author: Hari Sekhon
  #  Date: 2014-04-11 20:21:20 +0100 (Fri, 11 Apr 2014)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  # Forked from check_cloudera_manager_metrics.pl (2013) from the Advanced Nagios Plugins Collection
  #
  # to share with various newer Cloudera Manager check programs
  
  package HariSekhon::ClouderaManager;
  
  $VERSION = "0.6.1";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Carp;
  use JSON 'decode_json';
  use LWP::UserAgent;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $api
                      $activity
                      $cluster
                      $cm_mgmt
                      $default_port
                      $hostid
                      $json
                      $list_activities
                      $list_clusters
                      $list_hosts
                      $list_nameservices
                      $list_roles
                      $list_services
                      $nameservice
                      $protocol
                      $role
                      $service
                      $ssl_ca_path
                      $ssl_port
                      $tls
                      $tls_noverify
                      $ua
                      $url
                      $url_prefix
                      %cm_options
                      %cm_option_cluster
                      %cm_options_tls
                      %cm_options_list
                      %cm_options_list_basic
                      cm_query
                      check_cm_field
                      list_activities
                      list_clusters
                      list_hosts
                      list_nameservices
                      list_roles
                      list_services
                      list_cm_components
                      listing_cm_components
                      validate_cm_activity
                      validate_cm_cluster
                      validate_cm_cluster_options
                      validate_cm_hostid
                      validate_cm_nameservice
                      validate_cm_role
                      validate_cm_service
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  our $ua = LWP::UserAgent->new;
  
  our $protocol     = "http";
  # update: originally used v1 but Cloudera has removed APIs v1 - v5 from Cloudera Manager 6.x
  # https://docs.cloudera.com/documentation/enterprise/6/release-notes/topics/rg_deprecated_items.html
  our $api          = "/api/v6";
  our $default_port = 7180;
  $port             = $default_port;
  our $ssl_port     = 7183;
  
  our $activity;
  our $cluster;
  our $cm_mgmt;
  our $hostid;
  our $json;
  our $nameservice;
  our $role;
  our $service;
  our $ssl_ca_path;
  our $tls;
  our $tls_noverify;
  our $url;
  our $url_prefix;
  
  our $list_activities    = 0;
  our $list_clusters      = 0;
  our $list_hosts         = 0;
  our $list_nameservices  = 0;
  our $list_roles         = 0;
  our $list_services      = 0;
  
  env_creds(["CLOUDERA_MANAGER", "CM"], "Cloudera Manager");
  
  env_vars(["CLOUDERA_MANAGER_CLUSTER", "CLOUDERA_CLUSTER", "CM_CLUSTER"], \$cluster);
  env_vars(["CLOUDERA_MANAGER_TLS", "CLOUDERA_MANAGER_SSL"], \$tls);
  
  our %cm_options_tls = (
      "T|tls"            => [ \$tls,          "Use TLS connection to Cloudera Manager (\$CLOUDERA_MANAGER_TLS, \$CLOUDERA_MANAGER_SSL) (automatically updates port to $ssl_port if still set to $default_port to save one 302 redirect round trip)" ],
      "ssl-CA-path=s"    => [ \$ssl_ca_path,  "Path to CA certificate directory for validating SSL certificate (automatically enables --tls)" ],
      "tls-noverify"     => [ \$tls_noverify, "Do not verify SSL certificate from Cloudera Manager (automatically enables --tls)" ],
  );
  
  our %cm_option_cluster = (
      "C|cluster=s"      => [ \$cluster,      "Cluster Name as shown in Cloudera Manager (eg. \"Cluster - CDH4\", \$CLOUDERA_MANAGER_CLUSTER, \$CLOUDERA_CLUSTER, \$CM_CLUSTER)" ],
  );
  
  our %cm_options = (
      %cm_options_tls,
      %cm_option_cluster,
      "S|service=s"      => [ \$service,      "Service Name as shown in Cloudera Manager (eg. hdfs1, mapreduce4). Requires --cluster" ],
      "I|hostId=s"       => [ \$hostid,       "FQDN or HostId of node, see --list-hosts" ],
      "N|nameservice=s"  => [ \$nameservice,  "Nameservice (as specified in your HA configuration under dfs.nameservices). Requires --cluster and --service, see --list-nameservices" ],
      "R|roleId=s"       => [ \$role,         "RoleId (eg. hdfs4-NAMENODE-73d774cdeca832ac6a648fa305019cef). Requires --cluster and --service, or --CM-mgmt, see --list-roles for what to pass this option" ],
      "M|CM-mgmt"        => [ \$cm_mgmt,      "Cloudera Manager Management services" ],
  );
  
  our %cm_options_list_basic = (
      "list-clusters"     => [ \$list_clusters,           "List clusters for a given cluster service. Requires --cluster and --service" ],
      "list-hosts"        => [ \$list_hosts,              "List host id of nodes managed my Cloudera Manager" ],
      "list-services"     => [ \$list_services,           "List services for a given cluster. Convenience switch to find the serviceId to query, prints service ids and exits immediately. Requires --cluster" ],
  );
  
  our %cm_options_list = (
      "list-activities"   => [ \$list_activities,          "List activities for a given cluster service. Requires --cluster and --service" ],
      "list-nameservices" => [ \$list_nameservices,       "List nameservices for a given cluster service. Requires --cluster and --service. Service should be an HDFS service id" ],
      "list-roles"        => [ \$list_roles,              "List roles for a given cluster service. Requires --cluster and --service" ],
      %cm_options_list_basic,
  );
  
  @usage_order = qw/host port user password tls ssl-CA-path tls-noverify metrics all-metrics cluster service hostId activityId nameservice roleId CM-mgmt list-activities list-clusters list-hosts list-nameservices list-roles list-services warning critical/;
  
  sub cm_query(;$) {
      my $no_items;
      $tls = 1 if(defined($ssl_ca_path) or defined($tls_noverify));
      if(defined($tls_noverify)){
          $ua->ssl_opts( verify_hostname => 0 );
          $tls = 1;
      }
      if(defined($ssl_ca_path)){
          $ssl_ca_path = validate_directory($ssl_ca_path, "SSL CA directory", undef, "no vlog");
          $ua->ssl_opts( SSL_ca_path => $ssl_ca_path );
          $tls = 1;
      }
      if($tls){
          vlog_option "TLS enabled",  "true";
          vlog_option "SSL CA Path",  $ssl_ca_path  if defined($ssl_ca_path);
          vlog_option "TLS noverify", $tls_noverify ? "true" : "false";
      }
      if($tls){
          $protocol = "https";
          if($port == 7180){
              vlog2 "overriding default http port 7180 to default tls port 7183";
              $port = $ssl_port;
          }
      }
      # querying this behind and application load balancer will break with a '503 Service Temporarily Unavailable' if using IP rather than hostname, so just validate that we don't get a DNS error and then go via the FQDN to allow the LB to route the request
      #$host = validate_resolvable($host);
      validate_resolvable($host);
      $url_prefix = "$protocol://$host:$port";
  
      # Doesn't work
      #$ua->credentials("$host:$port", "Cloudera Manager", $user, $password);
      #$ua->credentials($host, "Cloudera Manager", $user, $password);
      $ua->show_progress(1) if $debug;
  
      $url = "$url_prefix$url";
      vlog2 "querying $url";
      my $req = HTTP::Request->new('GET', $url);
      $req->authorization_basic($user, $password);
      my $response = $ua->request($req);
      my $content  = $response->content;
      chomp $content;
      vlog3 "returned HTML:\n\n" . ( $content ? $content : "<blank>" ) . "\n";
      vlog2 "http code: " . $response->code;
      vlog2 "message: " . $response->message;
      if(!$response->is_success){
          my $err = "failed to query Cloudera Manager at '$url_prefix': " . $response->code . " " . $response->message;
          if($content =~ /"message"\s*:\s*"(.+)"/){
              $err .= ". Message returned by CM: $1";
          }
          if($content =~ /java\.net\.NoRouteToHostException/i){
              $err .= " (Cluster host on which the required components are deployment must be down)";
          } elsif($content =~ /org\.apache\.avro\.AvroRemoteException: java\.net\.ConnectException: Connection refused/i){
              $err .= " (Mgmt services stopped?)";
          } elsif($response->message =~ /Can't verify SSL peers without knowing which Certificate Authorities to trust/){
              $err .= ". Do you need to use --ssl-CA-path or --tls-noverify?";
          }
          quit "CRITICAL", $err;
      }
      unless($content){
          quit "CRITICAL", "blank content returned by Cloudera Manager at '$url_prefix'";
      }
  
      vlog2 "parsing output from Cloudera Manager\n";
  
      # give a more user friendly message than the decode_json's die 'malformed JSON string, neither array, object, number, string or atom, at character offset ...'
      #isJson() used recursive regex which broke older clients
      # is_valid_json give ugly errors
      #try{
      #    is_valid_json($content) or quit "CRITICAL", "invalid json returned by Cloudera Manager at '$url_prefix', did you try to connect to the SSL port without --tls?";
      #};
      try{
          $json = decode_json $content;
      };
      catch{
          quit "invalid json returned by Cloudera Manager at '$url_prefix', did you try to connect to the SSL port without --tls?";
      };
      return $json;
  }
  
  sub check_cm_field($){
      my $field = shift;
      defined($json->{$field}) or quit "UNKNOWN", "field '$field' not returned from Cloudera Manager. $nagios_plugins_support_msg_api";
      $json->{$field} =~ /^\s*$/ and quit "UNKNOWN", "field '$field' is empty";
  }
  
  # XXX: maybe could do something more with these, such as N out of M failed
  sub list_activities(;$){
      my $quit = shift;
      unless(defined($cluster) and defined($service)){
          usage "must define cluster and service to be able to list activities";
      }
      $url = "$api/clusters/$cluster/services/$service/activities";
      cm_query();
      my %activities;
      my @activities;
      foreach my $item (@{$json->{"items"}}){
          foreach(qw/name id/){
              code_error "no '$_' field returned in item from activity listing from Cloudera Manager at '$url_prefix'. $nagios_plugins_support_msg_api" unless defined($item->{$_});
          }
          push(@activities, $item->{"id"} . " => " . $item->{"name"});
          $activities{$item->{"name"}} = $item->{"id"};
      }
      @activities = sort @activities;
      if($quit){
          print "activities available for cluster '$cluster', service '$service':\n\n" . join("\n", @activities) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
      return %activities;
  }
  
  sub list_clusters(;$){
      my $quit = shift;
      $url = "$api/clusters";
      cm_query();
      my %clusters;
      foreach my $item (@{$json->{"items"}}){
          foreach(qw/name version/){
              defined($item->{$_}) or quit "UNKNOWN", "'$_' field not returned in item from cluster listing from Cloudera Manager at '$url_prefix'. $nagios_plugins_support_msg_api";
          }
          $clusters{$item->{"name"}} = $item->{"version"};
      }
      if($quit){
          print "CM clusters available:\n\n";
          printf("%-20s => CDH version\n\n", "cluster name");
          foreach(sort keys %clusters){
              printf("%-20s => %s\n", $_, $clusters{$_});
          }
          exit $ERRORS{"UNKNOWN"};
      }
      return %clusters;
  }
  
  sub list_hosts(;$){
      my $quit = shift;
      $url = "$api/hosts";
      cm_query();
      #my %hosts;
      my @hosts;
      foreach my $item (@{$json->{"items"}}){
          foreach(qw/hostname hostId/){
              defined($item->{$_}) or quit "UNKNOWN", "'$_' field not returned in item from host listing from Cloudera Manager at '$url_prefix'. $nagios_plugins_support_msg_api";
          }
          #$hosts{$item->{"hostname"}} = $item->{"hostId"};
          push(@hosts, $item->{"hostname"});
      }
      @hosts = sort @hosts;
      if($quit){
          #printf("%-36s => %s\n\n", "hostId", "hostname");
          #foreach(sort keys %hosts){
          #    print $hosts{$_} . " => $_\n";
          #}
          #exit $ERRORS{"UNKNOWN"};
          print "hosts managed by Cloudera Manager:\n\n" . join("\n", @hosts) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
      #return %hosts;
      return @hosts;
  }
  
  sub list_nameservices(;$){
      my $quit = shift;
      unless(defined($cluster) and defined($service)){
          usage "must define cluster and service to be able to list nameservices";
      }
      $url = "$api/clusters/$cluster/services/$service/nameservices";
      cm_query();
      my @nameservices;
      foreach(@{$json->{"items"}}){
          if(defined($_->{"name"})){
              push(@nameservices, $_->{"name"});
          } else {
              code_error "no 'name' field returned in item from nameservice listing from Cloudera Manager at '$url_prefix'. $nagios_plugins_support_msg_api";
          }
      }
      @nameservices = sort @nameservices;
      if($quit){
          print "nameservices available for cluster '$cluster', service '$service':\n\n" . join("\n", @nameservices) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
      return @nameservices;
  }
  
  sub list_roles(;$){
      my $quit = shift;
      if(defined($cluster) and defined($service)){
          $url = "$api/clusters/$cluster/services/$service/roles";
      } elsif(defined($cm_mgmt)){
          $url = "$api/cm/service/roles";
      } else {
          usage "must define cluster and service or --CM-mgmt to be able to list roles";
      }
      cm_query();
      my @roles;
      foreach(@{$json->{"items"}}){
          if(defined($_->{"name"})){
              push(@roles, $_->{"name"});
          } else {
              code_error "no 'name' field returned in item from role listing from Cloudera Manager at '$url_prefix'. $nagios_plugins_support_msg_api";
          }
      }
      @roles = sort @roles;
      if($quit){
          if(defined($cluster) and defined($service)){
              print "roles available for cluster '$cluster', service '$service':\n\n" . join("\n", @roles) . "\n";
          } elsif(defined($cm_mgmt)){
              print "roles available for CM mgmt services:\n\n" . join("\n", @roles) . "\n";
          }
          exit $ERRORS{"UNKNOWN"};
      }
      return @roles;
  }
  
  sub list_services(;$){
      my $quit = shift;
      usage "must define cluster to be able to list services" unless defined($cluster);
      $url = "$api/clusters/$cluster/services";
      cm_query();
      my @services;
      foreach(@{$json->{"items"}}){
          if(defined($_->{"name"})){
              push(@services, $_->{"name"});
          } else {
              code_error "no 'name' field returned in item from service listing from Cloudera Manager at '$url_prefix'. $nagios_plugins_support_msg_api";
          }
      }
      @services = sort @services;
      if($quit){
          print "services available for cluster '$cluster':\n\n" . join("\n", @services) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
      return @services;
  }
  
  sub listing_cm_components(){
      $list_activities    +
      $list_clusters      +
      $list_hosts         +
      $list_nameservices  +
      $list_roles         +
      $list_services;
  }
  
  sub list_cm_components(){
      if(listing_cm_components() > 1){
          usage "cannot specify more than one --list operation";
      }
      list_activities(1)    if($list_activities);
      list_clusters(1)      if($list_clusters);
      list_hosts(1)         if($list_hosts);
      list_nameservices(1)  if($list_nameservices);
      list_roles(1)         if($list_roles);
      list_services(1)      if($list_services);
  }
  
  sub validate_cm_activity(){
      defined($activity) or usage "activity not defined";
      $activity =~ /^\s*([\w-]+)\s*$/ or usage "Invalid activity given, must be alphanumeric with dashes";
      $activity = $1;
      vlog_option "activity", $activity;
      return $activity;
  }
  
  sub validate_cm_cluster(){
      defined($cluster) or usage "cluster not defined";
      $cluster    =~ /^\s*([\w\s\.-]+)\s*$/ or usage "Invalid cluster name given, may only contain alphanumeric, space, dash, dots or underscores";
      $cluster = $1;
      vlog_option "cluster", $cluster;
      return $cluster;
  }
  
  sub validate_cm_hostid(){
      defined($hostid) or usage "host id not defined";
      $hostid = isHostname($hostid) || usage "invalid host id given";
      vlog_option "hostId", "$hostid";
      return $hostid;
  }
  
  sub validate_cm_nameservice(){
      defined($nameservice) or usage "nameservice not defined";
      $nameservice =~ /^\s*([\w-]+)\s*$/ or usage "Invalid nameservice given, must be alphanumeric with dashes";
      $nameservice = $1;
      vlog_option "nameservice", $nameservice;
      return $nameservice;
  }
  
  sub validate_cm_role(){
      defined($role) or usage "role not defined";
      $role =~ /^\s*([\w-]+-\w+-\w+)\s*$/ or usage "Invalid role id given, expected in format such as <service>-<role>-<hexid> (eg hdfs4-NAMENODE-73d774cdeca832ac6a648fa305019cef). Use --list-roles to see available roles + IDs for a given cluster service";
      $role = $1;
      vlog_option "roleId", $role;
      return $role;
  }
  
  sub validate_cm_service(){
      defined($service) or usage "service not defined";
      $service    =~ /^\s*([\w-]+)\s*$/ or usage "Invalid service name given, must be alphanumeric with dashes";
      $service = $1;
      vlog_option "service", $service;
      return $service;
  }
  
  sub validate_cm_cluster_options(){
      defined($hostid and ($cluster or $service or $activity or $nameservice or $role)) and usage "cannot mix --hostId with other options such as and --cluster/service/roleId/activityId at the same time";
      if(defined($cluster) and defined($service)){
          $cluster    = validate_cm_cluster();
          $service    = validate_cm_service();
          $url = "$api/clusters/$cluster/services/$service";
          if(defined($activity)){
              $activity = validate_cm_activity();
              $url .= "/activities/$activity";
          } elsif(defined($nameservice)){
              $nameservice = validate_cm_nameservice();
              $url .= "/nameservices/$nameservice";
          } elsif(defined($role)){
              $role = validate_cm_role();
              $url .= "/roles/$role";
          }
      } elsif(defined($hostid)){
          $hostid = validate_cm_hostid();
          $url .= "$api/hosts/$hostid";
      } elsif(listing_cm_components()){
      } else {
          usage "no valid combination of types given, must be one of the following combinations:
  
      --cluster --service
      --cluster --service --activityId
      --cluster --service --nameservice
      --cluster --service --roleId
      --hostId
      ";
      }
      if(listing_cm_components() > 1){
          usage "cannot specify more than one --list operation";
      }
  }
  
  1;
HARISEKHON_CLOUDERAMANAGER

$fatpacked{"HariSekhon/DataStax/OpsCenter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_DATASTAX_OPSCENTER';
  #
  #  Author: Hari Sekhon
  #  Date: 2014-09-13 15:44:47 +0100 (Sat, 13 Sep 2014)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying Hari Sekhon LICENSE file
  #
  
  package HariSekhon::DataStax::OpsCenter;
  
  $VERSION = "0.5.1";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/../..";
  }
  use HariSekhonUtils;
  use Carp;
  use Data::Dumper;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $cluster
                      $keyspace
                      $list_clusters
                      $list_keyspaces
                      $list_nodes
                      $node_ip
                      %clusteroption
                      %keyspaceoption
                      %nodeipoption
                      curl_opscenter
                      curl_opscenter_err_handler
                      list_clusters
                      list_keyspaces
                      list_nodes
                      validate_cluster
                      validate_keyspace
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  set_port_default(8888);
  
  env_creds("DataStax OpsCenter");
  
  our $cluster;
  our $keyspace;
  our $node_ip;
  our $list_clusters;
  our $list_keyspaces;
  our $list_nodes;
  
  env_vars(["DATASTAX_OPSCENTER_CLUSTER",  "CLUSTER"],  \$cluster);
  env_vars(["DATASTAX_OPSCENTER_KEYSPACE", "KEYSPACE"], \$keyspace);
  
  our %clusteroption = (
      "C|cluster=s"    =>  [ \$cluster,        "Cluster as named in DataStax OpsCenter (\$DATASTAX_OPSCENTER_CLUSTER, \$CLUSTER). See --list-clusters" ],
      "list-clusters"  =>  [ \$list_clusters,  "List clusters managed by DataStax OpsCenter" ],
  );
  our %keyspaceoption = (
      "K|keyspace=s"   =>  [ \$keyspace,       "KeySpace to check (\$DATASTAX_OPSCENTER_KEYSPACE, \$KEYSPACE). See --list-keyspaces" ],
      "list-keyspaces" =>  [ \$list_keyspaces, "List keyspaces in given Cassandra cluster managed by DataStax OpsCenter. Requires --cluster" ],
  );
  our %nodeipoption = (
      "N|node-ip=s"    => [ \$node_ip,    "Node IP for cluster node to fetch metrics for (optional). See --list-nodes" ],
      "list-nodes"     => [ \$list_nodes, "List nodes and their node IPs managed by DataStax OpsCenter. Requires --cluster" ],
  );
  
  splice @usage_order, 6, 0, qw/cluster keyspace node-ip list-clusters list-keyspaces list-nodes/;
  
  sub curl_opscenter_err_handler($){
      my $response = shift;
      my $content  = $response->content;
      my $json;
      my $additional_information = "";
      unless($response->code eq "200"){
          my $additional_information = "";
          my $json;
          if($json = isJson($content)){
              if(defined($json->{"status"})){
                  $additional_information .= ". Status: " . $json->{"status"};
              }
              if(defined($json->{"reason"})){
                  $additional_information .= ". Reason: " . $json->{"reason"};
              } elsif(defined($json->{"message"})){
                  $additional_information .= ". Message: " . $json->{"message"};
                  #if($json->{"message"} eq "Resource not found."){
                  #    $additional_information = ". Message: keyspace not found - wrong keyspace specified? (case sensitive)";
                  #}
              }
          }
          quit("CRITICAL", $response->code . " " . $response->message . $additional_information);
      }
      if($content =~ /^null$/i) {
          quit "UNKNOWN", $response->code. " ". $response->message . " - 'null' returned by DataStax OpsCenter - invalid parameter or combination of parameters or OpsCenter recently restarted?";
      }
      unless($content){
          quit("CRITICAL", "blank content returned from DataStax OpsCenter");
      }
  }
  
  sub curl_opscenter($;$$){
      my $path = shift;
      my $ssl  = shift;
      my $type = shift() || 'GET';
      my $http = "http";
      $http .= "s" if $ssl;
      ($host and $port and $user and $password) or code_error "host/port/user/password not set before calling curl_opscenter()";
      $path =~ s/^\///g;
      $json = curl_json "$http://$host:$port/$path", "DataStax OpsCenter", $user, $password, \&curl_opscenter_err_handler, $type;
  }
  
  sub list_clusters(){
      if($list_clusters){
          $json = curl_opscenter "cluster-configs";
          vlog3 Dumper($json);
          print "Clusters managed by DataStax OpsCenter:\n\n";
          foreach(sort keys %{$json}){
              print "$_\n";
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub list_keyspaces(){
      if($list_keyspaces){
          $cluster or code_error "list_keyspaces() called without cluster being defined";
          $json = curl_opscenter "$cluster/keyspaces";
          vlog3 Dumper($json);
          print "Keyspaces in cluster '$cluster':\n\n";
          foreach(sort keys %{$json}){
              print "$_\n";
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub list_nodes(){
      if($list_nodes){
          $cluster or code_error "list_nodes() called without cluster being defined";
          $json = curl_opscenter "$cluster/nodes";
          vlog3 Dumper($json);
          print "Nodes in cluster '$cluster':\n\n";
          foreach(@{$json}){
              print get_field2($_, "node_name") . " => " . get_field2($_, "node_ip") . "\n";
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub validate_cluster(){
      unless($list_clusters){
          $cluster or usage "must specify cluster, use --list-clusters to show clusters managed by DataStax OpsCenter";
          $cluster =~ /^([\w\s-]+)$/ or usage "invalid cluster defined: must be alphanumeric, may contain spaces, dashes and underscores";
          $cluster = $1;
          vlog_option "cluster", $cluster;
      }
  }
  
  sub validate_keyspace(){
      unless($list_clusters or $list_keyspaces){
          $keyspace or usage "must specify keyspace, use --list-keyspaces to show keyspaces managed by Cassandra cluster '$cluster'";
          $keyspace = validate_chars($keyspace, "keyspace", '\w');
      }
  }
  
  1;
HARISEKHON_DATASTAX_OPSCENTER

$fatpacked{"HariSekhon/Datameer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_DATAMEER';
  #
  #  Author: Hari Sekhon
  #  Date: 2013-12-05 21:28:36 +0000 (Thu, 05 Dec 2013)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  package HariSekhon::Datameer;
  
  $VERSION = "0.1";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Carp;
  use JSON::XS;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                       $DATAMEER_DEFAULT_PORT
                       %datameer_options
                       %datameer_job_state
                       datameer_curl
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  our $DATAMEER_DEFAULT_PORT = 8080;
  $port = $DATAMEER_DEFAULT_PORT;
  
  env_creds("DATAMEER");
  
  our %datameer_options = (
      "H|host=s"         => [ \$host,         "Datameer server (\$DATAMEER_HOST, \$HOST)" ],
      "P|port=s"         => [ \$port,         "Datameer port   (\$DATAMEER_PORT, \$PORT, default: $DATAMEER_DEFAULT_PORT)" ],
      %useroptions,
  );
  
  our %datameer_job_state;
  $datameer_job_state{"OK"}       = [qw/RUNNING WAITING_FOR_OTHER_JOB COMPLETED QUEUED/];
  $datameer_job_state{"WARNING"}  = [qw/COMPLETED_WITH_Warnings CANCELED CANCELLED/];
  $datameer_job_state{"CRITICAL"} = [qw/ERROR/];
  
  sub datameer_curl($$$){
      # curl takes care of the error handling in HariSekhonUtils
      my $content = curl $_[0], "Datameer", $_[1], $_[2];
  
      my $json;
      try{
          $json = decode_json $content;
      };
      catch{
          quit "CRITICAL", "invalid json returned by '$host:$port'";
      };
      if(isHash($json) and defined($json->{"error"})){
          quit "CRITICAL", $json->{"error"};
      }
  
      return $json;
  }
HARISEKHON_DATAMEER

$fatpacked{"HariSekhon/Elasticsearch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_ELASTICSEARCH';
  #
  #  Author: Hari Sekhon
  #  Date: 2014-06-07 11:48:30 +0100 (Sat, 07 Jun 2014)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  package HariSekhon::Elasticsearch;
  
  $VERSION = "0.7.0";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Carp;
  use Data::Dumper;
  use LWP::Simple '$ua';
  
  set_port_default(9200);
  
  env_creds("ElasticSearch");
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $index
                      $list_indices
                      $list_nodes
                      $list_types
                      $node
                      $type
                      $ua
                      %elasticsearch_index
                      %elasticsearch_node
                      %elasticsearch_type
                      %es_status_map
                      check_elasticsearch_status
                      check_es_status
                      curl_elasticsearch
                      curl_elasticsearch_raw
                      delete_elasticsearch_index
                      ESIndexExists
                      isElasticSearchCluster
                      isESCluster
                      isElasticSearchIndex
                      isElasticSearchType
                      isESIndex
                      isESType
                      get_elasticsearch_indices
                      get_ES_indices
                      get_elasticsearch_nodes
                      get_ES_nodes
                      list_elasticsearch_indices
                      list_es_indices
                      list_elasticsearch_nodes
                      list_es_nodes
                      validate_elasticsearch_alias
                      validate_es_alias
                      validate_elasticsearch_cluster
                      validate_es_cluster
                      validate_elasticsearch_index
                      validate_es_index
                      validate_elasticsearch_type
                      validate_es_type
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  our $index;
  our $node;
  our $type;
  our $list_indices;
  our $list_nodes;
  our $list_types;
  
  our %es_status_map = (
      "green"  => "all primary and replica shards are active",
      "yellow" => "all primary shards are active but not all replica shards are online",
      "red"    => "not all primary shards are active! Some data will be missing from search queries!!",
  );
  
  env_var("ELASTICSEARCH_INDEX", \$index);
  env_var("ELASTICSEARCH_NODE",  \$node);
  env_var("ELASTICSEARCH_TYPE",  \$type);
  
  our %elasticsearch_index = (
      "I|index=s"     =>  [ \$index,          "Elasticsearch index (\$ELASTICSEARCH_INDEX)" ],
      "list-indices"  =>  [ \$list_indices,   "List Elasticsearch indices" ],
  );
  
  our %elasticsearch_type = (
      "Y|type=s"      =>  [ \$type,           "Elasticsearch type (\$ELASTICSEARCH_TYPE)" ],
      "list-types"    =>  [ \$list_types,     "List Elasticsearch types in given index" ],
  );
  
  our %elasticsearch_node = (
      "N|node=s"      =>  [ \$node,           "Elasticsearch node (\$ELASTICSEARCH_NODE)" ],
      "list-nodes"    =>  [ \$list_nodes,     "List Elasticsearch nodes" ],
  );
  
  splice @usage_order, 7, 0, qw/node index type shards replicas keys key value list-nodes list-indices list-types/;
  
  sub elasticsearch_err_handler($){
      my $response = shift;
      unless($response->code eq "200"){
          my $info = "";
          my $json;
          if($json = isJson($response->content)){
              foreach(qw/status error message reason/){
                  if(defined($json->{$_})){
                      $_ eq "status" and $json->{$_} eq $response->code and next;
                      my $tmp = $json->{$_};
                      $info .= ". " . ucfirst($_) . ": ";
                      if(isHash($tmp)){
                          my $reason            = get_field2($tmp, "reason", 1);
                          my $type              = get_field2($tmp, "type", 1);
                          my $root_cause_reason = get_field2($tmp, "root_cause.reason", 1);
                          my $root_cause_type   = get_field2($tmp, "root_cause.type", 1);
                          if($reason){
                              if($type){
                                  $info .= "$type: ";
                              }
                              $info .= "$reason";
                              if($root_cause_type and $root_cause_type ne $type){
                                  $info .= ": $root_cause_type";
                              }
                              if($root_cause_reason and $root_cause_reason ne $reason){
                                  $info .= ": $root_cause_reason";
                              }
                          } else {
                              $info .= Dumper($tmp);
                          }
                      } else {
                          $info .= $json->{$tmp};
                      }
                  }
              }
          }
          #$info =~ s/\. $//;
          #if($info){
          #    quit "CRITICAL", $info;
          #} else {
          #    quit "CRITICAL", $response->code . " " . $response->message;
          #}
          quit("CRITICAL", $response->code . " " . $response->message . $info);
      }
  }
  
  sub curl_elasticsearch_raw($;$$){
      my $url  = shift;
      my $type = shift() || "GET";
      my $body = shift;
      $url =~ s/^\///;
      if($url =~ /\?/){
          $url .= "&";
      } else {
          $url .= "?";
      }
      # Elasticsearch 5.0 no longer accepts the timeout parameter everywhere
      if($url ne '?' and
         $url !~ /_cat|_settings|_stats|_cluster/){
          $url .= sprintf("timeout=%ds&", minimum_value($timeout - 1, 1));
      }
      $url .= "pretty=true" if $verbose >= 3 or $debug;
      $url =~ s/\&$//;
      #my $content = curl "http://$host:$port/$url", "Elasticsearch", undef, undef, undef, $type, $body;
      my $content = undef;
      my $protocol = "http";
      if ($ssl) {
          $protocol = "https";
          if ($ssl_noverify) {
              $ua->ssl_opts(verify_hostname => 0, SSL_verify_mode => 0);
          }
      }
      if ($user and $password) {
          $content = curl "$protocol://$host:$port/$url", "Elasticsearch", $user, $password, \&elasticsearch_err_handler, $type, $body;
      } else {
          $content = curl "$protocol://$host:$port/$url", "Elasticsearch", undef, undef, \&elasticsearch_err_handler, $type, $body;
      }
      return $content;
  }
  
  sub curl_elasticsearch($;$$){
      my $content = curl_elasticsearch_raw $_[0], $_[1], $_[2];
      # _cat doesn't return json
      $json = isJson($content) or quit "CRITICAL", "non-json returned by ElasticSearch!";
      # probably not a good idea - lacks flexibility, may still be able to get partial information from returned json
      #if(get_field("timed_out")){
      #    quit "CRITICAL", "timed_out: true";
      #}
      return $json;
  }
  
  sub check_elasticsearch_status($;$){
      my $es_status = shift;
      my $msg .= ", status: '$es_status'";
      if($es_status eq "green"){
          # ok
      } elsif($es_status eq "yellow"){
          warning;
      } else {
          critical;
      }
      if($verbose){
          if(grep { $_ eq $es_status } keys %es_status_map){
              $msg .= " (" . $es_status_map{$es_status} . ")";
          }
      }
      return $msg;
  }
  *check_es_status = \&check_elasticsearch_status;
  
  sub delete_elasticsearch_index($){
      my $index = shift;
      my $content = curl_elasticsearch_raw "/$index", "DELETE";
      #tprint $content;
      return $content;
  }
  
  sub isElasticSearchCluster($){
      my $cluster = shift;
      return isAlNum($cluster);
      #defined($cluster) or return undef;
      ## must be lowercase
      #$cluster =~ /^([a-z0-9]+)$/ or return undef;
      #$cluster = $1;
      #return $cluster;
  }
  *isESCluster = \&isElasticSearchCluster;
  
  sub isElasticSearchIndex($){
      my $index = shift;
      defined($index) or return undef;
      # must be lowercase, can't start with an underscore
      $index =~ /^([a-z0-9\.][a-z0-9\._-]+)$/ or return undef;
      $index = $1;
      return $index;
  }
  *isESIndex = \&isElasticSearchIndex;
  
  # check but I think Elasticsearch types can have uppercase
  #*isElasticSearchType = \&isElasticSearchIndex;
  sub isElasticSearchType($){
      my $type = shift;
      defined($type) or return undef;
      # must be lowercase, can't start with an underscore
      $type =~ /^([A-Za-z0-9\.][A-Za-z0-9\._-]+)$/ or return undef;
      $type = $1;
      return $type;
  }
  *isESType = \&isElasticSearchType;
  
  sub ESIndexExists($) {
      my $index = shift;
      isESIndex($index) or code_error "passed invalid index name to doesESIndexExist";
      # This rest API call doesn't seem to be available in 1.2.1, but works in 1.4.1
      # TODO: test this on newer elasticsearch
      #my $content = curl_elasticsearch_raw("/$index");
      #return $content =~ /^\A$index\Z$/m;
      return grep { $index eq $_ } get_ES_indices();
  }
  
  sub get_elasticsearch_indices {
      my $content = curl_elasticsearch_raw("/_cat/indices?h=index");
      return map { strip($_) } sort split(/\n/, $content);
  }
  *get_ES_indices = \&get_elasticsearch_indices;
  
  sub list_elasticsearch_indices {
      if($list_indices){
          my @indices = get_elasticsearch_indices();
          print "Elasticsearch Indices:\n\n";
          print "<none>\n" unless @indices;
          foreach(@indices){
              #my @parts = split(/\s+/, $_);
              #print "$parts[1]\n";
              print "$_\n";
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub get_elasticsearch_nodes {
      # could use /_nodes instead but it's more cleanup of ip etc
      #my $content = curl_elasticsearch_raw("/_cat/nodes?h=host,ip,name");
      curl_elasticsearch("/_nodes");
      my @node_array;
      my %nodes = get_field_hash("nodes");
      foreach my $node_random_id(sort keys %nodes){
          my @node = (
              get_field("nodes.$node_random_id.host"),
              get_field("nodes.$node_random_id.ip"),
              get_field("nodes.$node_random_id.name")
          );
          push(@node_array, [@node]);
      }
  #    foreach my $line (split(/\n/, $content)){
  #        my @node_array = map { strip($_) } split(/\s+/, $line, 3);
  #        if(scalar @node_array == 3){
  #            push(@node_array, @node_array);
  #        } else {
  #            quit "UNKNOWN", "invalid node array length after parsing node list";
  #        }
  #    }
      return sort @node_array;
  }
  *get_ES_nodes = \&get_elasticsearch_nodes;
  
  sub list_elasticsearch_nodes {
      if($list_nodes){
          my @nodes = get_elasticsearch_nodes();
          print "Elasticsearch Nodes:\n\n";
          if(@nodes){
              printf "%-50s %-20s %s\n\n", "hostname", "ip", "name";
              foreach my $arr_ref (@nodes){
                  printf "%-50s %-20s %s\n", $$arr_ref[0], $$arr_ref[1], $$arr_ref[2];
              }
          } else {
              print "<none>\n"
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub validate_elasticsearch_alias($){
      my $alias = shift;
      defined($alias) or usage "Elasticsearch alias not defined";
      $alias = isESType($alias) or usage "invalid ElasticSearch alias name given, must be lowercase alphanumeric";
      vlog_option "alias", $alias;
      return $alias;
  }
  *validate_es_alias = \&validate_elasticsearch_alias;
  
  sub validate_elasticsearch_cluster($){
      my $cluster = shift;
      defined($cluster) or usage "Elasticsearch cluster not defined";
      $cluster = isESCluster($cluster) or usage "invalid ElasticSearch cluster name given, must be lowercase alphanumeric";
      vlog_option "cluster", $cluster;
      return $cluster;
  }
  *validate_es_cluster = \&validate_elasticsearch_cluster;
  
  sub validate_elasticsearch_index($){
      my $index = shift;
      defined($index) or usage "Elasticsearch index not defined";
      $index = isESIndex($index) or usage "invalid ElasticSearch index name given, must be lowercase alphanumeric";
      vlog_option "index", $index;
      return $index;
  }
  *validate_es_index = \&validate_elasticsearch_index;
  
  sub validate_elasticsearch_type($){
      my $type = shift;
      defined($type) or usage "Elasticsearch type not defined";
      $type = isESType($type) or usage "invalid ElasticSearch type name given, must be lowercase alphanumeric";
      vlog_option "type", $type;
      return $type;
  }
  *validate_es_type = \&validate_elasticsearch_type;
  
  1;
HARISEKHON_ELASTICSEARCH

$fatpacked{"HariSekhon/HBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_HBASE';
  #
  #  Author: Hari Sekhon
  #  Date: 2014-01-08 15:44:41 +0000 (Wed, 08 Jan 2014)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  package HariSekhon::HBase;
  
  $VERSION = "0.2";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Carp;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                          isHBaseColumnQualifier
                          isHBaseRowKey
                          isHBaseTable
                          validate_hbase_column_qualifier
                          validate_hbase_rowkey
                          validate_hbase_table
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  # based off my std lib from isDatabase* and validate_database_*
  
  sub isHBaseColumnQualifier ($) {
      my $column = shift;
      defined($column) or return undef;
      if($column =~ /^([A-Za-z][\w\s\(\)\:#]+)$/){
          return $1;
      }
      return undef;
  }
  
  sub isHBaseRowKey ($) {
      my $rowkey = shift;
      defined($rowkey) or return undef;
      if($rowkey =~ /^([A-Za-z][\w\:#]+)$/){
          return $1;
      }
      return undef;
  }
  
  sub isHBaseTable ($) {
      my $table = shift;
      defined($table) or return undef;
      if($table =~ /^([A-Za-z][\w\:]+)$/){
          return $1;
      }
      return undef;
  }
  
  sub validate_hbase_column_qualifier ($) {
      my $column = shift;
      defined($column) || usage "hbase column not defined";
      $column = isHBaseColumnQualifier($column) || usage "invalid hbase column qualifier defined";
      vlog_option("column qualifier", $column);
      return $column;
  }
  
  sub validate_hbase_rowkey ($) {
      my $rowkey = shift;
      defined($rowkey) || usage "hbase rowkey not defined";
      $rowkey = isHBaseRowKey($rowkey) || usage "invalid hbase rowkey defined: must be alphanumeric, colons and # are allowed for compound keys";
      vlog_option("rowkey", $rowkey);
      return $rowkey;
  }
  
  sub validate_hbase_table ($) {
      my $table = shift;
      defined($table) || usage "hbase table not defined";
      $table = isHBasetable($table) || usage "invalid hbase table defined: must be alphanumeric, colons and # are allowed for compound keys";
      vlog_option("table", $table);
      return $table;
  }
  
  1;
HARISEKHON_HBASE

$fatpacked{"HariSekhon/HBase/Thrift.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_HBASE_THRIFT';
  #
  #  Author: Hari Sekhon
  #  Date: 2013-07-28 23:56:03 +0100 (Sun, 28 Jul 2013)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  # Split off from my check_hbase_table.pl Nagios Plugin
  
  package HariSekhon::HBase::Thrift;
  
  $VERSION = "0.2.1";
  
  use strict;
  use warnings;
  
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/../..";
  }
  use HariSekhonUtils;
  use Thrift;
  use Thrift::Socket;
  use Thrift::BinaryProtocol;
  use Thrift::BufferedTransport;
  # Thrift generated bindings for HBase, provided in lib
  use Hbase::Hbase;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw(
                      connect_hbase_thrift
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  # using custom try/catch from my HariSekhonUtils as it's necessary to disable the custom die handler for this to work
  
  sub connect_hbase_thrift($$;$$){
      my $host = shift;
      my $port = shift;
      my $send_timeout = shift || 10000;
      my $recv_timeout = shift || 10000;
      my $client;
      my $protocol;
      my $socket;
      my $transport;
      validate_resolvable($host);
      vlog2 "connecting to HBase Thrift server at $host:$port\n";
      try {
          $socket    = new Thrift::Socket($host, $port);
      };
      catch_quit "failed to connect to Thrift server at '$host:$port'";
      try {
          $socket->setSendTimeout($send_timeout);
          $socket->setRecvTimeout($recv_timeout);
          $transport = new Thrift::BufferedTransport($socket,1024,1024);
      };
      catch_quit "failed to initiate Thrift Buffered Transport";
      try {
          $protocol  = new Thrift::BinaryProtocol($transport);
      };
      catch_quit "failed to initiate Thrift Binary Protocol";
      try {
          $client    = Hbase::HbaseClient->new($protocol);
      };
      catch_quit "failed to initiate HBase Thrift Client";
  
      $status = "OK";
  
      try {
          $transport->open();
      };
      catch_quit "failed to open Thrift transport to $host:$port";
  
      return $client;
  }
  
  1;
HARISEKHON_HBASE_THRIFT

$fatpacked{"HariSekhon/IBM/BigInsights.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_IBM_BIGINSIGHTS';
  #
  #  Author: Hari Sekhon
  #  Date: 2014-05-31 21:26:38 +0100 (Sat, 31 May 2014)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  package HariSekhon::IBM::BigInsights;
  
  $VERSION = "0.4";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/../..";
  }
  use HariSekhonUtils;
  use Carp;
  use Data::Dumper;
  use JSON;
  use LWP::UserAgent;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $api
                      $bigsheets_api
                      $protocol
                      $ua
                      %biginsights_options
                      curl_biginsights
                      curl_bigsheets
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  set_port_default(8080);
  
  our $ua = LWP::UserAgent->new;
  
  env_creds("BIGINSIGHTS", "IBM BigInsights Console");
  
  our %biginsights_options = (
      %hostoptions,
      %useroptions,
      %ssloptions,
  );
  
  our $api           = "data/controller";
  our $bigsheets_api = "bigsheets/api";
  
  our $protocol = "http";
  
  sub curl_biginsights($$$;$$){
      ($host and $port) or code_error "host and port not defined before calling curl_biginsights()";
      my $url_prefix = "$protocol://$host:$port";
      my $url      = shift;
      my $user     = shift;
      my $password = shift;
      my $err_sub  = shift   || \&curl_biginsights_err_handler;
      my $api      = shift() || $api;
      $url =~ s/^\///;
      $url = "$url_prefix/$api/$url";
      isUrl($url) or code_error "invalid URL '$url' supplied to curl_biginsights/bigsheets";
      my $content  = curl $url, "IBM BigInsights Console", $user, $password, $err_sub;
      try{
          $json = decode_json $content;
      };
      catch{
          quit "invalid json returned by IBM BigInsights Console at '$url_prefix', did you try to connect to the SSL port without --tls?";
      };
      vlog3(Dumper($json));
      return $json;
  }
  
  
  sub curl_bigsheets($$$){
      curl_biginsights $_[0], $_[1], $_[2], \&curl_bigsheets_err_handler, $bigsheets_api;
  }
  
  
  sub curl_biginsights_err_handler($){
      my $response = shift;
      my $content  = $response->content;
      my $json;
      my $additional_information = "";
      if($json = isJson($content)){
          if(defined($json->{"result"}{"error"})){
              quit "CRITICAL", "Error: " . $json->{"result"}{"error"};
          }
      }
      unless($response->code eq "200"){
          if($content =~ /not.+deployed/i and length(() = split("\n", $content)) < 3){
              $additional_information .= ". $content";
          }
          quit "CRITICAL", $response->code . " " . $response->message . $additional_information;
      }
      unless($content){
          quit "CRITICAL", "blank content returned by BigInsights Console";
      }
  }
  
  # http://www-01.ibm.com/support/knowledgecenter/SSPT3X_2.1.2/com.ibm.swg.im.infosphere.biginsights.analyze.doc/doc/bigsheets_restapi.html
  sub curl_bigsheets_err_handler($){
      my $response = shift;
      my $content  = $response->content;
      my $json;
      my $additional_information = "";
      if($json = isJson($content)){
          if(defined($json->{"errorMsg"})){
              $additional_information .= ". errorMsg: " . $json->{"errorMsg"};
          }
          if(defined($json->{"error"})){
              isHash($json->{"error"}) or quit "UNKNOWN", "error occurred but error field is not a hash as expected to obtain further information. $nagios_plugins_support_msg_api";
              if(defined($json->{"error"}{"errorCode"})){
                  $additional_information .= ". ErrorCode: " . $json->{"error"}{"errorCode"};
              }
              if(defined($json->{"error"}{"message"})){
                  $additional_information .= ". Message: " . $json->{"error"}{"message"};
              }
          }
      } else {
          if($content =~ /not.+deployed/i and length(() = split("\n", $content)) < 3){
              $additional_information .= ". $content";
          }
      }
      unless($response->code eq "200" or $response->code eq "201"){
          quit "CRITICAL", $response->code . " " . $response->message . $additional_information;
      }
      if(defined($json->{"errorMsg"})){
          if($json->{"errorMsg"} eq "Could not get Job status: null"){
              quit "UNKNOWN", "worksheet job run status: null (workbook not been run yet?)";
          }
          $additional_information =~ s/^\.\s+//;
          quit "CRITICAL", $additional_information;
      }
      unless($content){
          quit "CRITICAL", "blank content returned from by BigInsights Console";
      }
  }
  
  1;
HARISEKHON_IBM_BIGINSIGHTS

$fatpacked{"HariSekhon/MapR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_MAPR';
  #
  #  Author: Hari Sekhon
  #  Date: 2014-09-30 21:54:01 +0100 (Tue, 30 Sep 2014)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying Hari Sekhon LICENSE file
  #
  
  package HariSekhon::MapR;
  
  $VERSION = "0.5.2";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Data::Dumper;
  use LWP::UserAgent;
  
  our $ua = LWP::UserAgent->new;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $cluster
                      $list_clusters
                      $list_nodes
                      $list_services
                      $list_volumes
                      $node
                      $protocol
                      $service
                      $ssl
                      $ssl_ca_path
                      $ssl_noverify
                      $ua
                      $volume
                      %mapr_option_cluster
                      %mapr_option_node
                      %mapr_option_service
                      %mapr_option_volume
                      %mapr_options
                      curl_mapr
                      list_clusters
                      list_nodes
                      list_services
                      list_volumes
                      validate_cluster
                      validate_mapr_options
                      validate_service
                      validate_volume
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  set_port_default(8443);
  
  env_creds("MAPR", "MapR Control System");
  
  our $cluster;
  our $node;
  our $service;
  our $volume;
  our $list_clusters;
  our $list_nodes;
  our $list_services;
  our $list_volumes;
  
  env_vars(["MAPR_CLUSTER", "CLUSTER"], \$cluster);
  
  my $no_ssl;
  
  our %mapr_options = (
      %hostoptions,
      %useroptions,
      %ssloptions,
      "no-ssl"   =>  [ \$no_ssl,  "Don't use SSL, newer versions of MCS seem to only use SSL, use this only on older versions of MCS if you don't have SSL (you may need to also change the port to 8080 instead of 8443)" ],
  );
  delete $mapr_options{"S|ssl"};
  $mapr_options{"ssl-noverify"}[1] =~ s/\(.*//;
  
  our %mapr_option_cluster = (
      "C|cluster=s"   => [ \$cluster,       "Cluster Name as shown in MapR Control System (eg. \"my.cluster.com\", see --list-clusters, \$MAPR_CLUSTER, \$CLUSTER)" ],
      "list-clusters" => [ \$list_clusters, "Lists clusters managed by MapR Control System" ],
  );
  
  our %mapr_option_node = (
      "N|node=s"      => [ \$node,          "Node to check (see --list-nodes)" ],
      "list-nodes"    => [ \$list_nodes,    "Lists nodes managed by MapR Control System" ],
  );
  
  our %mapr_option_service = (
      "s|service=s"   => [ \$service,       "Check the specified service (see --list-services)" ],
      "list-services" => [ \$list_services, "Lists services" ],
  );
  
  our %mapr_option_volume = (
      "L|volume=s"    => [ \$volume,        "Volume to check (see --list-volumes)" ],
      "list-volumes"  => [ \$list_volumes,  "Lists volumes and their mount points" ],
  );
  
  splice @usage_order, 6, 0, qw/cluster node service volume list-clusters list-nodes list-services list-volumes ssl ssl-CA-path ssl-noverify no-ssl/;
  
  
  sub validate_mapr_options(){
      $host       = validate_host($host);
      $port       = validate_port($port);
      $user       = validate_user($user);
      $password   = validate_password($password);
      validate_ssl();
  }
  
  our $protocol = "https";
  
  sub curl_mapr($$$;$){
      ($host and $port) or code_error "host and port not defined before calling curl_mapr()";
      my $url      = shift() || code_error "no url suffix passed to curl_mapr()";
      my $user     = shift;
      my $password = shift;
      my $err_sub  = shift() || \&curl_mapr_err_handler;
      $url =~ s/^\/*//;
      $url or code_error "invalid url passed to curl_mapr()";
      if($no_ssl){
          $protocol = "http";
          # MapR 5.1 sandbox ships MCS without SSL still on 8443
          #if($port == 8443){
              #vlog2 "detected port still set to 8443 but using --no-ssl, switching to port 8080";
              #$port = 8080;
          #}
      }
      my $url_prefix = "$protocol://$host:$port";
      $url = "$url_prefix/rest/$url";
      isUrl($url) or code_error "invalid URL '$url' supplied to curl_mapr()";
      my $content = curl $url, "MapR Control System", $user, $password, $err_sub;
      vlog2("parsing output from MapR Control System\n");
      $json = isJson($content) or quit "CRITICAL", "invalid json returned by MapR Control System, perhaps you tried --no-ssl and SSL was used on that port? Try running with -vvv to debug and file as ticket if neccessary to https://github.com/harisekhon/nagios-plugins/issues";
      vlog3 Dumper($json);
      return $json;
  }
  
  
  sub curl_mapr_err_handler($){
      my $response = shift;
      my $content  = $response->content;
      my $additional_information = "";
      if(!$response->is_success){
          my $err = "failed to query MapR Control System: " . $response->code . " " . $response->message;
          if($content =~ /"message"\s*:\s*"(.+)"/){
              $err .= ". Message returned by MapR Control System: $1";
          }
          if($response->code eq 401 and $response->message eq "Unauthorized"){
              $err .= ". Invalid --user/--password?";
          }
          if($response->code eq 404 and $response->request->{"_uri"} =~ /blacklist\/listusers/){
              $err .= ". Blacklist users API endpoint is not implemented as of MCS 3.1. This has been confirmed with MapR, trying updating to a newer version of MCS";
          }
          if($response->message =~ /Can't verify SSL peers without knowing which Certificate Authorities to trust/ or
             $response->message =~ /certificate verify failed/){
              $err .= ". Do you need to use --ssl-CA-path or --ssl-noverify?";
          }
          quit "CRITICAL", $err;
      } elsif($json = isJson($response->content)){
          my $status = get_field2($json, "status");
          unless($status eq "OK"){
              my $err = "";
              foreach(get_field2_array($json, "errors")){
                  $err .= ". " . get_field2($_, "desc");
                  if($err =~ /Obtaining rlimit for resource disk failed with error - Unknown cluster parameter provided/){
                      $err .= ". You have supplied an invalid cluster name, see --list-clusters for the right cluster name";
                  }
              }
              quit "CRITICAL", "MapR Control System returned status='$status'$err";
          }
      }
      unless($content){
          quit "CRITICAL", "blank content returned by MapR Control System";
      }
  }
  
  
  sub list_clusters(){
      if($list_clusters){
          $json = curl_mapr("/dashboard/info", $user, $password);
          my @data = get_field_array("data");
          print "MapR Control System Clusters:\n\n";
          foreach(@data){
              print get_field2($_, "cluster.name") . "\n";
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  
  sub list_nodes(){
      if($list_nodes){
          $json = curl_mapr("/node/list?columns=hostname", $user, $password);
          my @data = get_field_array("data");
          print "MapR Control System nodes:\n\n";
          foreach(@data){
              print get_field2($_, "hostname") . "\n";
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub list_services(){
      if($list_services){
          if($node){
              $json = curl_mapr("/service/list?node=$node", $user, $password);
          } else {
              my $url = "/dashboard/info";
              $url .= "?cluster=$cluster" if $cluster;
              $json = curl_mapr($url, $user, $password);
          }
          print "MapR Services";
          print " on node '$node'" if $node;
          print " on cluster '$cluster'" if $cluster;
          print ":\n\n";
          my %services;
          if($node){
              foreach(get_field_array("data")){
                  $services{get_field2($_, "displayname")} = 1;
              }
          } else {
              foreach(get_field_array("data")){
                  my %services2 = get_field2_hash($_, "services");
                  foreach(keys %services2){
                      $services{$_} = 1;
                  }
              }
          }
          foreach(sort keys %services){
              print "$_\n";
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub list_volumes(){
      my %vols;
      if($list_volumes){
          my $url = "/volume/list";
          $url .= "?cluster=$cluster" if $cluster;
          $json = curl_mapr($url, $user, $password);
          foreach(get_field_array("data")){
              $vols{get_field2($_, "volumename")}{"mount"} = get_field2($_, "mountdir");
          }
          print "MapR-FS volumes:\n\n";
          printf("%-30s %s\n\n", "Name", "Mount Point");
          foreach my $vol (sort keys %vols){
              printf("%-30s %s\n", $vol, $vols{$vol}{"mount"});
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub validate_cluster($){
      my $cluster = shift;
      defined($cluster) or usage "cluster not specified";
      $cluster =~ /^([\w\.-]+)$/ or usage "invalid cluster name given, must be alphanumeric with dots and underscores permitted";
      $cluster = $1;
      vlog_option "cluster", $cluster;
      return $cluster;
  }
  
  
  sub validate_volume($){
      my $volume = shift;
      defined($volume) or usage "volume not specffied";
      if($volume){
          $volume =~ /^([A-Za-z0-9\._-]+)$/ or usage "invalid volume specified";
          $volume = $1;
      }
      return $volume;
  }
  
  
  sub validate_service($){
      my $service = shift;
      defined($service) or usage "service not specified";
      $service =~ /^(\w[\w\s-]+\w)$/ or usage "invalid service name, must be alphanumeric, may contain spaces/dashes";
      $service = $1;
      vlog_option "service", $service;
      return $service;
  }
  
  
  1;
HARISEKHON_MAPR

$fatpacked{"HariSekhon/MongoDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_MONGODB';
  #
  #  Author: Hari Sekhon
  #  Date: 2014-06-14 13:42:34 +0100 (Sat, 14 Jun 2014)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  package HariSekhon::MongoDB;
  
  $VERSION = "0.2.0";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Carp;
  use JSON;
  use MongoDB;
  use MongoDB::MongoClient;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $hosts
                      $sasl
                      $sasl_mechanism
                      $ssl
                      %mongo_host_option
                      %mongo_sasl_options
                      @hosts
                      @valid_concerns
                      connect_mongo
                      curl_mongo
                      validate_mongo_hosts
                      validate_mongo_sasl
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  # not used
  #set_port_default(27017);
  
  env_creds("MongoDB");
  
  our $hosts;
  our @hosts;
  
  # 'all' gets rejected by the MongoDB Perl Library
  #our @valid_concerns    = qw/1 2 majority all/;
  our @valid_concerns    = qw/1 2 majority/;
  
  our $sasl           = 0;
  our $sasl_mechanism = "GSSAPI";
  
  our %mongo_host_option = (
      "H|host=s"         => [ \$host,          "MongoDB host(s) to connect to, comma separated, with optional :<port> suffixes. Tries hosts in given order from left to right to find Primary for write. Specifying any one host is sufficient as the rest will be auto-determined to find the primary (\$MONGODB_HOST, \$HOST)" ],
  );
  
  our %mongo_sasl_options = (
      "ssl"                   => [ \$ssl,             "Enable SSL, MongoDB libraries must have been compiled with SSL and server must support it. Experimental" ],
      "sasl"                  => [ \$sasl,            "Enable SASL authentication, must be compiled in to the MongoDB perl driver to work. Experimental" ],
      "sasl-mechanism=s"      => [ \$sasl_mechanism,  "SASL mechanism (default: GSSAPI eg Kerberos on MongoDB Enterprise 2.4+ in which case this should be run from a valid kinit session, alternative PLAIN for LDAP using user/password against MongoDB Enterprise 2.6+ which is sent in plaintext so should be used over SSL). Experimental" ],
  );
  
  push(@usage_order, qw/ssl sasl sasl-mechanism/);
  
  sub connect_mongo($;$){
      my $hosts = shift;
      my $mongo_connect_options_hashref = shift() || {};
      my $client;
      if($user and $password){
          # doing it this way to avoid username/password fields which break unauthenticated even when supplying 'undef' values
          $hosts =~ s/mongodb:\/\///;
          $hosts = "mongodb://$user:$password\@$hosts";
      }
      try {
          $client = MongoDB::MongoClient->new(
                                              "host"           => $hosts,
                                              #"username"       => $user,
                                              #"password"       => $password,
                                              "db_name"        => "admin",
                                              # hangs when giving only nodes of a replica set that aren't the Primary
                                              #"find_master"    => 1,
                                              "timeout"        => int($timeout * 1000 / 4), # connection timeout
                                              #"wtimeout"       => $wtimeout,
                                              "query_timeout"  => int($timeout * 1000 / 4),
                                              "ssl"            => $ssl,
                                              "sasl"           => $sasl,
                                              "sasl-mechanism" => $sasl_mechanism,
                                              %{$mongo_connect_options_hashref},
                                             ) || quit "CRITICAL", "$!";
      };
      catch_quit "failed to connect to MongoDB host '$hosts'";
  
      vlog2 "connection initiated to $host\n";
      return $client;
  }
  
  
  sub curl_mongo($){
      my $path = shift;
      $path =~ s/^\///;
      my $url = "http://$host:$port/$path";
      my $content = curl $url, "MongoDB", $user, $password, \&curl_mongo_err_handler;
      try{
          $json = decode_json $content;
      };
      catch{
          my $additional_information = "";
          if($content =~ /It looks like you are trying to access MongoDB over HTTP on the native driver port/){
              chomp $content;
              $additional_information .= ". " . $content . " Try setting your --port to 1000 higher for the rest interface and ensure mongod --rest option is enabled";
          }
          quit "invalid json returned by MongoDB rest interface at '$url'$additional_information";
      };
      return $json;
  }
  
  
  sub curl_mongo_err_handler($){
      my $response = shift;
      my $content  = strip($response->content);
      my $json;
      my $additional_information = "";
      unless($response->code eq "200"){
          if(scalar split("\n", $content) < 2){
              $additional_information .= $content
          }
          if($response->code eq "500"){
              $additional_information .= ". Have you enabled the rest interface with the mongod --rest option?";
          }
          quit "CRITICAL", $response->code . " " . $response->message . $additional_information;
      }
      unless($content){
          quit "CRITICAL", "blank content returned by MongoDB rest interface";
      }
  }
  
  
  sub validate_mongo_hosts($){
      my $host = shift;
      defined($host) or usage "MongoDB host(s) not specified";
      @hosts = split(",", $host);
      for(my $i=0; $i < scalar @hosts; $i++){
          $hosts[$i] = validate_hostport(strip($hosts[$i]), "Mongo");
      }
      $hosts  = "mongodb://" . join(",", @hosts);
  #my $hosts  = join(",", @hosts);
      vlog_option "Mongo host list", $hosts;
      return $hosts;
  }
  
  
  sub validate_mongo_sasl(){
      grep { $sasl_mechanism eq $_ } qw/GSSAPI PLAIN/ or usage "invalid sasl-mechanism specified, must be either GSSAPI or PLAIN";
      vlog_option "ssl",  "enabled" if $ssl;
      vlog_option "sasl", "enabled" if $sasl;
      vlog_option "sasl-mechanism", $sasl_mechanism if $sasl;
  }
  
  1;
HARISEKHON_MONGODB

$fatpacked{"HariSekhon/Redis.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_REDIS';
  #!/usr/bin/perl -T
  # nagios: -epn
  #
  #  Author: Hari Sekhon
  #  Date: 2013-11-17 00:22:17 +0000 (Sun, 17 Nov 2013)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  package HariSekhon::Redis;
  
  $VERSION = "0.2.1";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Carp;
  use Redis;
  use Time::HiRes 'time';
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $REDIS_DEFAULT_PORT
                      $database
                      $hostport
                      $precision
                      %redis_options
                      %redis_options_database
                      connect_redis
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  my $slave;
  
  our $REDIS_DEFAULT_PORT = 6379;
  our $port               = $REDIS_DEFAULT_PORT;
  
  $password = undef;
  
  env_creds("REDIS");
  
  our $database;
  
  my $REDIS_DEFAULT_PRECISION = 5;
  our $precision = $REDIS_DEFAULT_PRECISION;
  
  our %redis_options = (
      "H|host=s"         => [ \$host,         "Redis host (\$REDIS_HOST, \$HOST)" ],
      "P|port=s"         => [ \$port,         "Redis port (default: $REDIS_DEFAULT_PORT, \$REDIS_PORT, \$PORT)" ],
      "p|password=s"     => [ \$password,     "Redis password (\$REDIS_PASSWORD, \$PASSWORD. Optional, use if Redis is configured with requirepass)" ],
      "precision=i"      => [ \$precision,    "Number of decimal places for timings (default: $REDIS_DEFAULT_PRECISION)" ],
  );
  
  our %redis_options_database = (
      "d|database=s"     => [ \$database,     "Database to select (default: 0)" ],
  );
  
  @usage_order = qw/host port database password warning critical precision/;
  
  sub connect_redis(%){
      my (%params) = @_;
      my $host     = $params{"host"} || croak "no host passed to connect_redis";
      my $port     = $params{"port"} || $REDIS_DEFAULT_PORT;
      my $password = $params{"password"};
      # don't replace $host with IP as it can break load balancer routing with '503 Service Temporarily Unavailable'
      validate_resolvable($host);
      my $hostport = $host . ( $verbose ? ":$port" : "" );
      $hostport   .= " ($host)";
      vlog2 "connecting to redis server $hostport";
      my $redis;
      try {
          $redis = Redis->new(server => "$host:$port", password => $password) || quit "CRITICAL", "failed to connect to redis server $hostport";
      };
      catch_quit "failed to connect to redis server $hostport";
      $redis or quit "CRITICAL", "failed to connect to Redis server $hostport";
      vlog2 "API ping to $hostport\n";
      try {
          $redis->ping || quit "CRITICAL", "API ping to $hostport failed, authentication required?";
      };
      catch_quit "API ping to $hostport failed, authentication required?";
      return ($redis, $hostport);
  }
  
  1;
HARISEKHON_REDIS

$fatpacked{"HariSekhon/Riak.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_RIAK';
  #
  #  Author: Hari Sekhon
  #  Date: 2015-06-13 22:40:31 +0100 (Sat, 13 Jun 2015)
  #
  #  vim:ts=4:sts=4:sw=4:et
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying Hari Sekhon LICENSE file
  #
  #  If you're using my code you're welcome to connect with me on LinkedIn and optionally send me feedback to help improve or steer this or other code I publish
  #
  #  https://www.linkedin.com/in/harisekhon
  #
  
  package HariSekhon::Riak;
  
  $VERSION = "0.2";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Carp;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $riak_admin_path
                      %riak_admin_path_option
                      get_riak_admin_path
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  # default install path for riak-admin from packages
  $ENV{"PATH"} .= ":/usr/sbin";
  # this is the a convenient path to check too
  $ENV{"PATH"} .= ":/usr/local/riak/bin";
  
  our $riak_admin_path = "";
  
  our %riak_admin_path_option = (
      "riak-admin-path=s"  => [ \$riak_admin_path, "Path to directory containing riak-admin command if differing from the default /usr/sbin" ],
  );
  
  sub get_riak_admin_path(){
      if($riak_admin_path){
          if(grep {$_ eq $riak_admin_path } split(":", $ENV{"PATH"})){
              usage "$riak_admin_path already in \$riak_admin_path ($ENV{PATH})";
          }
          $riak_admin_path = validate_directory($riak_admin_path, "riak-admin PATH", undef, "no vlog");
          $ENV{"PATH"} = "$riak_admin_path:$ENV{PATH}";
          vlog2 "\$riak_admin_path for riak-admin:",   $ENV{"PATH"};
          vlog2;
      }
  }
  
  1;
HARISEKHON_RIAK

$fatpacked{"HariSekhon/Solr.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_SOLR';
  #
  #  Author: Hari Sekhon
  #  Date: 2015-02-01 21:07:37 +0000 (Sun, 01 Feb 2015)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying Hari Sekhon LICENSE file
  #
  
  package HariSekhon::Solr;
  
  $VERSION = "0.9.0";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use URI::Escape;
  use Carp;
  use Data::Dumper;
  use Math::Round;
  use Time::HiRes 'time';
  use LWP::UserAgent;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $collection
                      $collections
                      $collection_alias
                      $core
                      $http_context
                      $list_collection_aliases
                      $list_collections
                      $list_cores
                      $list_nodes
                      $list_shards
                      $list_replicas
                      $no_warn_replicas
                      $num_found
                      $query_qtime
                      $query_status
                      $query_time
                      $replica
                      $rows
                      $shard
                      $show_settings
                      $solr_admin
                      $solr_node
                      $start
                      $ua
                      $url
                      %solroptions
                      %solroptions_collection
                      %solroptions_collections
                      %solroptions_collection_aliases
                      %solroptions_context
                      %solroptions_core
                      %solroptions_node
                      %solroptions_list_cores
                      %solroptions_shard
                      %solroptions_replica
                      check_collections
                      curl_solr
                      Dumper
                      get_solr_collections
                      get_solr_cores
                      get_solr_nodes
                      get_solr_replicas
                      get_solr_shards
                      find_solr_core
                      isSolrCollection
                      isSolrCore
                      isSolrShard
                      list_solr_collections
                      list_solr_collection_aliases
                      list_solr_cores
                      list_solr_nodes
                      list_solr_replicas
                      list_solr_shards
                      msg_shard_status
                      query_solr
                      validate_solr_collection
                      validate_solr_collections
                      validate_solr_collection_alias
                      validate_solr_context
                      validate_solr_core
                      validate_solr_shard
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  set_port_default(8983);
  
  env_creds("Solr");
  
  our $ua = LWP::UserAgent->new;
  
  my  $default_http_context = "/solr";
  our $http_context = $default_http_context;
  
  my  $default_solr_admin = "$http_context/admin";
  our $solr_admin = $default_solr_admin;
  
  our $url;
  
  our $collection;
  our $collections;
  our $collection_alias;
  our $core;
  our $shard;
  our $replica,
  our $solr_node;
  our $list_collection_aliases = 0;
  our $list_collections = 0;
  our $list_shards      = 0;
  our $list_replicas    = 0;
  our $list_cores       = 0;
  our $list_nodes       = 0;
  our $start = 0;
  our $rows  = 3;
  
  our $query_time;
  our $query_qtime;
  our $query_status;
  our $num_found;
  
  our %solroptions = (
      %hostoptions,
      %useroptions,
      %ssloptions,
  );
  
  env_vars("SOLR_COLLECTION", \$collection);
  env_vars("SOLR_CORE",       \$core);
  env_vars("SOLR_COLLECTION_ALIAS", \$collection_alias);
  env_vars("SOLR_COLLECTIONS",      \$collections);
  
  our %solroptions_collection = (
      "C|collection=s"    => [ \$collection,          "Solr Collection name (\$SOLR_COLLECTION)" ],
      "list-collections"  => [ \$list_collections,    "List Collections (Solr 4 onwards)" ],
  );
  
  our %solroptions_collection_aliases = (
      "A|collection-alias=s"    => [ \$collection_alias,        "Collection Alias (\$SOLR_COLLECTION_ALIAS)" ],
      "list-collection-aliases" => [ \$list_collection_aliases, "List Collection Aliases (Solr 4.9 onwards)" ],
  );
  our %solroptions_collections = (
      "E|collections=s"   => [ \$collections,         "Collections, comma separated (\$SOLR_COLLECTIONS)" ],
  );
  
  our %solroptions_shard = (
      "s|shard=s"         => [ \$shard,               "Shard name, requires --collection" ],
      "list-shards"       => [ \$list_shards,         "List shards, requires --collection" ],
  );
  
  our %solroptions_replica = (
      "r|replica=s"       => [ \$replica,             "Replica name, requires --collection and --shard" ],
      "list-replicas"     => [ \$list_replicas,       "List replicas, requires --collection" ],
  );
  
  our %solroptions_list_cores = (
      "list-cores"        => [ \$list_cores,          "List Cores for which there are loaded cores on given Solr instance" ],
  );
  
  our %solroptions_core = (
      "C|core=s"          => [ \$core,                "Solr Core name (\$SOLR_CORE)" ],
      %solroptions_list_cores,
  );
  
  our %solroptions_node = (
      "N|node=s"          => [ \$solr_node,           "Solr node name" ],
      "list-nodes"        => [ \$list_nodes,          "List Solr nodes" ],
  );
  
  our %solroptions_context = (
      "http-context=s"    => [ \$http_context,        "Solr http context handler prefix for REST API url (defaults to $default_http_context)" ],
  );
  
  sub curl_solr_err_handler($){
      my $response = shift;
      my $content  = $response->content;
      my $json;
      my $additional_information = "";
      if($json = isJson($content)){
          if(defined($json->{"error"}->{"msg"})){
              $additional_information .= ". Error msg: " . $json->{"error"}->{"msg"};
              $additional_information =~ s/\n/,/g;
          }
          if(defined($json->{"error"}->{"trace"})){
              $additional_information .= ". Error trace: " . $json->{"error"}->{"trace"};
              $additional_information =~ s/\n/,/g;
          }
          # collection creation returns HTTP 200 and status 0 with only this error message :-/
          if(defined($json->{"failure"})){
              local $Data::Dumper::Terse = 1;
              local $Data::Dumper::Indent = 0;
              $additional_information .= ". Failure " . Dumper($json->{"failure"});
          }
      }
      # must check for additional error or failure information having been collected since Solr collection creation returns HTTP 200 with header status 0 and only "failure" hash key message to detect the problem :-/
      if($response->code ne "200" or $additional_information){
          #<title>Error 500 {msg=SolrCore 'collection1_shard1_replica2' is not available due to init failure: Index locked for write for core collection1_shard1_replica2,trace=org.apache.solr.common.SolrException: SolrCore 'collection1_shard1_replica2' is not available due to init failure: Index locked for write for core collection1_shard1_replica2
          if(not $additional_information and $response->content =~ /<title>Error\s+\d+\s*\{?([^\n]+)/){
              $additional_information = $1;
              $additional_information =~ s/<\/title>.*//;
              # Solr's responses change weirdly, sometimes it returns the error in server message as well as body instead of a normal 500 Server Error. In these cases ignore the additional info since it's simply a duplication of information and adds volume without value
              if($response->message =~ /\Q$additional_information/){
                  $additional_information = "";
              } else {
                  $additional_information = ". $additional_information";
              }
          }
          my $response_msg = $response->message;
          $response_msg =~ s/^{//;
          $response_msg =~ s/\s+at org\.apache\.solr\..*// unless $verbose;
          quit "CRITICAL", $response->code . " " . $response_msg . $additional_information;
      }
      unless($content){
          quit "CRITICAL", "blank content returned by Solr";
      }
  }
  
  
  sub curl_solr($;$$){
      my $url     = shift() || code_error "no url argument passed to curl_solr()";
      my $type    = shift;
      my $content = shift;
      my $protocol = "http";
      $protocol .= "s" if($ssl);
      $url = "$protocol://$host:$port$url";
      $url =~ /\?/ and $url .= "&" or $url .= "?";
      $url .= "omitHeader=off"; # we need the response header for query time, status and num found
      $url .= "&wt=json"; # xml is lame
      $url .= "&start=$start&rows=$rows";
      $url .= "&indent=true" if $verbose > 2;
      $url .= "&debugQuery=true" if $debug;
      my $start = time;
      my $json = curl_json $url, "Solr", $user, $password, \&curl_solr_err_handler, $type, $content;
      $query_time   = round((time - $start) * 1000); # secs => ms
      # just use NTP check, if doing this logic in every plugin then everything would alarm at the same time drowning out the real problem
      #$query_time < 0 and quit "UNKNOWN", "Solr query time < 0 ms - NTP problem?";
      $query_qtime  = get_field_int("responseHeader.QTime");
      $query_status = get_field("responseHeader.status");
      $num_found    = get_field_int("response.numFound", 1);
      if($query_status ne 0){
          #critical;
          #vlog2 "critical - query status from header was '$query_status' (expected 0)";
          $type = ( $type ? "POST" : "query" );
          quit "CRITICAL", "$type status from header was '$query_status' (expected 0)";
      }
      return $json;
  }
  
  sub query_solr($$;$){
      my $collection = shift() || code_error "no collection argument passed to query_solr()";
      my $query      = shift() || code_error "no query argument passed to query_solr()";
      my $filter     = shift;
      # should be validated before this function call
      #$collection = validate_solr_collection($collection);
      # must be URL encoded before passing to Solr
      # XXX: is this uri escaped later?
      $query  = uri_escape($query);
      $filter = uri_escape($filter);
      curl_solr "$http_context/$collection/select?q=$query" . ( $filter ? "&fq=$filter" : "");
  }
  
  sub get_solr_collection_aliases(){
      $json = curl_solr "$solr_admin/collections?action=CLUSTERSTATUS";
      return get_field("cluster.aliases", 1);
  }
  
  sub list_solr_collection_aliases(){
      if($list_collection_aliases){
          my $collection_aliases = get_solr_collection_aliases();
          print "Solr Collection Aliases:\n\n";
          if($collection_aliases){
              foreach(sort keys %{$collection_aliases}){
                  print "$_ => $$collection_aliases{$_}\n";
              }
          } else {
              print "<none>\n";
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub get_solr_collections(){
      $json = curl_solr "$solr_admin/collections?action=LIST";
      return get_field_array("collections");
  }
  
  sub list_solr_collections(){
      if($list_collections){
          my @collections = get_solr_collections();
          print "Solr Collections:\n\n";
          print join("\n", @collections) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub get_solr_cores(){
      # not using this as it lists all cores, whereas it's more useful to only list cores for which there are cores on the given Solr server
      #$json = curl_solr "$solr_admin/cores?action=LIST&distrib=false";
      $json = curl_solr "$solr_admin/cores?distrib=false";
      my %results = get_field_hash("status");
      my %cores;
      foreach(sort keys %results){
          my $core = get_field2($results{$_}, "name");
          $cores{$core} = 1;
      }
      return sort keys %cores;
  }
  
  sub list_solr_cores(){
      if($list_cores){
          my @cores = get_solr_cores();
          print "Solr cores loaded on Solr instance '$host:$port':\n\n";
          print join("\n", @cores) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub find_solr_core($){
      my $core = shift;
      my @cores = get_solr_cores;
      if(grep { $_ eq $core } @cores){
          return $core;
      } else {
          foreach(@cores){
              if($_ =~ /^${core}_shard\d+_replica\d+$/){
                  return $_;
              }
          }
      }
      return undef;
  }
  
  sub get_solr_nodes(){
      $json = curl_solr "$solr_admin/collections?action=CLUSTERSTATUS";
      return get_field_array("cluster.live_nodes");
  }
  
  sub list_solr_nodes(){
      if($list_nodes){
          my @nodes = get_solr_nodes();
          print "Solr nodes:\n\n";
          print join("\n", @nodes) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub get_solr_shards($){
      my $collection = shift;
      isSolrCollection($collection) or code_error "invalid collection passed to get_solr_shards()";
      $json = curl_solr "$solr_admin/collections?action=CLUSTERSTATUS";
      my %collections = get_field_hash("cluster.collections");
      unless(grep { $_ eq $collection } keys %collections){
          quit "UNKNOWN", "couldn't find collection '$collection' for which to get shards";
      }
      my %shards = get_field2_hash($collections{$collection}, "shards");
      return sort keys %shards;
  }
  
  sub list_solr_shards($){
      if($list_shards){
          my $collection = shift;
          isSolrCollection($collection) or code_error "invalid collection passed to list_solr_shards()";
          my @shards = get_solr_shards($collection);
          print "Solr shards in Solr collection '$collection':\n\n";
          print join("\n", @shards) . "\n";
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  sub get_solr_replicas($){
      my $collection = shift;
      isSolrCollection($collection) or code_error "invalid collection passed to get_solr_replicas()";
      $json = curl_solr "$solr_admin/collections?action=CLUSTERSTATUS";
      my %collections = get_field_hash("cluster.collections");
      unless(grep { $_ eq $collection } keys %collections){
          quit "UNKNOWN", "couldn't find collection '$collection' for which to get replicas";
      }
      my %shards = get_field2_hash($collections{$collection}, "shards");
      return %shards;
  }
  
  sub print_shard_replicas($$){
      my $shard_ref = shift;
      my $shard     = shift;
      isHash($shard_ref) or code_error "non-hashref passed to print_shard_replicas";
      my %shards = %{$shard_ref};
      my %replicas = get_field2_hash($shards{$shard}, "replicas");
      my $core;
      my $node;
      my $state;
      foreach my $replica (sort keys %replicas){
          $core  = get_field2($replicas{$replica}, "core");
          $node  = get_field2($replicas{$replica}, "node_name");
          $state = get_field2($replicas{$replica}, "state");
          printf "shard %-10s\treplica %-20s\tcore %-20s\tnode: %-20s\tstate %s\n", "'$shard'", "'$replica'", "'$core'", "'$node'", "'$state'";
      }
  }
  
  sub list_solr_replicas($;$){
      if($list_replicas){
          my $collection = shift;
          my $shard      = shift;
          isSolrCollection($collection) or code_error "invalid collection passed to list_solr_replicas()";
          my %shards = get_solr_replicas($collection);
          if($shard){
              defined($shards{$shard}) or quit "UNKNOWN", "no replicas found for shard '$shard'. Did you specify the correct shard name? See --list-shards\n";
              print "Solr replicas in Solr collection '$collection' shard '$shard':\n\n";
              my %replicas = get_field2_hash($shards{$shard}, "replicas");
              print_shard_replicas(\%shards, $shard);
          } else {
              print "Solr replicas in Solr collection '$collection':\n\n";
              foreach my $shard (sort keys %shards){
                  print_shard_replicas(\%shards, $shard);
              }
          }
          exit $ERRORS{"UNKNOWN"};
      }
  }
  
  my %inactive_shards;
  #my %inactive_shard_states;
  my %inactive_replicas;
  #my %inactive_replica_states;
  my %inactive_replicas_active_shards;
  my %shards_without_active_replicas;
  my %facts;
  our $no_warn_replicas;
  our $show_settings;
  
  sub check_collection($){
      my $collection = shift;
      vlog2 "collection '$collection': ";
      my $collection2 = $collection;
      $collection2 =~ s/\./\\./g;
      my %shards = get_field_hash("$collection2.shards");
      foreach my $shard (sort keys %shards){
          my $shard2 = $shard;
          $shard2 =~ s/\./\\./g;
          my $state = get_field("$collection2.shards.$shard2.state");
          vlog2 "\t\t\tshard '$shard' state '$state'";
          unless($state eq "active"){
              $inactive_shards{$collection}{$shard} = $state;
              #push(@{$inactive_shard_states{$collection}{$state}}, $shard);
          }
          my %replicas = get_field_hash("$collection2.shards.$shard2.replicas");
          my $found_active_replica = 0;
          foreach my $replica (sort keys %replicas){
              $replica =~ s/\./\\./g;
              my $replica_name  = get_field("$collection2.shards.$shard2.replicas.$replica.node_name");
              my $replica_state = get_field("$collection2.shards.$shard2.replicas.$replica.state");
              $replica_name =~ s/_solr$//;
              vlog2 "\t\t\t\t\treplica '$replica_name' state '$replica_state'";
              if($replica_state eq "active"){
                  $found_active_replica++;
              } else {
                  $inactive_replicas{$collection}{$shard}{$replica_name} = $replica_state;
                  #push(@{$inactive_replica_states{$collection}{$shard}{$replica_state}}, $replica_name);
                  if($state eq "active"){
                      $inactive_replicas_active_shards{$collection}{$shard}{$replica_name} = $replica_state;
                  }
              }
          }
          if(not $found_active_replica and not defined($inactive_shards{$collection}{$shard})){
              $shards_without_active_replicas{$collection}{$shard} = $state;
              delete $inactive_replicas_active_shards{$collection}{$shard};
              delete $inactive_replicas_active_shards{$collection} unless %{$inactive_replicas_active_shards{$collection}};
          }
      }
      if($inactive_shards{$collection} and not %{$inactive_shards{$collection}}){
          delete $inactive_shards{$collection};
      }
      $facts{$collection}{"maxShardsPerNode"}  = get_field_int("$collection2.maxShardsPerNode");
      $facts{$collection}{"router"}            = get_field("$collection2.router.name");
      $facts{$collection}{"replicationFactor"} = get_field_int("$collection2.replicationFactor");
      $facts{$collection}{"autoAddReplicas"}   = get_field("$collection2.autoAddReplicas", 1);
      vlog2;
  }
  
  sub check_collections(){
      my $found = 0;
      unless(%$json){
          quit "CRITICAL", "no collections found";
      }
      foreach(keys %$json){
          if($collection){
              if($collection eq $_){
                  $found++;
                  check_collection($_);
              }
          } else {
              check_collection($_);
          }
      }
      if($collection and not $found){
          quit "CRITICAL", "collection '$collection' not found, did you specify the correct name? See --list-collections for list of known collections";
      }
  }
  
  sub msg_replicas_down($){
      my $hashref = shift;
      foreach my $collection (sort keys %$hashref){
          $msg .= "collection '$collection' ";
          foreach my $shard (sort keys %{$$hashref{$collection}}){
              $msg .= "shard '$shard'";
              if($verbose){
                  $msg .= " (" . join(",", sort keys %{$$hashref{$collection}{$shard}}) . ")";
              }
              $msg .= ", ";
          }
          $msg =~ s/, $//;
      }
      $msg =~ s/, $//;
  }
  
  sub msg_additional_replicas_down(){
      unless($no_warn_replicas){
          if(%inactive_replicas_active_shards){
              $msg .= ". Additional backup shard replicas down (shards still up): ";
              msg_replicas_down(\%inactive_replicas_active_shards);
          }
      }
  }
  
  sub msg_shards($){
      my $hashref = shift;
      foreach my $collection (sort keys %$hashref){
          my $num_inactive = scalar keys(%{$$hashref{$collection}});
          plural $num_inactive;
          #next unless $num_inactive > 0;
          $msg .= "collection '$collection' => $num_inactive shard$plural down";
          if($verbose){
              $msg .= " (";
              foreach my $shard (sort keys %{$$hashref{$collection}}){
                  $msg .= "$shard,";
              }
              $msg =~ s/,$//;
              $msg .= "), ";
          }
      }
      $msg =~ s/, $//;
  }
  
  sub msg_shard_status(){
      # Initially used inverted index hashes to display uniquely all the different shard states, but then when extending to replica states this really became too much, simpler to just call shards and replicas 'down' if not active
      if(%inactive_shards){
          critical;
          $msg = "SolrCloud shards down: ";
          msg_shards(\%inactive_shards);
          if(%shards_without_active_replicas){
              $msg .= ". SolrCloud shards 'active' but with no active replicas: ";
              msg_shards(\%shards_without_active_replicas);
          }
          msg_additional_replicas_down();
      } elsif(%shards_without_active_replicas){
          critical;
          $msg = "SolrCloud shards 'active' but with no active replicas: ";
          msg_shards(\%shards_without_active_replicas);
          msg_additional_replicas_down();
      } elsif(%inactive_replicas and not $no_warn_replicas){
          warning;
          $msg = "SolrCloud shard replicas down: ";
          msg_replicas_down(\%inactive_replicas);
      } else {
          my $collections;
          if($collection){
              $plural = "";
              $collections = $collection;
          } else {
              plural keys %$json;
              $collections = join(", ", sort keys %$json);
          }
          $msg = "all SolrCloud shards " . ( $no_warn_replicas ? "" : "and replicas " ) . "active for collection$plural: $collections";
      }
      if($show_settings){
          $msg .= ". Replication Settings: ";
          foreach my $collection (sort keys %facts){
              $msg .= "collection '$collection'";
              # made autoAddReplicas optional since it wasn't found on my SolrCloud 4.7.2 cluster, must have been added after since it was on another cluster of mine
              foreach(qw/maxShardsPerNode replicationFactor router autoAddReplicas/){
                  $msg .= " $_=" . $facts{$collection}{$_} if $facts{$collection}{$_};
              }
              $msg .= ", ";
          }
          $msg =~ s/, $//;
      }
  }
  
  sub isSolrCollection($){
      my $collection = shift;
      defined($collection) or return undef;
      $collection =~ /^([\w\.-]+)$/ or return undef;
      return $1;
  }
  *isSolrCore  = \&isSolrCollection;
  *isSolrShard = \&isSolrCollection;
  
  sub validate_solr_collection($){
      my $collection = shift;
      defined($collection) or quit "CRITICAL", "Solr collection not specified";
      $collection = isSolrCollection($collection) or quit "CRITICAL", "invalid Solr collection specified";
      vlog_option "collection", $collection;
      return $collection;
  }
  
  sub validate_solr_collections($){
      my $collections = shift;
      defined($collections) or quit "CRITICAL", "Solr collections not specified";
      my @collections;
      $collections = trim($collections);
      $collections or quit "CRITICAL", "Solr collections are blank!";
      foreach my $collection (split(/\s*,\s*/, $collections)){
          $collection = isSolrCollection($collection) or quit "CRITICAL", "invalid Solr collection '$collection' specified";
          push(@collections, $collection);
      }
      $collections = join(",", @collections);
      vlog_option "collections", $collections;
      return $collections;
  }
  
  sub validate_solr_collection_alias($){
      my $collection_alias = shift;
      defined($collection_alias) or quit "CRITICAL", "Solr collection alias not specified";
      $collection_alias = isSolrCollection($collection_alias) or quit "CRITICAL", "invalid Solr collection alias specified";
      vlog_option "collection alias", $collection_alias;
      return $collection_alias;
  }
  
  sub validate_solr_core($){
      my $core = shift;
      defined($core) or quit "CRITICAL", "Solr core not specified";
      $core = isSolrCore($core) or quit "CRITICAL", "invalid Solr core specified";
      vlog_option "core", $core;
      return $core;
  }
  
  sub validate_solr_shard($){
      my $shard = shift;
      defined($shard) or quit "CRITICAL", "Solr shard not specified";
      $shard = isSolrShard($shard) or quit "CRITICAL", "invalid Solr shard specified";
      vlog_option "shard", $shard;
      return $shard;
  }
  
  sub validate_solr_context($){
      my $context = shift;
      defined($context) or quit "CRITICAL", "Solr http context not defined";
      $context =~ /^\/*([\/\w-]+)$/ or quit "CRITICAL", "invalid Solr http context, must be alphanumeric";
      $context = "/$1";
      if($solr_admin eq $default_solr_admin){
          $solr_admin = "$context/admin";
      }
  
      vlog_option "http context", $context;
      return $context;
  }
  
  1;
HARISEKHON_SOLR

$fatpacked{"HariSekhon/ZooKeeper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHON_ZOOKEEPER';
  #
  #  Author: Hari Sekhon
  #  Date: 2013-07-03 01:58:10 +0100 (Wed, 03 Jul 2013)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  # Split off from Nagios plugin check_zookeeper.pl I wrote in 2011
  
  package HariSekhon::ZooKeeper;
  
  $VERSION = "0.8.2";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils qw/:DEFAULT :time/;
  use Carp;
  use IO::Socket;
  # This would prevent check_zookeeper_config.pl and similar programs only requiring 4lw support from running without full ZooKeeper C to Perl module build
  #use Net::ZooKeeper qw/:DEFAULT :errors :log_levels/;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                      $DATA_READ_LEN
                      $ZK_DEFAULT_PORT
                      $default_zk_timeout
                      $random_conn_order
                      $zk_conn
                      $zkh
                      $zk_stat
                      $zk_timeout
                      $znode_age_secs
                      %zookeeper_options
                      @zk_valid_states
                      check_znode_age_positive
                      check_znode_exists
                      connect_zookeepers
                      get_znode_age
                      get_znode_contents
                      get_znode_contents_json
                      get_znode_contents_xml
                      translate_zoo_error
                      zoo_cmd
                      zoo_debug
                      zookeeper_random_conn_order
                      isZnode
                      validate_base_and_znode
                      validate_znode
                      isZookeeperEnsemble
                      validate_zookeeper_ensemble
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  # Max num of chars to read from znode contents
  our $DATA_READ_LEN = 500;
  
  # ZooKeeper Client Port
  our $ZK_DEFAULT_PORT = 2181;
  set_port_default($ZK_DEFAULT_PORT);
  our @zk_valid_states = qw/leader follower standalone/;
  
  env_creds("ZOOKEEPER");
  
  our $default_zk_timeout = 2;
  our $zk_timeout = $default_zk_timeout;
  our $random_conn_order = 0;
  our $zkh;
  our $zk_stat;
  our $znode_age_secs;
  my $zookeepers;
  my @zookeepers;
  
  our %zookeeper_options = (
      "H|host=s"          => [ \$host,                  "ZooKeeper node(s) to connect to (\$ZOOKEEPER_HOST, \$HOST), should be a comma separated list of ZooKeepers the same as are configured on the ZooKeeper servers themselves with optional individual ports per server (node1:$ZK_DEFAULT_PORT,node2:$ZK_DEFAULT_PORT,node3:$ZK_DEFAULT_PORT). It takes longer to connect to 3 ZooKeepers than just one of them (around 5 secs per ZooKeeper specified + (session-timeout x any offline ZooKeepers) so you will need to increase --timeout). Connection order is deterministic and will be tried in the order specified unless --random-conn-order" ],
      "P|port=s"          => [ \$port,                  "Port to connect to on ZooKeepers for any nodes not suffixed with :<port> (defaults to $ZK_DEFAULT_PORT, set to 5181 for MapR, \$ZOOKEEPER_PORT, \$PORT)" ],
      # %useroptions,
      "u|user=s"          => [ \$user,                  "User to connect with (\$ZOOKEEPER_USER environment variable. Not tested. YMMV. optional)" ],
      "p|password=s"      => [ \$password,              "Password to connect with (\$ZOOKEEPER_PASSWORD environment variable. Not tested. YMMV. optional)" ],
      "random-conn-order" => [ \$random_conn_order,     "Randomize connection order to provided zookeepers (otherwise tries in order given)" ],
      "session-timeout=s" => [ \$zk_timeout,            "ZooKeeper session timeout in secs (default: $default_zk_timeout). This determines how long to wait for connection to downed ZooKeepers and affects total execution time" ],
  );
  splice @usage_order, 6, 0, qw/random-conn-order session-timeout/;
  
  sub zookeeper_random_conn_order(){
      require Net::ZooKeeper;
      if($random_conn_order){
          vlog2 "using random connection order";
          Net::ZooKeeper::set_deterministic_conn_order(0); # default
      } else {
          vlog2 "setting deterministic connection order";
          Net::ZooKeeper::set_deterministic_conn_order(1);
      }
  }
  
  sub zoo_debug(){
      require Net::ZooKeeper;
      import Net::ZooKeeper qw/:log_levels/;
      if($debug){
          vlog2 "setting ZooKeeper log level => debug";
          #Net::ZooKeeper::set_log_level(&Net::ZooKeeper::ZOO_LOG_LEVEL_DEBUG);
          Net::ZooKeeper::set_log_level(&ZOO_LOG_LEVEL_DEBUG);
      } elsif($verbose > 3){
          vlog2 "setting ZooKeeper log level => info";
          #Net::ZooKeeper::set_log_level(&Net::ZooKeeper::ZOO_LOG_LEVEL_INFO);
          Net::ZooKeeper::set_log_level(&ZOO_LOG_LEVEL_INFO);
      } elsif($verbose > 1){
          vlog2 "setting ZooKeeper log level => warn";
          #Net::ZooKeeper::set_log_level(&Net::ZooKeeper::ZOO_LOG_LEVEL_WARN);
          Net::ZooKeeper::set_log_level(&ZOO_LOG_LEVEL_WARN);
      }
  }
  
  sub check_znode_age_positive(){
      if($znode_age_secs < 0){
          my $clock_mismatch_msg = "clock synchronization problem, modified timestamp on znode is in the future!";
          if($status eq "OK"){
              $msg = "$clock_mismatch_msg $msg";
          } else {
              $msg .= ". Also, $clock_mismatch_msg";
          }
          warning;
      }
  }
  
  sub get_znode_age($){
      my $znode = shift;
      if(defined($zk_stat)){
          my $mtime = $zk_stat->{mtime} / 1000;
          isFloat($mtime) or quit "UNKNOWN", "invalid mtime returned for znode '$znode', got '$mtime'";
          vlog3 sprintf("znode '%s' mtime = %s", $znode, $mtime);
          $znode_age_secs = time - int($mtime);
          vlog2 "znode last modified $znode_age_secs secs ago";
          check_znode_age_positive();
          return $znode_age_secs;
      } else {
          quit "UNKNOWN", "no stat object returned by ZooKeeper exists call for znode '$znode', try re-running with -vvvvD to see full debug output";
      }
  }
  
  sub get_znode_contents($){
      my $znode = shift;
      my $data = $zkh->get($znode, 'data_read_len' => $DATA_READ_LEN);
                                 # 'stat' => $zk_stat, 'watch' => $watch)
                                 # || quit "CRITICAL", "failed to read data from znode $znode: $!";
      plural @zookeepers;
      defined($data) or quit "CRITICAL", "no data returned for znode '$znode' from zookeeper$plural '$zookeepers': " . $zkh->get_error();
      # /hadoop-ha/logicaljt/ActiveStandbyElectorLock contains carriage returns which messes up the output in terminal by causing the second line to overwrite the first
      $data =~ s/\r//g;
      $data = trim($data);
      vlog3 "znode '$znode' data:\n\n$data\n";
      return $data;
  }
  
  sub get_znode_contents_json($){
      my $znode = shift;
      my $data  = get_znode_contents($znode);
      $data     = isJson($data) or quit "CRITICAL", "znode '$znode' data is not JSON as expected, got '$data'";
      return $data;
  }
  
  sub get_znode_contents_xml($){
      my $znode = shift;
      my $data  = get_znode_contents($znode);
      $data     = isXml($data) or quit "CRITICAL", "znode '$znode' data is not XML as expected, got '$data'";
      return $data;
  }
  
  sub check_znode_exists($;$){
      my $znode  = shift;
      my $noquit = shift;
      vlog2 "checking znode '$znode' exists";
      if($noquit){
          $zkh->exists($znode, 'stat' => $zk_stat) or return 0;
      } else {
          $zkh->exists($znode, 'stat' => $zk_stat) or quit "CRITICAL", "znode '$znode' does not exist! ZooKeeper returned: " . translate_zoo_error($zkh->get_error());
          $zk_stat or quit "UNKNOWN", "failed to get stats from znode $znode";
      }
      vlog2 "znode '$znode' exists";
      return 1;
  }
  
  sub connect_zookeepers(@){
      require Net::ZooKeeper;
      @zookeepers = @_;
      plural @zookeepers;
      $zookeepers = join(", ", @zookeepers);
  
      vlog2 "trapping SIGPIPE in case of lost zookeeper connection";
      # API may raise SIG PIPE on connection failure
      local $SIG{'PIPE'} = sub { quit "UNKNOWN", "lost connection to ZooKeeper$plural '$zookeepers'"; };
  
      zoo_debug();
      zookeeper_random_conn_order();
  
      $zk_timeout = validate_float($zk_timeout, "zookeeper session timeout", 0.001, 100);
  
      vlog2 "connecting to ZooKeeper node$plural: $zookeepers";
      $zkh = Net::ZooKeeper->new( $zookeepers,
                                  "session_timeout" => $zk_timeout * 1000
                                )
          || quit "CRITICAL", "failed to create connection object to ZooKeepers within $zk_timeout secs: $!";
      vlog2 "ZooKeeper connection object created, won't be connected until we issue a call";
      # Not tested auth yet
      if(defined($user) and defined($password)){
          $zkh->add_auth('digest', "$user:$password");
      }
      my $session_timeout = ($zkh->{session_timeout} / 1000) or quit "UNKNOWN", "invalid session timeout determined from ZooKeeper handle, possibly not connected to ZooKeeper?";
      vlog2 sprintf("session timeout is %.2f secs\n", $zk_timeout);
  
      vlog2 "checking znode '/' exists to determine if we're properly connected to ZooKeeper";
      my $connection_succeeded = 0;
  # the last attempt will retry all zookeepers two more times if that zookeeper fails to connect
  # to see this use -vv --session-timeout 0.001
      for(my $i=0; $i < scalar @zookeepers; $i++){
          $zkh->exists("/") and $connection_succeeded = 1 and last;
      }
      $connection_succeeded or quit "CRITICAL", "connection error, failed to find znode '/': " . translate_zoo_error($zkh->get_error());
      vlog2 "found znode '/', connection to zookeeper succeeded\n";
  
      vlog3 "creating ZooKeeper stat object";
      $zk_stat = $zkh->stat();
      $zk_stat or quit "UNKNOWN", "failed to create ZooKeeper stat object";
      vlog3 "stat object created";
  
      return $zkh;
  }
  
  sub translate_zoo_error($){
      require Net::ZooKeeper;
      import Net::ZooKeeper qw/:errors/;
      my $errno = shift;
      isInt($errno, 1) or code_error "non int passed to translate_zoo_error()";
      # this makes me want to cry, if anybody knows a better way of getting some sort of error translation out of this API please let me know!
      no strict 'refs';
      foreach(qw(
          ZOK
          ZSYSTEMERROR
          ZRUNTIMEINCONSISTENCY
          ZDATAINCONSISTENCY
          ZCONNECTIONLOSS
          ZMARSHALLINGERROR
          ZUNIMPLEMENTED
          ZOPERATIONTIMEOUT
          ZBADARGUMENTS
          ZINVALIDSTATE
          ZAPIERROR
          ZNONODE
          ZNOAUTH
          ZBADVERSION
          ZNOCHILDRENFOREPHEMERALS
          ZNODEEXISTS
          ZNOTEMPTY
          ZSESSIONEXPIRED
          ZINVALIDCALLBACK
          ZINVALIDACL
          ZAUTHFAILED
          ZCLOSING
          ZNOTHING
      )){
          # This is a tricky workaround to runtime require to avoid forcing the annoying Net::ZooKeeper dependency where client code only needs 4lw support
          #if(eval "Net::ZooKeeper::$_" == $errno){
          if(&$_ == $errno){
              use strict 'refs';
              return "$errno $_";
          }
      }
      use strict 'refs';
      return "<failed to translate zookeeper error for error code: $errno>";
  }
  
  sub isZnode($){
      my $znode = shift;
      defined($znode) or undef;
      $znode =~ /^(\/(?:(?:[\w\._-]+\/)*[\w:\._-]+)?)$/ or undef;
      $znode = $1;
      return $znode;
  }
  
  sub validate_znode($;$){
      my $znode = shift;
      my $name  = shift() || "";
      $name .= " " if $name;
      defined($znode) or usage "${name}znode not defined";
      $znode = isZnode($znode) or usage "invalid ${name}znode";
      return $znode;
  }
  
  sub validate_base_and_znode($$$){
      my $base = shift;
      my $znode = shift;
      my $name = shift;
      $znode = validate_znode($base, "base") . "/$znode";
      $znode =~ s/\/+/\//g;
      $znode = validate_znode($znode, $name);
  }
  
  sub isZookeeperEnsemble($){
      my $zookeeper_ensemble = shift;
      my $znode_chroot = $zookeeper_ensemble;
      $znode_chroot =~ s/[^\/]+//;
      $zookeeper_ensemble =~ s/\/.*$//;
      #my @zookeeper_ensemble = validate_hosts($zookeeper_ensemble, $port);
      my @zookeeper_ensemble = split(/\s*,\s*/, $zookeeper_ensemble);
      foreach(my $i=0; $i < scalar @zookeeper_ensemble; $i++){
          $zookeeper_ensemble[$i] = validate_hostport($zookeeper_ensemble[$i], "zookeeper index $i");
      }
      $zookeeper_ensemble = join(",", @zookeeper_ensemble);
      if($znode_chroot){
          $znode_chroot = isZnode($znode_chroot) or return undef;
          $zookeeper_ensemble .= $znode_chroot;
      }
      return $zookeeper_ensemble;
  }
  
  sub validate_zookeeper_ensemble($){
      my $zookeeper_ensemble = shift;
      defined($zookeeper_ensemble) or usage "zookeeper ensemble not defined";
      $zookeeper_ensemble = isZookeeperEnsemble($zookeeper_ensemble) or usage "invalid zookeeper ensemble";
      return $zookeeper_ensemble;
  }
  
  
  # ============================================================================ #
  #                               Zoo 4lw support
  # ============================================================================ #
  
  our $zk_conn;
  # TODO: ZooKeeper closes connection after 1 cmd, see if I can work around this, as having to use several TCP connections is inefficient
  sub zoo_cmd ($;$) {
      my $cmd     = shift;
      my $timeout = shift;
      unless(defined($cmd)){
          carp "no cmd arg defined for zoo_cmd()";
          exit get_status_code("UNKNOWN");
      }
      if(defined($timeout)){
          unless(isFloat($timeout)){
              carp "non-float timeout passed as zoo_cmd() 2nd arg";
              exit get_status_code("UNKNOWN");
          }
      }
      validate_resolvable($host);
      vlog3 "connecting to $host:$port";
      $zk_conn = IO::Socket::INET->new (
                                          Proto    => "tcp",
                                          PeerAddr => $host,
                                          PeerPort => $port,
                                          Timeout  => $timeout,
                                       ) or quit "CRITICAL", sprintf("Failed to connect to '%s:%s'%s: $!", $host, $port, (defined($timeout) and ($debug or $verbose > 2)) ? " within $timeout secs" : "");
      vlog3 "OK connected";
      vlog3 "sending request: '$cmd'";
      print $zk_conn $cmd or quit "CRITICAL", "Failed to send request '$cmd': $!";
      vlog3 "sent request:    '$cmd'";
  }
  
  1;
HARISEKHON_ZOOKEEPER

$fatpacked{"HariSekhonUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HARISEKHONUTILS';
  #
  #  Author: Hari Sekhon
  #  Date: 2011-09-15 11:30:24 +0100 (Thu, 15 Sep 2011)
  #
  #  https://github.com/harisekhon/lib
  #
  #  License: see accompanying LICENSE file
  #
  
  #  HARI SEKHON:
  #
  #  Library of personal stuff I use a lot, cobbled together from bits of my own
  #  scripts over the last few years and a Nagios library I started in Python years ago
  #
  #  I welcome feedback on this. Currently this lib isn't designed for purity but rather convenience
  #  and ease of maintenance.  If you have a better way of doing anything in this library that will
  #  not significantly inconvenience me then let me know!
  #
  #  PLEASE DO NOT CHANGE ANYTHING IN HERE!
  #
  #  You may use this library at your own risk. You may not change it.
  #
  # ============================================================================ #
  #  Unit Tests
  #
  #  make test
  #
  #  This will call a bunch of Test::More unit tests from t/
  #
  # ============================================================================ #
  #  Functional Tests
  #
  #  If you import this library then at the very minimum I recommend that you add
  #  one or more functional tests to cover all usage scenarios for your code to
  #  validate when this library is updated.
  #
  #  ./testcmd.exp path_to_tests/*.exptest
  #
  #  One of the original purposes of this library was to be able to rapidly develop Nagios plugins.
  #  If you use this to ease your development of Nagios plugins I strongly recommend that you add
  #  functional tests and run them whenever either this library or your plugin changes
  #
  #  Running make test under nagios-plugins will run all unit and functional tests
  #  to make sure everything still works as expected before releasing to production. It will
  #  also check for plugins that are importing this library but don't have any test files
  #
  #  You don't want your Nagios screen to suddenly go all red because you haven't done your QA!
  #
  #  If you've added some code and don't have a corresponding suite of test files
  #  in the ./tests directory then they may well break when I update this library.
  
  package HariSekhonUtils;
  use warnings;
  use strict;
  # fixes 'Can't locate object method "tid" via package "threads" at /usr/lib64/perl5/XSLoader.pm line 94.' caused by http_proxy/https_proxy environment variables (LWP module)
  # eval'ing it for perls built without thread support (like Travis CI)
  use Config;
  if($Config{usethreads}){
      require threads;
      import threads;
  }
  use 5.006_001;
  use Carp;
  use Cwd 'abs_path';
  use Fcntl ':flock';
  use File::Basename;
  use Getopt::Long qw(:config bundling);
  # fixes 'Can't locate object method "flush" via package "IO::Handle" at /usr/local/share/perl5/LWP/UserAgent.pm line 536.' in -D/--debug mode
  use IO::Handle;
  use POSIX;
  use JSON 'decode_json';
  use Scalar::Util 'blessed';
  #use Sys::Hostname;
  #use Term::ANSIColor 2.01 qw(colorstrip);
  use Term::ReadKey;
  use Time::Local;
  # Workaround for IO::Socket::SSL bug not respecting disabling verifying self-signed certs
  if( -f dirname(__FILE__) . "/.use_net_ssl" ){
      require Net::SSL;
      import Net::SSL;
  }
  
  our $VERSION = "1.19.6";
  
  #BEGIN {
  # May want to refactor this so reserving ISA, update: 5.8.3 onwards
  #use Exporter "import";
  #require Exporter;
  use Exporter;
  our @ISA = qw(Exporter);
  # consider replacing the above with these two lines for compatibility with Perl 5.6 and then removing our from @EXPORT* below
  #use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
  #@ISA = qw(Exporter);
  our %EXPORT_TAGS = (
      'array' =>  [   qw(
                          assert_array
                          assert_hash
                          assert_int
                          assert_float
                          compact_array
                          flattenStats
                          get_field
                          get_field_array
                          get_field_float
                          get_field_hash
                          get_field_int
                          get_field2
                          get_field2_array
                          get_field2_float
                          get_field2_hash
                          get_field2_int
                          inArray
                          sort_insensitive
                          uniq_array
                          uniq_array2
                          uniq_array_ordered
                      ) ],
      'cmd'   =>  [   qw(
                          cmd
                          pkill
                          prompt
                          isYes
                          set_sudo
                          which
                      ) ],
      'file'  => [    qw(
                          open_file
                          get_path_owner
                      ) ],
      'io'    => [    qw(
                          autoflush
                      ) ],
      'is'    => [    qw(
                          isArray
                          isAlNum
                          isAwsAccessKey
                          isAwsHostname
                          isAwsFqdn
                          isAwsSecretKey
                          isChars
                          isCollection
                          isDatabaseName
                          isDatabaseColumnName
                          isDatabaseFieldName
                          isDatabaseTableName
                          isDatabaseViewName
                          isDigit
                          isDomain
                          isDomain2
                          isDomainStrict
                          isDnsShortname
                          isEmail
                          isFilename
                          isDirname
                          isFloat
                          isFqdn
                          isHash
                          isHex
                          isHost
                          isHostname
                          isIP
                          isInt
                          isInterface
                          isKrb5Princ
                          isJavaBean
                          isJavaException
                          isJson
                          isLabel
                          isLdapDn
                          isLinux
                          isLinuxOrMac
                          isMac
                          isMinVersion
                          isNagiosUnit
                          isNoSqlKey
                          isObject
                          isOS
                          isPathQualified
                          isPort
                          isProcessName
                          isPythonTraceback
                          isRef
                          isRegex
                          isScalar
                          isScientific
                          isThreshold
                          isUrl
                          isUrlPathSuffix
                          isUser
                          isVersion
                          isVersionLax
                          isXml
                          user_exists
                      ) ],
      'lock'  =>  [   qw(
                          go_flock_yourself
                          flock_off
                      ) ],
      'log'   =>  [   qw(
                          log
                          loginit
                          logdie
                      ) ],
      'net'   =>  [   qw(
                          resolve_ip
                      ) ],
      'options' => [  qw(
                          add_options
                          add_host_options
                          add_user_options
                          get_options
                          check_regex
                          check_string
                          check_threshold
                          check_thresholds
                          env_cred
                          env_creds
                          env_var
                          env_vars
                          expand_units
                          human_units
                          isYes
                          msg_perf_thresholds
                          minimum_value
                          month2int
                          parse_file_option
                          prompt
                          plural
                          remove_timeout
                          set_host_default
                          set_port_default
                          set_threshold_defaults
                          timecomponents2days
                          usage
                          validate_ssl
                          validate_tls
                          validate_thresholds
                          version
                      ) ],
      'os'    =>  [   qw(
                          isLinux
                          isMac
                          isOS
                          linux_mac_only
                          linux_only
                          mac_only
                      ) ],
      'regex' =>  [   qw(
                          escape_regex
                          $aws_access_key_regex
                          $aws_host_ip_regex
                          $aws_hostname_regex
                          $aws_fqdn_regex
                          $aws_secret_key_regex
                          $column_regex
                          $dirname_regex
                          $domain_regex
                          $domain_regex2
                          $domain_regex_strict
                          $email_regex
                          $filename_regex
                          $fqdn_regex
                          $host_regex
                          $hostname_regex
                          $ip_prefix_regex
                          $ip_regex
                          $krb5_principal_regex
                          $label_regex
                          $ldap_dn_regex
                          $mac_regex
                          $process_name_regex
                          $rwxt_regex
                          $subnet_mask_regex
                          $tld_regex
                          $url_path_suffix_regex
                          $url_regex
                          $user_regex
                          $version_regex
                          $version_regex_lax
                      ) ],
      'status' =>  [  qw(
                          $status
                          status
                          status2
                          status3
                          critical
                          warning
                          unknown
                          is_critical
                          is_warning
                          is_unknown
                          is_ok
                          isYes
                          get_status_code
                          get_upper_threshold
                          get_upper_thresholds
                          msg_thresholds
                          try
                          catch
                          catch_quit
                          quit
                      ) ],
      'string' => [   qw(
                          lstrip
                          ltrim
                          perf_suffix
                          random_alnum
                          rstrip
                          rtrim
                          strBool
                          strip
                          strip_ansi_escape_codes
                          trim
                          trim_float
                      ) ],
      'time'    => [  qw(
                          sec2min
                          sec2human
                          tprint
                          tstamp
                      ) ],
      'timeout' => [  qw(
                          $timeout_current_action
                          set_http_timeout
                          set_timeout
                          set_timeout_default
                          set_timeout_max
                          set_timeout_range
                      ) ],
      'validate' => [ qw(
                          skip_java_output
                          validate_alnum
                          validate_aws_access_key
                          validate_aws_bucket
                          validate_aws_secret_key
                          validate_chars
                          validate_collection
                          validate_database
                          validate_database_columnname
                          validate_database_fieldname
                          validate_database_query_select_show
                          validate_database_tablename
                          validate_database_viewname
                          validate_dir
                          validate_directory
                          validate_dirname
                          validate_domain
                          validate_domainname
                          validate_email
                          validate_file
                          validate_filename
                          validate_float
                          validate_fqdn
                          validate_host_port_user_password
                          validate_host
                          validate_hosts
                          validate_hostname
                          validate_hostport
                          validate_int
                          validate_integer
                          validate_interface
                          validate_ip
                          validate_java_bean
                          validate_krb5_princ
                          validate_krb5_realm
                          validate_label
                          validate_ldap_dn
                          validate_metrics
                          validate_node_list
                          validate_nodeport_list
                          validate_nosql_key
                          validate_password
                          validate_port
                          validate_process_name
                          validate_program_path
                          validate_regex
                          validate_resolvable
                          validate_ssl
                          validate_tls
                          validate_thresholds
                          validate_units
                          validate_url
                          validate_url_path_suffix
                          validate_user
                          validate_user_exists
                          validate_username
                      ) ],
      'vars' =>   [   qw(
                          $critical
                          $debug
                          $default_warning
                          $default_critical
                          $email
                          $expected_version
                          $host
                          $github_repo
                          $json
                          $msg
                          $msg_err
                          $msg_threshold
                          $multiline
                          $nagios_plugins_support_msg
                          $nagios_plugins_support_msg_api
                          $nodes
                          $password
                          $plural
                          $port
                          $progname
                          $status
                          $status_prefix
                          $sudo
                          $ssl
                          $ssl_ca_path
                          $tls
                          $ssl_noverify
                          $timeout
                          $timeout_current_action
                          $timeout_default
                          $timeout_max
                          $timeout_min
                          $usage_line
                          $user
                          $verbose
                          $version
                          $warning
                          %ERRORS
                          %emailoptions
                          %expected_version_option
                          %hostoptions
                          %multilineoption
                          %nodeoptions
                          %options
                          %ssloptions
                          %thresholdoptions
                          %thresholds
                          %tlsoptions
                          %useroption
                          %useroptions
                          @usage_order
                      ) ],
      'verbose' => [  qw(
                          code_error
                          debug
                          hr
                          tprint
                          tstamp
                          verbose_mode
                          vlog
                          vlog2
                          vlog3
                          vlogt
                          vlog2t
                          vlog3t
                          vlog_option
                          vlog_option_bool
                      ) ],
      'web'   =>  [   qw(
                          curl
                          curl_json
                          wget
                      ) ],
  );
  # same as below
  #Exporter::export_tags('foo');
  #Exporter::export_ok_tags('bar');
  # TODO: move all of this from EXPORT to EXPORT_OK while validating all dependent code still works
  our @EXPORT =   (
                      @{$EXPORT_TAGS{'array'}},
                      @{$EXPORT_TAGS{'cmd'}},
                      @{$EXPORT_TAGS{'io'}},
                      @{$EXPORT_TAGS{'is'}},
                      @{$EXPORT_TAGS{'file'}},
                      @{$EXPORT_TAGS{'lock'}},
                      @{$EXPORT_TAGS{'net'}},
                      @{$EXPORT_TAGS{'options'}},
                      @{$EXPORT_TAGS{'os'}},
                      @{$EXPORT_TAGS{'status'}},
                      @{$EXPORT_TAGS{'string'}},
                      @{$EXPORT_TAGS{'timeout'}},
                      @{$EXPORT_TAGS{'validate'}},
                      @{$EXPORT_TAGS{'vars'}},
                      @{$EXPORT_TAGS{'verbose'}},
                      @{$EXPORT_TAGS{'web'}},
                  );
  our @EXPORT_OK = (  @EXPORT,
                      @{$EXPORT_TAGS{'log'}},
                      @{$EXPORT_TAGS{'regex'}},
                      @{$EXPORT_TAGS{'time'}},
                   );
  # could also do this:
  #{ my %seen; push @{$EXPORT_TAGS{'all'}}, grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS; }
  $EXPORT_TAGS{'all'}         = [ @EXPORT_OK  ];
  $EXPORT_TAGS{'most'}        = [ @EXPORT     ];
  $EXPORT_TAGS{'EXPORT_OK'}   = [ @EXPORT_OK  ];
  $EXPORT_TAGS{'EXPORT'}      = [ @EXPORT     ];
  
  our $status_prefix = "";
  
  our %ERRORS;
  
  BEGIN {
      # needs to be before die_sub(), otherwise could get 'Use of uninitialized value $HariSekhonUtils::ERRORS{"CRITICAL"} in exit' and exit with blank / 0 incorrect error code on early stage failures such as 'This Perl not built to support threads'
      #
      # Std Nagios Exit Codes. Not using weak nagios utils.pm. Also improves portability to not rely on it being present
      %ERRORS = (
          "OK"        => 0,
          "WARNING"   => 1,
          "CRITICAL"  => 2,
          "UNKNOWN"   => 3,
          "DEPENDENT" => 4
      );
  
      delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
      $ENV{'PATH'} = '/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/local/sbin';
  
      # If we're a Nagios plugin check_* then make stderr go to stdout
      if(substr(basename($0), 0, 6) eq "check_"){
          open STDERR, ">&STDOUT";
          select(STDERR);
          $| = 1;
          select(STDOUT);
          $| = 1;
      }
  
      sub die_sub {
          # this is auto-translated in to equivalent system error string, we're not interested in system interpretation
          # so explicitly cast back to int so we can compare with std error codes
          # XXX: $? can't be trusted because die calls leave this as zero, especially bad from Perl modules, which then prefixes "OK:" and returns zero exit code!!! Therefore no longer unifying quit() to use die, since this dual behaviour cannot be determined inside this sub. Now only call die for real errors, if UNKNOWN is set for code_error then leave UNKNOWN, otherwise force CRITICAL
          my $exit_code = ( defined($?) and $? == $ERRORS{"UNKNOWN"} ? $ERRORS{"UNKNOWN"} : $ERRORS{"CRITICAL"} );
          #$exit_code = (defined($exit_code) and $exit_code ne "" ? int($exit_code) : $ERRORS{"CRITICAL"});
          my $str   = "@_" || "Died";
          # better to add the status prefix in here instead of in quit calls
          #my $status_prefixes = join("|", keys %ERRORS);
          #$str =~ s/:\s+(?:$status_prefixes):/:/g;
          if(substr(basename($0), 0, 6) eq "check_"){
              my $prefix = "";
              foreach(keys %ERRORS){
                  if($exit_code == $ERRORS{$_}){
                      $prefix = $_;
                      last;
                  }
              }
              $prefix = "CRITICAL" unless $prefix;
              $status_prefix = "" unless $status_prefix;
              $str = "${status_prefix}${prefix}: $str";
          }
          # mimic original die behaviour by only showing code line when there is no newline at end of string
          if(substr($str, -1, 1) eq "\n"){
              print STDERR $str;
          } else {
              carp $str;
          }
          if(grep(/^$exit_code$/, values %ERRORS)){
              exit $exit_code;
          }
          exit $ERRORS{"CRITICAL"};
      };
      if(substr(basename($0), 0, 6) eq "check_"){
          $SIG{__DIE__} = \&die_sub;
      }
  
      # This is because the die handler causes program exit instead of return from eval {} block required for exception handling
      sub try(&) {
          my $old_die = $SIG{__DIE__};
          if(defined($SIG{__DIE__})){
              undef $SIG{__DIE__};
          }
          eval {$_[0]->()};
          #$SIG{__DIE__} = \&die_sub;
          $SIG{__DIE__} = $old_die;
      }
  
      sub catch(&) {
          $_[0]->($@) if $@;
      }
  }
  
  # quick prototype to allow me to use this just below
  sub quit(@);
  
  our $progname = basename $0;
  $progname =~ /^([\w\.\/_-]+)$/ or quit("UNKNOWN", "Invalid program name - does not adhere to strict regex validation, you should name the program simply and sanely");
  $progname = $1;
  
  our $nagios_plugins_support_msg = "Please try latest version from https://github.com/harisekhon/nagios-plugins, re-run on command line with -vvv and if problem persists paste full output from -vvv mode in to a ticket requesting a fix/update at https://github.com/harisekhon/nagios-plugins/issues/new";
  our $nagios_plugins_support_msg_api = "API may have changed. $nagios_plugins_support_msg";
  
  # ============================================================================ #
  
  our $critical;
  our $debug = 0;
  our $email;
  our $expected_version;
  our $help;
  our $host;
  our $github_repo;
  our $json;
  our $msg = "";
  our $msg_err = "";
  our $msg_threshold = "";
  our $multiline;
  our $nodes;
  my  @options;
  our %options;
  our $password;
  our $port;
  my  $selflock;
  our $status = "UNKNOWN";
  our $sudo = "";
  our $syslog_initialized = 0;
  our $ssl;
  our $ssl_ca_path;
  our $ssl_noverify;
  our $tls;
  our $timeout_current_action = "";
  our $timeout_default = 10;
  our $timeout_max     = 60;
  our $timeout_min     = 1;
  our $timeout         = undef;
  our $usage_line      = "usage: $progname [ options ]";
  our $user;
  our %thresholds;
  # Standard ordering of usage options for help. Exported and overridable inside plugin to customize usage()
  our @usage_order  = qw/host port user users groups password database table query field regex warning critical ssl tls ssl-CA-path ssl-noverify tls-noverify multiline/;
  # Not sure if I can relax the case sensitivity on these according to the Nagios Developer guidelines
  my  @valid_units = qw/% s ms us B KB MB GB TB c/;
  our $verbose = 0;
  our $version;
  our $warning;
  
  # ============================================================================ #
  # Validation Regex - maybe should qr// here but it makes the vlog option output messy
  # ============================================================================ #
  # tried reversing these to be in $regex_blah format and not auto exporting but this turned out to be less intuitive from the perspective of a module caller and it was convenient to just use the regex in pieces of code without having to import them specially. This also breaks some code such as check_hadoop_jobtracker.pl which uses $domain_regex
  my  $domain_component   = '\b[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\b';
  # validated against http://data.iana.org/TLD/tlds-alpha-by-domain.txt which lists all possible TLDs assigned by IANA
  # this matches everything except the XN--\w{6,10} TLDs as of 8/10/2012
  #our $tld_regex          = '\b(?:[A-Za-z]{2,4}|london|museum|travel|local|localdomain|intra)\b';
  # Using the official list now to be tighter and avoid matching things like node.role in elasticsearch
  # to allow the prototype to be checked
  sub open_file ($;$);
  sub code_error (@);
  
  our $tld_regex = "\\b(?i:";
  my $total_tld_count = 0;
  
  sub load_tlds($){
      my $file = shift;
      my $fh = open_file($file);
      my $tld_count;
      while(<$fh>){
          chomp;
          s/#.*//;
          next if /^\s*$/;
          if(/^([A-Za-z0-9-]+)$/){
              $tld_regex .= "$1|";
              $tld_count += 1;
          } else {
              warn "TLD: '$_' from tld file '$file' not validated, skipping that TLD";
          }
      }
      # debug isn't set by this point
      #warn "$tld_count tlds loaded from tld file '$file'\n";
      $total_tld_count += $tld_count;
  }
  # downloaded from IANA, run 'make tld' to update
  my $tld_file = dirname(__FILE__) . "/resources/tlds-alpha-by-domain.txt";
  load_tlds($tld_file);
  $total_tld_count > 1000 or code_error("$total_tld_count tlds loaded, expected > 1000");
  my $custom_tlds = dirname(__FILE__) . "/resources/custom_tlds.txt";
  if(-f $custom_tlds){
      load_tlds($custom_tlds);
  }
  $tld_regex =~ s/\|$//;
  $tld_regex .= ")\\b";
  #print "tld_regex = $tld_regex\n";
  # debug isn't set by this point
  #warn "$total_tld_count tlds loaded\n";
  $total_tld_count < 2000 or code_error("$total_tld_count tlds loaded, expected < 2000");
  
  # AWS regex from http://blogs.aws.amazon.com/security/blog/tag/key+rotation
  our $aws_access_key_regex = '(?<![A-Z0-9])[A-Z0-9]{20}(?![A-Z0-9])';
  our $aws_secret_key_regex = '(?<![A-Za-z0-9/+=])[A-Za-z0-9/+=]{40}(?![A-Za-z0-9/+=])';
  our $domain_regex       = '(?:' . $domain_component . '\.)*' . $tld_regex;
  our $domain_regex2      = '(?:' . $domain_component . '\.)+' . $tld_regex;
  our $domain_regex_strict = $domain_regex2;
  # must permit numbers as valid host identifiers that are being used in the wild in FQDNs
  our $hostname_component = '\b[A-Za-z0-9](?:[A-Za-z0-9_\-]{0,61}[a-zA-Z0-9])?\b';
  #our $aws_host_ip_regex  = 'ip-(?:10-\d+-\d+-\d+|172-1[6-9]-\d+-\d+|172-2[0-9]-\d+-\d+|172-3[0-1]-\d+-\d+|192-168-\d+-\d+)';
  # the ip- prefix gives it away as an IP so can be a bit more general and let's catch all IPs not just private ranges
  our $aws_host_ip_regex  = '\bip-\d+-\d+-\d+-\d+\b';
  our $hostname_regex     = "$hostname_component(?:\.$domain_regex)?";
  our $aws_hostname_regex = "$aws_host_ip_regex(?:\.$domain_regex)?";
  our $dirname_regex      = '[\/\w\s\\.,:*()=%?+-]+';
  our $filename_regex     = $dirname_regex . '[^\/]';
  our $rwxt_regex         = '[r-][w-][x-][r-][w-][x-][r-][w-][xt-]';
  our $fqdn_regex         = $hostname_component . '\.' . $domain_regex;
  our $aws_fqdn_regex     = $aws_host_ip_regex . '\.' . $domain_regex;
  # SECURITY NOTE: I'm allowing single quote through as it's found in Irish email addresses. This makes the $email_regex non-safe without further validation. This regex only tests whether it's a valid email address, nothing more. DO NOT UNTAINT EMAIL or pass to cmd to SQL without further validation!!!
  our $email_regex        = '\b[A-Za-z0-9](?:[A-Za-z0-9\._\%\'\+-]{0,62}[A-Za-z0-9\._\%\+-])?@' . $domain_regex . '\b';
  # TODO: review this IP regex again
  our $ip_prefix_regex    = '\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}';
  our $ip_regex           = $ip_prefix_regex . '(?:25[0-5]|2[0-4][0-9]|[01]?[1-9][0-9]|[01]?0[1-9]|[12]00|[0-9])\b'; # now allowing 0 or 255 as the final octet due to CIDR
  our $subnet_mask_regex  = '\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[1-9][0-9]|[01]?0[1-9]|[12]00|[0-9])\b';
  our $mac_regex          = '\b[0-9A-Fa-f]{1,2}[:-](?:[0-9A-Fa-f]{1,2}[:-]){4}[0-9A-Fa-f]{1,2}\b';
  our $host_regex         = "\\b(?:$hostname_regex|$ip_regex)\\b";
  # I did a scan of registered running process names across several hundred linux servers of a diverse group of enterprise applications with 500 unique process names (58k individual processes) to determine that there are cases with spaces, slashes, dashes, underscores, chevrons (<defunct>), dots (script.p[ly], in.tftpd etc) to determine what this regex should be. Incidentally it appears that Linux truncates registered process names to 15 chars.
  # This is not from ps -ef etc it is the actual process registered name, hence init not [init] as it appears in ps output
  our $process_name_regex = '\s*[\w_\.\/\<\>-][\w\s_\.\/\<\>-]*';
  our $url_path_suffix_regex = '/(?:[\w.,:\/%&?!#=*|\[\]~+-]+)?';
  our $url_regex          = '\b(?i:https?://' . $host_regex . '(?::\d{1,5})?(?:' . $url_path_suffix_regex . ')?)';
  our $user_regex         = '\b[A-Za-z0-9][A-Za-z0-9\._-]*[A-Za-z0-9]\b';
  our $column_regex       = '\b[\w\:]+\b';
  our $ldap_dn_regex      = '\b\w+=[\w\s-]+(?:,\w+=[\w\s-]+)*\b';
  our $krb5_principal_regex = "$user_regex(?:\/$hostname_regex)?(?:\@$domain_regex)?";
  our $threshold_range_regex  = qr/^(\@)?(-?\d+(?:\.\d+)?)(:)(-?\d+(?:\.\d+)?)?$/;
  our $threshold_simple_regex = qr/^(-?\d+(?:\.\d+)?)$/;
  our $label_regex        = '\s*[\%\(\)\/\*\w-][\%\(\)\/\*\w\s-]+';
  our $version_regex      = '\d(\.\d+)*';
  our $version_regex_lax  = $version_regex . '-?.*';
  
  # ============================================================================ #
  #                                   Options
  # ============================================================================ #
  # universal options added automatically when using get_options()
  our %default_options = (
      "D|debug+"     => [ \$debug,    "Debug code" ],
      "t|timeout=i"  => [ \$timeout,  "Timeout in secs (\$TIMEOUT, default: $timeout_default)" ],
      "v|verbose+"   => [ \$verbose,  "Verbose level (\$VERBOSE=<int>, or use multiple -v, -vv, -vvv)" ],
      "V|version"    => [ \$version,  "Print version and exit" ],
      "h|help"       => [ \$help,     "Print description and usage options" ],
  );
  
  # These two subroutines are primarily for my other programs such as my spotify programs which have necessarily longer run times and need a good way to set this and have the %default_options auto updated for usage() to automatically stay in sync with the live options
  sub set_timeout_max ($) {
      $timeout_max = shift;
      isInt($timeout_max) or code_error("must pass an integer to set_timeout_max()");
  }
  
  
  sub set_timeout_default ($) {
      $timeout_default = shift;
      isInt($timeout_default) or code_error("must pass an integer to set_timeout_default()");
      ($timeout_default > $timeout_max) and code_error("\$timeout_default ($timeout_default) may not be higher than \$timeout_max ($timeout_max)");
      ($timeout_default < $timeout_min) and code_error("\$timeout_default ($timeout_default) may not be lower than \$timeout_min ($timeout_min)");
      $timeout = $timeout_default;
      $default_options{"t|timeout=i"} = [ \$timeout, "Timeout in secs (default: $timeout_default)" ];
  }
  
  sub set_timeout_range($$){
      my $min = shift;
      my $max = shift;
      isInt($min) or code_error("non-integer passed to set_timeout_range for min (first arg)");
      isInt($max) or code_error("non-integer passed to set_timeout_range for max (second arg)");
      $timeout_min = $min;
      $timeout_max = $max;
  }
  
  # ============================================================================ #
  # Optional options
  our %hostoptions = (
      "H|host=s"      => [ \$host, "Host to connect to" ],
      "P|port=s"      => [ \$port, "Port to connect to" ],
  );
  our %nodeoptions = (
      "N|nodes=s"     => [ \$nodes, "Nodes to connect to" ],
      "P|port=s"      => [ \$port,  "Port to connect to if not appended to each node in the node list in the form 'host:port'"  ],
  );
  our %useroptions = (
      "u|user=s"      => [ \$user,     "User to connect with" ],
      "p|password=s"  => [ \$password, "Password to connect with" ],
  );
  our %multilineoption = (
      "m|multiline"   => [ \$multiline,  "Multiline output for easier viewing" ],
  );
  our %thresholdoptions = (
      "w|warning=s"   => [ \$warning,  "Warning  threshold or ran:ge (inclusive)" ],
      "c|critical=s"  => [ \$critical, "Critical threshold or ran:ge (inclusive)" ],
  );
  our %emailoptions = (
      "E|email=s"     => [ \$email,   "Email address" ],
  );
  our %expected_version_option = (
      "e|expected=s"     => [ \$expected_version,     "Expected version regex, raises CRITICAL if not matching, optional" ]
  );
  our %ssloptions = (
      "S|ssl"            => [ \$ssl,          "Use SSL connection" ],
      "ssl-CA-path=s"    => [ \$ssl_ca_path,  "Path to CA certificate directory for validating SSL certificate (automatically enables --ssl)" ],
      "ssl-noverify"     => [ \$ssl_noverify, "Do not verify SSL certificate (automatically enables --ssl)" ],
  );
  our %tlsoptions = (
      "T|tls"            => [ \$tls,          "Use TLS connection" ],
      "ssl-CA-path=s"    => [ \$ssl_ca_path,  "Path to CA certificate directory for validating SSL certificate (automatically enables --tls)" ],
      "tls-noverify"     => [ \$ssl_noverify, "Do not verify SSL certificate (automatically enables --tls)" ],
  );
  my $short_options_len = 0;
  my $long_options_len  = 0;
  
  
  #sub add_host_options($){
  #    my $name = shift;
  #    defined($name) or code_error("no name arg passed to add_host_options()");
  #    if(length($name) >= 4){
  #        $name = join " ", map {ucfirst} split " ", lc $name;
  #    }
  #    foreach(keys %hostoptions){
  #        $hostoptions{$_}[1] =~ s/^(.)/$name \L$1/;
  #    }
  #    %options = ( %options, %hostoptions );
  #}
  
  #sub add_user_options($){
  #    my $name = shift;
  #    defined($name) or code_error("no name arg passed to add_user_options()");
  #    if(length($name) >= 4){
  #        $name = join " ", map {ucfirst} split " ", lc $name;
  #    }
  #    foreach(keys %useroptions){
  #        $useroptions{$_}[1] =~ s/^(.)/$name \L$1/;
  #    }
  #    %options = ( %options, %useroptions );
  #}
  
  my $default_host;
  sub set_host_default($;$){
      #defined($default_host) and code_error("default host cannot be set twice");
      # already defined, first one wins
      defined($default_host) and not defined($_[1]) and return;
      $default_host = shift;
      isHost($default_host) or code_error("invalid host passed as first arg to set_host_default");
      if(not defined($host)){
          $host = $default_host;
      }
      $hostoptions{"H|host=s"}[1] =~ s/\)$/, default: $default_host\)/;
      return $host;
  }
  
  my $default_port;
  sub set_port_default($;$){
      #defined($default_port) and code_error("default port cannot be set twice");
      # already defined, first one wins
      defined($default_port) and not defined($_[1]) and return;
      $default_port = shift;
      isPort($default_port) or code_error("invalid port passed as first arg to set_port_default");
      if(not defined($port)){
          $port = $default_port;
      }
      $hostoptions{"P|port=s"}[1] =~ s/\)$/, default: $default_port\)/;
      return $port;
  }
  
  sub set_threshold_defaults($$){
      our $default_warning  = shift;
      our $default_critical = shift;
      isThreshold($default_warning)  or code_error("invalid warning threshold passed as first arg to set_threshold_defaults()");
      isThreshold($default_critical) or code_error("invalid critical threshold passed as second arg to set_threshold_defaults()");
      $warning  = $default_warning;
      $critical = $default_critical;
      $thresholdoptions{"w|warning=s"}[1]  =~ s/\)$/, default: $default_warning\)/;
      $thresholdoptions{"c|critical=s"}[1] =~ s/\)$/, default: $default_critical\)/;
  }
  
  # ============================================================================ #
  # Environment Host/Port and User/Password Credentials
  
  my @host_envs;
  my @port_envs;
  my @user_envs;
  my @password_envs;
  
  my $port_env_found = 0;
  
  sub env_cred($){
      my $name = shift;
      $name = uc $name;
      $name =~ s/[^A-Za-z0-9]/_/g;
      $name .= "_" if $name;
      push(@host_envs,     "\$${name}HOST");
      push(@port_envs,     "\$${name}PORT");
      push(@user_envs,     "\$${name}USERNAME");
      push(@user_envs,     "\$${name}USER");
      push(@password_envs, "\$${name}PASSWORD");
      # Can't vlog here since verbose mode and debug mode aren't set until after option processing
      if($ENV{"${name}HOST"} and not $host){
          #vlog2("reading host from \$${name}HOST environment variable");
          $host = $ENV{"${name}HOST"};
      }
      if($ENV{"${name}PORT"} and not $port_env_found){
          #vlog2("reading port from \$${name}PORT environment variable");
          $port = $ENV{"${name}PORT"};
          $port_env_found++;
      }
      if($ENV{"${name}USERNAME"} and not $user){
          #vlog2("reading user from \$${name}USERNAME environment variable");
          $user = $ENV{"${name}USERNAME"};
      } elsif($ENV{"${name}USER"} and not $user){
          #vlog2("reading user from \$${name}USER environment variable");
          $user = $ENV{"${name}USER"};
      }
      if($ENV{"${name}PASSWORD"} and not $password){
          #vlog2("reading password from \$${name}PASSWORD environment variable");
          $password = $ENV{"${name}PASSWORD"};
      }
      return 1;
  }
  
  sub env_creds($;$){
      my $name     = shift;
      my $longname = shift;
      ( defined($name) and $name ) or code_error("no name arg passed to env_creds()");
      unless($longname){
          unless(isScalar(\$name)){
              code_error("must supply longname second arg to env_creds() if first arg for ENV is not a scalar");
          }
          if($name ne uc $name){
              $longname = $name;
          } elsif(length($name) < 5){
              $longname = $name;
          } else {
              $longname = join " ", map {ucfirst} split " ", lc $name;
          }
      }
  
      if(isScalar(\$name)){
          env_cred($name);
      } elsif(isArray($name)){
          foreach (@{$name}){
              env_cred($_);
          }
      } else {
          code_error("non-scalar/non-array ref passed as first arg to env_creds()");
      }
  
      env_cred("");
  #    if($ENV{"HOST"}){
  #        $host = $ENV{"HOST"} unless $host;
  #    }
  #    if($ENV{"PORT"}){
  #        $port = $ENV{"PORT"} unless $port;
  #    }
  #    if($ENV{"USERNAME"}){
  #        $user = $ENV{"USERNAME"} unless $user;
  #    } elsif($ENV{"USER"}){
  #        $user = $ENV{"USER"} unless $user;
  #    }
  #    if($ENV{"PASSWORD"}){
  #        $password = $ENV{"PASSWORD"} unless $password;
  #    }
  
      $hostoptions{"H|host=s"}[1]     = "$longname host (" . join(", ", @host_envs) . ")";
      $hostoptions{"P|port=s"}[1]     = "$longname port (" . join(", ", @port_envs) . ( defined($port) ? ", default: $port)" : ")");
      #$nodeoptions{"N|node=s"}[1]     = "$longname node (" . join(", ", @host_envs) . ")";
      #$nodeoptions{"P|port=s"}[1]     = "$longname port (" . join(", ", @port_envs) . ( defined($port) ? ", default: $port)" : ")");
      $useroptions{"u|user=s"}[1]     = "$longname user (" . join(", ", @user_envs) . ")";
      $useroptions{"p|password=s"}[1] = "$longname password (" . join(", ", @password_envs) . ")";
      return 1;
  }
  
  sub env_var($$){
      my $name    = shift;
      my $var_ref = shift;
      $name = uc $name;
      $name =~ s/[^A-Za-z0-9]/_/g;
      if($ENV{$name} and not defined($$var_ref)){
          $$var_ref = $ENV{$name};
      }
      return 1;
  }
  
  sub env_vars($$){
      my $name    = shift;
      my $var_ref = shift;
      if(isScalar(\$name)){
          env_var($name, $var_ref);
      } elsif(isArray($name)){
          foreach (@{$name}){
              env_var($_, $var_ref);
          }
      } else {
          code_error("non-scalar/non-array ref passed as first arg to env_vars()");
      }
      return 1;
  }
  
  # ============================================================================ #
  #                           Nagios Exit Code Functions
  # ============================================================================ #
  
  # Set status safely - escalate only
  
  # there is no ok() since that behaviour needs to be determined by scenario
  
  sub unknown () {
      if($status eq "OK"){
          $status = "UNKNOWN";
      }
  }
  
  sub warning () {
      if($status ne "CRITICAL"){
          $status = "WARNING";
      }
  }
  
  sub critical () {
      $status = "CRITICAL";
  }
  
  ############################
  sub is_ok () {
      ($status eq "OK");
  }
  
  sub is_warning () {
      ($status eq "WARNING");
  }
  
  sub is_critical () {
      ($status eq "CRITICAL");
  }
  
  sub is_unknown () {
      ($status eq "UNKNOWN");
  }
  
  sub get_status_code (;$) {
      if($_[0]){
          defined($ERRORS{$_[0]}) || code_error("invalid status '$_[0]' passed to get_status_code()");
          return $ERRORS{$_[0]};
      } else {
          defined($ERRORS{$status}) || code_error("invalid status '$status' found in \$status variable used by get_status_code()");
          return $ERRORS{$status};
      }
  }
  
  sub status () {
      my $status = get_status_code();
      vlog("status: $status");
      return $status;
  }
  
  # status2/3 not exported/used at this time
  sub status2 () {
      my $status = get_status_code();
      vlog2("status: $status");
      return $status;
  }
  
  sub status3 () {
      my $status = get_status_code();
      vlog3("status: $status");
      return $status;
  }
  
  # requires that you 'use Data::Dumper' in calling program, since not all programs will need this
  sub catch_quit ($) {
      my $my_errmsg = $_[0];
      catch {
          if(isObject($@) and defined($@->{"message"})){
              $my_errmsg .= ": " . ref($@) . ": " . $@->{"message"};
          } elsif($!) {
              $my_errmsg .= ": $!";
          } elsif($@ and not isObject($@)) {
              $my_errmsg .= ": $@";
          }
          chomp $my_errmsg;
          #$my_errmsg =~ s/ $filename_regex line \d+\.$//;
          quit "CRITICAL", $my_errmsg;
      };
      return 1;
  }
  
  # ============================================================================ #
  
  
  #sub option_present ($) {
  #    my $new_option = shift;
  #    grep {
  #        my @option_switches = split("|", $_);
  #        my @new_option_switches = split("|", $new_option);
  #    } (keys %options);
  #}
  
  
  # TODO: consider calling this from get_options and passing hashes we want options for straight to that sub
  
  # TODO: fix this to use option_present
  #sub add_options ($) {
  #    my $options_hash = shift;
  #    isHash($options_hash, 1);
  #    #@default_options{keys %options} = values %options;
  #    #@default_options{keys %{$_[0]}} = values %{$options_hash};
  #    foreach my $option (keys %{$options_hash}){
  #        unless(option_present($option)){
  #            print "want to add $option\n";
  #            #$default_options{$option} = ${$options_hash{$option}};
  #        }
  #    }
  #
  ##    #my (%optionshash) = @_;
  ##    # by ref is faster
  ##    my $hashref = shift;
  ##    unless(isHash($hashref)){
  ##        #my ($package, $file, $line) = caller;
  ##        code_error("non hash ref passed to add_options subroutine"); # at " . $file . " line " . $line);
  ##    }
  ##    # TODO: consider replacing this with first position insertion in array in get_options for efficiency
  ##    foreach my $option (keys %options){
  ##        unless grep { grep($options keys %{$_} } @options){
  ##            push(@options, { $_ => $options{$_} })
  ##        };
  ##    }
  ##    #foreach(keys %hashref){
  ##    #    push(@options, { $_ => $hashref{$_} });
  ##    #}
  #}
  
  
  #sub update_option_description {
  #    my $option =
  #}
  
  
  #sub add_thresholds {
  #    our $range_inversion = 0;
  #    foreach(keys %thresholds){
  #        $options{$_} = $thresholds{$_};
  #    }
  #}
  
  
  # For reference only, faster to just put this directly in to code
  #sub isUserNameEUID(){
  #    #my $user = shift;
  #    #defined($user) or code_error "no user passed to amIuser()";
  #    # checking EUID against arg
  #    getpwuid($>) eq shift;
  #}
  
  
  sub autoflush () {
      select(STDERR);
      $| = 1;
      select(STDOUT);
      $| = 1;
      return 1;
  }
  
  
  sub assert_array($$) {
      my $array = shift;
      my $name  = shift;
      isArray($array) or quit "UNKNOWN", "$name is not an array! $nagios_plugins_support_msg_api";
  }
  
  sub assert_float($$) {
      my $float = shift;
      my $name  = shift;
      isFloat($float) or quit "UNKNOWN", "$name is not a float! $nagios_plugins_support_msg_api";
  }
  
  sub assert_hash($$) {
      my $hash = shift;
      my $name = shift;
      isHash($hash) or quit "UNKNOWN", "$name is not a hash! $nagios_plugins_support_msg_api";
  }
  
  sub assert_int($$) {
      my $int  = shift;
      my $name = shift;
      isInt($int, "signed") or quit "UNKNOWN", "$name is not an integer! $nagios_plugins_support_msg_api";
  }
  
  
  sub check_regex ($$;$) {
      my $string = shift;
      my $regex  = shift;
      my $no_msg = shift;
      defined($string) or code_error("undefined string passed to check_regex()");
      defined($regex)  or code_error("undefined regex passed to check_regex()");
      if($string !~ /$regex/){
          critical;
          $msg .= " (expected regex: '$regex')" unless $no_msg;
          return;
      }
      return 1;
  }
  
  
  sub check_string ($$;$) {
      my $string           = shift;
      defined($string) or code_error("undefined string passed to check_string()");
      my $expected_string  = shift;
      my $no_msg           = shift;
      if(defined($expected_string) and $string ne $expected_string){
          critical;
          $msg .= " (expected: '$expected_string')" unless $no_msg;
          return;
      }
      return 1;
  }
  
  
  sub check_threshold ($$) {
      #subtrace(@_);
      my $threshold = shift;
      my $result    = shift;
  
      $threshold =~ /(?:warning|critical)$/ or code_error("invalid threshold name passed to check_threshold subroutine");
      isFloat($result, 1) or isScientific($result, 1) or code_error("Non-float passed to check_threshold subroutine");
  
      my $upper = defined($thresholds{$threshold}{"upper"}) ? $thresholds{$threshold}{"upper"} : undef;
      my $lower = defined($thresholds{$threshold}{"lower"}) ? $thresholds{$threshold}{"lower"} : undef;
      my $invert_range = $thresholds{$threshold}{"invert_range"} || undef;
      my $error = 0;
  
      if(!$invert_range){
          debug("doing straight non range-inverted $threshold threshold checks");
          debug("if result $result > $threshold upper ($upper)") if defined($upper);
          debug("if result $result < $threshold lower ($lower)") if defined($lower);
          if(defined($upper) and $result > $upper){
              $error = "$result>$upper";
          }
          elsif(defined($lower) and $result < $lower){
              $error = "$result<$lower";
          }
      } else {
          debug("doing range-inverted $threshold threshold checks");
          debug("if result $result <= $threshold upper ($upper)") if defined($upper);
          debug("if result $result >= $threshold lower ($lower)") if defined($lower);
          if(defined($upper) and defined($lower)){
              if($lower <= $result and $result <= $upper ){
              #$error = " $result not within range $lower-$upper";
              $error = "not within range $lower-$upper";
              }
          } else {
              if(defined($upper) and $result <= $upper){
                  $error = "$result<=$upper";
              }
              elsif(defined($lower) and $result >= $lower){
                  $error = "$result>=$lower";
              }
          }
      }
      if($error){
          $thresholds{$threshold}{"error"} = $error;
          vlog2("result outside of $threshold thresholds: $error\n");
          if($threshold =~ /warning/){
              warning;
          } else {
              critical;
          }
          # $threshold_ok false
          return 0;
      } else {
          undef $thresholds{$threshold}{"error"};
      }
      # $threshold_ok true
      return 1;
  }
  
  
  sub check_thresholds ($;$$) {
      #subtrace(@_);
      my $result            = shift;
      my $no_msg_thresholds = shift || 0;
      my $name              = shift() || "";
      $name .= " " if $name;
      vlog2("checking ${name}thresholds");
      defined($result) or code_error("no result passed to check_thresholds()");
      my $status_ok = check_threshold("${name}critical", $result) and
                      check_threshold("${name}warning",  $result);
      # this is switched off because it's done via msg_thresholds chaining in to return below, do not re-enable this or you'll get double printing
      #msg_thresholds() unless $no_msg_thresholds;
      return ($status_ok, msg_thresholds($no_msg_thresholds, $name));
  }
  
  
  #sub checksum ($;$) {
  #    my $file = shift;
  #    my $algo = shift;
  #    $algo or $algo = "md5";
  #    my $fh;
  #    unless(open($fh, $file)){
  #        vlog "Failed to read file '$file': $!\n";
  #        return;
  #    }
  #    binmode($fh);
  #    my $checksum;
  #    if($algo eq "md5"){
  #        $checksum = Digest::MD5->new;
  #    } elsif ($algo eq "sha1"){
  #        $checksum = Digest::Sha->new("sha1");
  #    } else {
  #        croak "checksum passed unsupported algorithm type '$algo'";
  #    }
  #    $checksum->addfile($fh);
  #    return $checksum->hexdigest;
  #}
  #sub sha1sum {
  #    return checksum($_[0], "sha1");
  #}
  #
  #sub md5sum {
  #    return checksum($_[0], "md5");
  #}
  
  
  sub cmd ($;$$$) {
      my $cmd     = shift;
      my $errchk  = shift;
      my $inbuilt = shift;
      my $return_exitcode = shift;
      $cmd =~ s/^\s+//;
      my $prog      = (split(/\s+/, $cmd))[0];
      if($prog eq "exec"){
          $prog = (split(/\s+/, $cmd))[1];
      }
      if($inbuilt){
          # TODO: consider adding inbuilt check, however this means two shell calls per command, very inefficient, think it's better to just catch failure
          #type($prog, 1);
      } else {
          which($prog, 1);
      }
      # this would be if we were gonna support shell built-ins
      #unless(which($prog)){
      #    type($prog) or quit("UNKNOWN", "'$prog' command was not found in \$PATH and is not a shell built-in");
      #    $prog = (split(/\s+/, $cmd))[1];
      #    which($prog, 1);
      #}
      if($cmd =~ s/\|\s*$//){
          # return reference to filehandle for more efficient processing
          vlog2("opening cmd pipe");
          vlog3("cmd: $cmd");
          open my $fh, "$cmd |";
          return $fh;
      }
      vlog3("cmd: $cmd");
      # XXX: this doesn't work to solve Alpine's buggy behaviour of not returning error output and non-zero exit code when testing validate_regex() posix with broken capture of no closing brace
      #open my $fh, "$cmd 2>&1 |";
      my $return_output = `$cmd 2>&1`;
      my $exitcode      = $?;
      #my $return_output = do { local $/; <$fh> };
      #close $fh;
      my @output        = split("\n", $return_output);
      $exitcode         = $exitcode >> 8;
      vlog3("output:\n\n$return_output");
      vlog3("exitcode: $exitcode\n");
      if ($errchk and $exitcode != 0) {
          my $err = "";
          if(substr($progname, 0, 6) eq "check_"){
              foreach (@output) {
                  $err .= " " . trim($_);
              }
          } else {
              $err = join("\n", @output);
          }
          quit("CRITICAL", "'$cmd' returned $exitcode - $err");
      }
      if($return_exitcode){
          return ($exitcode, @output);
      } else {
          return @output;
      }
  }
  
  
  sub code_error (@) {
      use Carp;
      #quit("UNKNOWN", "Code Error - @_");
      $? = $! = $ERRORS{"UNKNOWN"};
      if($debug){
          confess "Code Error - @_";
      } else {
          croak "Code Error - @_";
      }
  }
  
  
  # Remove blanks from array
  sub compact_array (@) {
      return grep { $_ !~ /^\s*$/ } @_;
  }
  
  
  sub curl ($;$$$$$$) {
      my $url      = shift;
      my $name     = shift;
      my $user     = shift;
      my $password = shift;
      my $err_sub  = shift;
      my $type     = shift() || 'GET';
      my $body     = shift;
      grep { $type eq $_ } qw/GET POST PUT DELETE HEAD/ or code_error "unsupported type '$type' passed to curl() as sixth argument";
      #debug("url passed to curl: $url");
      defined($url) or code_error "no URL passed to curl()";
      my $url2 = isUrl($url) or code_error "invalid URL '$url' supplied to curl()";
      $url = $url2;
      my $host = $url;
      $host =~ s/^https?:\/\///;
      $host =~ s/(?::\d+)?(?:\/.*)?$//;
      isHost($host) or die "invalid host determined from URL '$url' in curl()";
      my $auth = (defined($user) and defined($password));
      # don't replace $host with resolved host as this changes the vlog output, affects proxy exceptions can break load balancer routing with '503 Service Temporarily Unavailable'
      validate_resolvable($host);
      if($name){
          if($type eq "POST"){
              vlog2("POSTing to $name");
          } elsif($type eq "PUT"){
              vlog2("PUTing to $name");
          } else {
              vlog2("querying $name");
          }
          vlog3("HTTP $type $url" . ( $auth ? " (basic authentication)" : "") );
      } else {
          vlog2("HTTP $type $url" . ( $auth ? " (basic authentication)" : "") );
      }
      if($type eq "POST" or $type eq "PUT"){
          vlog3($body);
      }
      #unless(defined(&main::get)){
          # inefficient, it'll import for each curl call, instead force top level author to
          # use LWP::Simple 'get'
          #debug("importing LWP::Simple 'get'\n");
          #require LWP::Simple;
          #import LWP::Simple "get";
          #code_error "called curl() without declaring \"use LWP::Simple 'get'\"";
      #}
      #$content = main::get $url;
      #my ($result, $err) = ($?, $!);
      #vlog2("result: $result");
      #vlog2("error:  " . ( $err ? $err : "<none>" ) . "\n");
      #if($result ne 0 or $err){
      #    quit("CRITICAL", "failed to get '$url': $err");
      #}
      defined_main_ua();
      $main::ua->show_progress(1) if $debug;
      $main::ua->env_proxy;
      my $req = HTTP::Request->new($type, $url);
      # LWP timeout should always be less than global timeout to prevent "UNKNOWN" erorrs
      if ($timeout >= 1) {
          $main::ua->timeout($timeout-.5);
      } else {
          $main::ua->timeout(.5);
      }
      $req->authorization_basic($user, $password) if (defined($user) and defined($password));
      $req->content($body) if $body;
      my $response = $main::ua->request($req);
      my $content  = $response->content;
      vlog3("returned HTML:\n\n" . ( $content ? $content : "<blank>" ) . "\n");
      vlog2("http status code:     " . $response->code);
      vlog2("http status message:  " . $response->message . "\n");
      if($err_sub){
          isCode($err_sub) or code_error "invalid subroutine passed to curl() as error handler";
          &$err_sub($response);
      } else {
          unless($response->code eq "200"){
              my $additional_information = "";
              my $json;
              if($json = isJson($content)){
                  foreach(qw/status error message reason/){
                      if(defined($json->{$_})){
                          $_ eq "status" and $json->{$_} eq $response->code and next;
                          $additional_information .= ". " . ucfirst($_) . ": " . $json->{$_};
                      }
                  }
              }
              quit("CRITICAL", $response->code . " " . $response->message . $additional_information);
          }
          unless($content){
              quit("CRITICAL", "blank content returned from '$url'");
          }
      }
      return $content;
  }
  
  
  sub curl_json ($;$$$$$$) {
      my $url         = shift;
      my $name        = shift;
      my $user        = shift;
      my $password    = shift;
      my $err_handler = shift;
      my $type        = shift() || 'GET';
      my $body        = shift;
      my $content     = curl $url, $name, $user, $password, $err_handler, $type, $body;
      vlog2("parsing output from " . ( $name ? $name : $url ) . "\n");
      $json = isJson($content) or quit "CRITICAL", "invalid json returned " . ( $name ? "by $name at $url" : "from $url");
  }
  
  
  sub debug (@) {
      return unless $debug;
      my ( $package, $filename, $line ) = caller;
      my $debug_msg = "@_";
      $debug_msg =~ s/^(\n+)//;
      #my $prefix_newline = $1 || "";
      my $sub = (caller(1))[3];
      if($sub){
          $sub .= "()";
      } else {
          $filename = basename $filename;
          $sub = "global $filename line $line";
      }
      #printf "${prefix_newline}debug: %s => %s\n", $sub, $debug_msg;
      printf "debug: %s => %s\n", $sub, $debug_msg;
  }
  
  
  sub defined_main_ua(){
      unless(defined($main::ua)){
          code_error "LWP useragent \$ua not defined (or inaccessibly defined with my instead of our), must import to main before calling curl(), do either \"use LWP::Simple '\$ua'\" or \"use LWP::UserAgent; our \$ua = LWP::UserAgent->new\"";
      }
  }
  
  
  sub escape_regex ($) {
      my $regex = shift;
      defined($regex) or code_error "no regex arg passed to escape_regex() subroutine";
      #$regex =~ s/([^\w\s\r\n])/\\$1/g;
      # backslashes everything that isn't /[A-Za-z_0-9]/
      $regex = quotemeta($regex); # $regex = \Q$regex\E;
      return $regex;
  }
  
  
  sub expand_units ($;$$) {
      my $num   = shift;
      my $units = shift;
      my $name  = shift;
      my $power;
      defined($num)   || code_error "no num arg 1 passed to expand_units()";
      if((!defined($units)) and $num =~ /^(\d+(?:\.\d+)?)([A-Za-z]{1,2})$/){
          $num   = $1;
          $units = $2;
      }
      defined($units) || code_error "no units arg 2 passed to expand_units()";
      isFloat($num)   || code_error "non-float num arg 1 passed to expand_units()";
      if   ($units =~ /^B?$/i) { return $num; }
      elsif($units =~ /^KB?$/i){ $power = 1; }
      elsif($units =~ /^MB?$/i){ $power = 2; }
      elsif($units =~ /^GB?$/i){ $power = 3; }
      elsif($units =~ /^TB?$/i){ $power = 4; }
      elsif($units =~ /^PB?$/i){ $power = 5; }
      else { code_error "unrecognized units '$units' " . ($name ? "for $name " : "") . "passed to expand_units(). $nagios_plugins_support_msg"; }
      return $num * (1024**$power);
  }
  
  my %stats;
  
  # To check prototype before calling recursively
  sub processStat($$);
  sub processStat($$){
      my $name = shift;
      my $var  = shift;
      vlog3("processing $name");
      if(isArray($var)){
          if(scalar @{$var} > 0){
              foreach(my $i=0; $i < scalar @{$var}; $i++){
                  processStat("$name.$i", $$var[$i]);
              }
          } else {
              processStat("$name.0", "");
          }
      } elsif(isHash($var)){
          if(scalar keys %{$var} and defined($$var{"value"})){
              processStat($name, $$var{"value"});
              #vlog2 "$name='$$var{value}'";
              #$stats{$name} = $$var{"value"};
          } else {
              foreach my $key (keys %{$var}){
                  processStat("$name.$key", $$var{$key});
              }
          }
      } else {
          return if $name =~ /\.version$/;
          isFloat($var) or return;
          vlog2("$name='$var'");
          $stats{$name} = $var;
      }
  }
  
  sub flattenStats($){
      my $hashref = shift;
      isHash($hashref) or code_error "invalid arg passed to flattenStats, not a hashref!";
      foreach my $stat (sort keys %{$hashref}){
          processStat($stat, $hashref->{$stat});
      }
      return %stats;
  }
  
  
  sub get_field($;$){
      get_field2($json, $_[0], $_[1]);
  }
  
  sub get_field_array($;$){
      get_field2_array($json, $_[0], $_[1]);
  }
  
  sub get_field_float($;$){
      get_field2_float($json, $_[0], $_[1]);
  }
  
  sub get_field_hash($;$){
      get_field2_hash($json, $_[0], $_[1]);
  }
  
  sub get_field_int($;$){
      get_field2_int($json, $_[0], $_[1]);
  }
  
  sub get_field2($$;$){
      my $hash_ref  = shift;
      my $field     = shift || code_error "field not passed to get_field2()";
      my $noquit    = shift;
      isHash($hash_ref) or code_error "non-hash ref passed to get_field2()";
      # negative lookbehind allows for escaping dot in the field name
      my @parts     = split(/(?<!\\)\./, $field);
      $field =~ s/\\\././g;
      if(scalar(@parts) > 1){
          my $ref = $hash_ref;
          foreach(@parts){
              s/\\\././g;
              # XXX: this returns field not found where field exists but value is 'undef'
              if(isHash($ref) and defined($ref->{$_})){
                  $ref = $ref->{$_};
              } elsif(isArray($ref) and $_ =~ /^(\d+)$/){
                  if(defined(${$ref}[$1])){
                      $ref = ${$ref}[$1];
                  } else {
                      quit "UNKNOWN", "array has no $1 item for field '$field'. $nagios_plugins_support_msg_api" unless $noquit;
                      $ref = undef;
                      last;
                  }
              } else {
                  quit "UNKNOWN", "'$field' '$_' field not found. $nagios_plugins_support_msg_api" unless $noquit;
                  $ref = undef;
                  last;
              }
          }
          return $ref;
      } else {
          # XXX: this returns field not found where field exists but value is 'undef'
          if(defined($hash_ref->{$field})){
              return $hash_ref->{$field};
          } else {
              quit "UNKNOWN", "'$field' field not found. $nagios_plugins_support_msg_api" unless $noquit;
              return;
          }
      }
      code_error "hit end of get_field2 sub";
  }
  
  sub get_field2_array($$;$){
      my $hash_ref = shift;
      my $field    = shift;
      my $noquit   = shift;
      my $value = get_field2($hash_ref, $field, $noquit);
      if($noquit){
          return unless $value;
          return unless isArray($value);
      }
      assert_array($value, $field);
      return @{$value};
  }
  
  sub get_field2_float($$;$){
      my $hash_ref = shift;
      my $field    = shift;
      my $noquit   = shift;
      my $value = get_field2($hash_ref, $field, $noquit);
      if($noquit){
          return unless defined($value);
          return unless isFloat($value);
      }
      assert_float($value, $field);
      return $value;
  }
  
  sub get_field2_hash($$;$){
      my $hash_ref = shift;
      my $field    = shift;
      my $noquit   = shift;
      my $value = get_field2($hash_ref, $field, $noquit);
      if($noquit){
          return unless $value;
          return unless isHash($value);
      }
      assert_hash($value, $field);
      if($value){
          return %{$value};
      } else {
          return {};
      }
  }
  
  sub get_field2_int($$;$){
      my $hash_ref = shift;
      my $field    = shift;
      my $noquit   = shift;
      my $value = get_field2($hash_ref, $field, $noquit);
      if($noquit){
          return unless defined($value);
          return unless isInt($value);
      }
      assert_int($value, $field);
      return $value;
  }
  
  # get a field from a flattened hash
  #sub get_field3($$;$){
  #    my $hash_ref  = shift;
  #    my $field     = shift || code_error "field not passed to get_field3()";
  #    my $noquit    = shift;
  #    isHash($hash_ref) or code_error "non-hash ref passed to get_field3()";
  #    # XXX: this returns field not found where field exists but value is 'undef'
  #    if(defined($hash_ref->{$field})){
  #        return $hash_ref->{$field};
  #    } else {
  #        quit "UNKNOWN", "'$field' field not found. $nagios_plugins_support_msg_api" unless $noquit;
  #        return;
  #    }
  #    code_error "hit end of get_field3 sub";
  #}
  
  
  sub get_options {
      my %options3;
      #@default_options{ keys %options } = values %options;
      foreach my $default_option (keys %default_options){
          # Check that the %options given don't clash with any existing or in-built options
          foreach my $option (keys %options){
              foreach my $switch (split(/\s*\|\s*/, $option)){
                  if(grep({$_ eq $switch} split(/\s*\|\s*/, $default_option))){
                      code_error("Key clash on switch '$switch' with in-built option '$default_option' vs provided option '$option'");
                  }
              }
          }
          $options{$default_option} = $default_options{$default_option}; #unless exists $options{$default_option}; # check above is stronger
      }
      foreach(keys %options){
          unless (isArray($options{$_})){
              code_error("invalid value for %options key '$_', should be an array not " . lc ref($options{$_}) );
          }
          $options3{$_} = $options{$_}[0];
      }
      my %option_count;
      foreach my $option (keys %options3){
          foreach my $switch (split(/\s*\|\s*/, $option)){
              $option_count{$switch}++;
          }
      }
      foreach(keys %option_count){
          $option_count{$_} > 1 and code_error("Duplicate option key detected '$_'");
      }
      GetOptions(%options3) or usage();
      # TODO: finish this debug code
  #    if($debug){
  #        foreach(sort keys %options3){
  #            if(defined($options3{$_}[0])){
  #                debug("var $options3{$_}[0] = $options3{$_}[0]");
  #            }
  #        }
  #    }
  
      defined($help) and usage();
      defined($version) and version();
  
      if(defined($ENV{"DEBUG"}) and $ENV{"DEBUG"}){
          $debug = 1;
      }
      if($debug){
          $verbose = 3;
      }
  
      if(defined($ENV{'VERBOSE'})){
          if(isInt($ENV{'VERBOSE'})){
              my $env_verbose = int($ENV{'VERBOSE'});
              if($env_verbose > $verbose){
                  $verbose = $env_verbose;
                  vlog3("environment variable \$VERBOSE = '$env_verbose', increasing verbosity");
              }
          } else {
              warn "environment variable \$VERBOSE is not an integer ('$ENV{VERBOSE}')";
          }
      }
  
      verbose_mode();
      #vlog2("options:\n");
      # validation is done on an option by option basis
  
      if(defined($ENV{'TIMEOUT'})){
          if(isInt($ENV{'TIMEOUT'})){
              if(not defined($timeout)){
                  vlog3("environment variable \$TIMEOUT = '$ENV{TIMEOUT}' and timeout not already set, setting timeout = $ENV{TIMEOUT}");
                  $timeout = int($ENV{'TIMEOUT'});
              }
          } else {
              warn "\$TIMEOUT environment variable is not an integer ('$ENV{TIMEOUT}')";
          }
      }
      if(not defined($timeout)){
          $timeout = $timeout_default;
      }
  
      1;
  }
  
  
  sub get_path_owner ($) {
      # defined($_[0]) || code_error "no path passed to get_path_owner()";
      my $path = shift;
      open my $fh, $path || return;
      my @stats = stat($fh);
      close $fh;
      defined($stats[4]) || return;
      return getpwuid($stats[4]) || 0;
  }
  
  sub get_upper_threshold ($) {
      my $type = shift;
      if($type eq "warning" or $type eq "critical"){
          if(defined($thresholds{$type}{"upper"})){
              return $thresholds{$type}{"upper"};
          } else {
              return "";
          }
      }
      code_error "invalid threshold type '$type' passed to get_upper_threshold(), must be one of: warning critical";
  }
  
  sub get_upper_thresholds () {
      return get_upper_threshold("warning") . ";" . get_upper_threshold("critical");
  }
  
  # go flock ur $self ;)
  sub go_flock_yourself (;$$) {
      my $there_can_be_only_one = shift;
      my $wait = shift;
      my $locking_options;
      if($wait){
          vlog2("waiting to go flock myself");
          $locking_options = LOCK_EX;
      } else {
          $locking_options = LOCK_EX|LOCK_NB;
      }
      if($there_can_be_only_one){
          open  *{0} or die "Failed to open *{0} for lock: $!\n";
          flock *{0}, $locking_options or die "Failed to acquire global lock, related code is already running somewhere!\n";
      } else {
          open $selflock, $0 or die "Failed to open $0 for lock: $!\n";
          flock $selflock, $locking_options or die "Another instance of " . abs_path($0) . " is already running!\n";
      }
      vlog2("truly flocked now");
      1;
  }
  
  sub flock_off (;$) {
      my $there_can_be_only_one = shift;
      if($there_can_be_only_one){
          open  *{0} or die "Failed to open *{0} for lock: $!\n";
          flock *{0}, LOCK_UN;
      } else {
          open $selflock, $0 or die "Failed to open $0 for lock: $!\n";
          flock $selflock, LOCK_UN;
      }
  }
  
  
  sub hr() {
      print "# " . "="x76 . " #\n";
  }
  
  
  sub human_units ($;$$) {
      my $num   = shift;
      my $units = shift;
      my $terse = shift;
      if($units){
          $num = expand_units($num, $units);
      }
      defined($num) or code_error "no arg passed to human_units()";
      isFloat($num) or isScientific($num) or code_error "non-float passed to human_units()";
      if(     $num >= (1024**7)){
          code_error "determine suspicious units for number $num, larger than Exabytes??!!";
      } elsif($num >= (1024**6)){
          $num = sprintf("%.2f", $num / (1024**6));
          $units = "EB";
      } elsif($num >= (1024**5)){
          $num = sprintf("%.2f", $num / (1024**5));
          $units = "PB";
      } elsif($num >= (1024**4)){
          $num = sprintf("%.2f", $num / (1024**4));
          $units = "TB";
      } elsif($num >= (1024**3)){
          $num = sprintf("%.2f", $num / (1024**3));
          $units = "GB";
      } elsif($num >= (1024**2)){
          $num = sprintf("%.2f", $num / (1024**2));
          $units = "MB";
      } elsif($num >= (1024**1)){
          $num = sprintf("%.2f", $num / (1024**1));
          $units = "KB";
      } elsif($num < 1024){
          if($terse){
              return "${num}B";
          } else {
              return "$num bytes";
          }
      } else {
          code_error "unable to determine units for number $num";
      }
      return trim_float($num) . $units;
  }
  
  
  sub inArray ($@) {
      my $item  = shift;
      my @array = @_;
      my $found = 0;
      foreach(@array){
          #vlog("checking $item against $_");
          if($item eq $_){
              $found++;
          }
      }
      return $found;
  }
  
  
  sub isAlNum ($) {
      my $arg = shift;
      defined($arg) or return; #code_error("no arg passed to isAlNum()");
      $arg =~ /^([A-Za-z0-9]+)$/ or return;
      return $1;
  }
  
  
  sub isArray ($) {
      my $isArray;
      if(defined($_[0])){
          $isArray = ref $_[0] eq "ARRAY";
      }
      if($_[1]){
          unless($isArray){
              code_error "non array reference passed to isArray()";
          }
      }
      return $isArray;
  }
  
  
  sub isAwsAccessKey($){
      my $aws_access_key = shift;
      defined($aws_access_key) or return;
      $aws_access_key =~ /^($aws_access_key_regex)$/ or return;
      return $1;
  }
  
  sub isAwsHostname($){
      my $aws_hostname = shift;
      defined($aws_hostname) or return;
      $aws_hostname =~ /^($aws_hostname_regex)$/ or return;
      return $1;
  }
  
  sub isAwsFqdn($){
      my $aws_fqdn = shift;
      defined($aws_fqdn) or return;
      $aws_fqdn =~ /^($aws_fqdn_regex)$/ or return;
      return $1;
  }
  
  sub isAwsSecretKey($){
      my $aws_secret_key = shift;
      defined($aws_secret_key) or return;
      $aws_secret_key =~ /^($aws_secret_key_regex)$/ or return;
      return $1;
  }
  
  
  sub isChars($$){
      my $string = shift;
      my $chars  = shift;
      defined($string) or return;
      defined($chars) or code_error "no chars passed to isChars";
      $chars = isRegex("[$chars]") or code_error "invalid regex char range passed to isChars()";
      $string =~ /^($chars+)$/ or return;
      return $1;
  }
  
  # isSub/isCode is used by set_timeout() to determine if we were passed a valid function for the ALRM sub
  sub isCode ($) {
      my $isCode = ref $_[0] eq "CODE";
      return $isCode;
  }
  
  sub isCollection($){
      my $collection = shift;
      defined($collection) or return;
      $collection =~ /^(\w(?:[\w\.]*\w)?)$/  or return;
      $collection = $1;
      return $collection;
  }
  
  #sub isDigit {
  #    isInt(@_);
  #}
  *isDigit = \&isInt;
  
  
  sub isDatabaseName ($) {
      my $database = shift;
      defined($database) || return;
      $database =~ /^(\w+)$/ or return;
      $database = $1;
      return $database;
  }
  
  
  sub isDatabaseColumnName ($) {
      my $column = shift;
      defined($column) || return;
      $column =~ /^($column_regex)$/ or return;
      $column = $1;
      return $column;
  }
  
  
  sub isDatabaseFieldName ($) {
      my $field = shift;
      defined($field) || return;
      ( $field  =~ /^(\d+)$/ or $field =~/^([A-Za-z][\w()*,._-]+[A-Za-z0-9)])$/ ) or return;
      return $1;
  }
  
  
  sub isDatabaseTableName ($;$) {
      my $table           = shift;
      my $allow_qualified = shift;
      defined($table) || return;
      if($allow_qualified){
          $table =~ /^([A-Za-z0-9][\w\.]*[A-Za-z0-9])$/i or return;
          return $1;
      } else {
          $table =~ /^([A-Za-z0-9]\w*[A-Za-z0-9])$/i or return;
          return $1;
      }
      return;
  }
  *isDatabaseViewName = \&isDatabaseTableName;
  
  
  sub isDomain ($) {
      my $domain = shift;
      defined($domain) or return;
      return if(length($domain) > 255);
      $domain =~ /^($domain_regex)$/ or return;
      return $1;
  }
  
  sub isDomainStrict ($) {
      my $domain = shift;
      defined($domain) or return;
      return if(length($domain) > 255);
      $domain =~ /^($domain_regex2)$/ or return;
      return $1;
  }
  *isDomain2 = \&isDomainStrict;
  
  sub isDnsShortname($){
      my $name = shift;
      defined($name) or return;
      return if(length($name) < 3 or length($name) > 63);
      $name =~ /^($hostname_component)$/ or return;
      return $1;
  }
  
  
  # SECURITY NOTE: this only checks if the email address is valid, it's doesn't make it safe to arbitrarily pass to commands or SQL etc!
  sub isEmail ($) {
      my $email = shift;
      defined($email) or return;
      return if(length($email) > 256);
      $email =~ /^$email_regex$/ || return;
      # Intentionally not untainting this as it's not safe given the addition of ' to the $email_regex to support Irish email addresses
      return $email;
  }
  
  
  sub isFilename($){
      my $filename = shift;
      return unless defined($filename);
      return if $filename =~ /^\s*$/;
      return if $filename =~ /\/$/;
      return unless($filename =~ /^($filename_regex)$/);
      return $1;
  }
  
  sub isDirname($){
      my $dirname = shift;
      return unless defined($dirname);
      return if $dirname =~ /^\s*$/;
      return unless($dirname =~ /^($dirname_regex)$/);
      return $1;
  }
  
  
  sub isFloat ($;$) {
      my $number = shift;
      my $negative = shift() ? "-?" : "";
      defined($number) or return;
      $number =~ /^$negative\d+(?:\.\d+)?$/;
  }
  
  
  sub isFqdn ($) {
      my $fqdn = shift;
      defined($fqdn) or return;
      return if(length($fqdn) > 255);
      $fqdn =~ /^($fqdn_regex)$/ or return;
      return $1;
  }
  
  
  sub isHash ($) {
      my $isHash;
      if(defined($_[0])){
          $isHash = ref $_[0] eq "HASH";
      }
      if($_[1]){
          unless($isHash){
              code_error "non hash reference passed";
          }
      }
      return $isHash;
  }
  
  
  sub isHex ($) {
      my $hex = shift;
      defined($hex) or return;
      $hex =~ /^((?:0x)?[A-Fa-f\d]+)$/ or return;
      return 1;
  }
  
  
  sub isHost ($) {
      my $host = shift;
      defined($host) or return;
      # special case to short-circuit failure when chaining find_active_server.py
      if($host eq "NO_SERVER_AVAILABLE" or $host eq "NO_HOST_AVAILABLE"){
          return;
      }
      # at casual glance this looks like it's duplicating isHostname but it's using a different unified regex of isHostname + isIP
      if(length($host) > 255){ # Can't be a hostname
          return;
      } elsif($host =~ /^($host_regex)$/){
          $host = $1;
          return $host;
      }
      return;
  }
  
  
  sub isHostname ($) {
      my $hostname = shift;
      defined($hostname) or return;
      # special case to short-circuit failure when chaining find_active_server.py
      if($hostname eq "NO_SERVER_AVAILABLE" or $hostname eq "NO_HOST_AVAILABLE"){
          return;
      }
      return if(length($hostname) > 255);
      $hostname =~ /^($hostname_regex)$/ or return;
      return $1;
  }
  
  
  sub isInt ($;$) {
      my $number = shift;
      my $signed = shift() ? "-?" : "";
      defined($number) or return; # code_error("no number passed to isInt()");
      $number =~ /^($signed\d+)$/;
  }
  
  
  sub isInterface ($) {
      my $interface = shift;
      defined($interface) || return;
      # TODO: consider checking if the interface actually exists on the system
      $interface =~ /^((?:em|eth|bond|lo|docker)\d+|lo|veth[A-Fa-f0-9]+)$/ or return;
      return $1;
  }
  
  
  sub isIP ($) {
      my $ip = shift;
      defined($ip) or return;
      $ip =~ /^($ip_regex)$/ or return;
      $ip = $1;
      my @octets = split(/\./, $ip);
      (@octets == 4) or return;
      foreach(@octets){
          $_ < 0   and return;
          $_ > 255 and return;
      }
      # not disallowing 0 or 255 in final octet any more due to CIDR
      #$octets[3] eq 0  and return;
      #$octets[3] > 254 and return;
      return $ip;
  }
  
  
  sub isJavaBean ($) {
      my $string = shift;
      $string =~ /^([A-Za-z][A-Za-z0-9.,:=_-]+[A-Za-z0-9])$/ or return undef;
      return $1;
  }
  
  
  sub isJavaException ($) {
      my $string = shift;
      if($string =~ /(?:^\s+at|^Caused by:)\s+\w+(?:\.\w+)+/){
          #debug "skipping java exception \\s+at|^Caused by => '$string'";
          return 1;
      } elsif($string =~ /\(.+:[\w-]+\(\d+\)\)/){
          #debug "skipping java exception (regex):\\w(\\d+) => '$string'";
          return 1;
      } elsif($string =~ /(\b|_).+\.\w+Exception:/){
          #debug "skipping java exception regex\\.\\w+Exception: => '$string'";
          return 1;
      } elsif($string =~ /^(?:\w+\.)*\w+Exception:/){
          #debug "skipping java exception (?:\\w+\\.)*\\w+Exception: => '$string'";
          return 1;
      } elsif($string =~ /\$\w+\(\w+:\d+\)/){
          #debug "skipping java exception \$\\w+(regex) => '$string'";
          return 1;
      #} elsif($string =~ /\s\w+\s\[[\w-]+\]\s[A-Z][a-z]+(?:[A-Z][a-z]+)+:\d+\s/){
          #debug "skipping java exception \\w+\\s\\[[\\w-]+\\]\\s[A-Z][a-z]+(?:[A-Z][a-z]+)+:\\d+\\s => '$string'";
          #return 1;
      }
      return;
  }
  
  # wish there was a better way of validating the JSON returned but Test::JSON is_valid_json() also errored out badly from underlying JSON::Any module, similar to JSON's decode_json
  #sub isJson($){
  #    my $data = shift;
  #    defined($data) or return;
  #    # slightly modified from http://stackoverflow.com/questions/2583472/regex-to-validate-json
  #    # XXX: Unfortunately this only work on RHEL6's version of Perl and parse failure breaks all dependent code on RHEL5 now
  ##    my $json_regex = qr/
  ##      (?(DEFINE)
  ##         (?<number>   -? (?= [1-9]|0(?!\d) ) \d+ (\.\d+)? ([eE] [+-]? \d+)? )
  ##         (?<boolean>   true | false | null )
  ##         (?<string>    " ([^"\\\\]* | \\\\ ["\\\\bfnrt\/] | \\\\ u [0-9a-f]{4} )* " )
  ##         (?<array>     \[  (?: (?&json)  (?: , (?&json)  )*  )?  \s* \] )
  ##         (?<pair>      \s* (?&string) \s* : (?&json)  )
  ##         (?<object>    \{  (?: (?&pair)  (?: , (?&pair)  )*  )?  \s* \} )
  ##         (?<json>      \s* (?: (?&number) | (?&boolean) | (?&string) | (?&array) | (?&object) ) \s* )
  ##      )
  ##      \A (?&json) \Z
  ##      /six;
  #    # TODO: reinvestigate if this can be made to work
  ##    my $json;
  ##    my $number  = qr/(-? (?= [1-9]|0(?!\d) ) \d+ (\.\d+)? ([eE] [+-]? \d+)?)/six;
  ##    my $boolean = qr/(true | false | null)/six;
  ##    my $string  = qr/(" ([^"\\\\]* | \\\\ ["\\\\bfnrt\/] | \\\\ u [0-9a-f]{4} )* ")/six;
  ##    my $array   = qr/(\[  (?: (&$json)  (?: , (&$json)  )*  )?  \s* \])/six;
  ##    my $pair    = qr/\s* ($string) \s* : ($json)/six;
  ##    my $object  = qr/(\{  (?: ($pair)  (?: , ($pair)  )*  )?  \s* \})/six;
  ##    $json    = qr/(\s* (?: ($number) | ($boolean) | ($string) | ($array) | ($object) ) \s*)/six;
  ##    my $json_regex = qr/\A ($json) \Z/six;
  #    #if($data =~ $json_regex){
  #    #    return 1;
  #    #}
  #    return 0;
  #}
  
  sub isJson($){
      my $string = shift;
      defined($string) or return;
      my $json = undef;
      try {
          $json = decode_json($string);
      };
      return $json;
  }
  
  
  sub isXml($){
      require XML::Simple;
      import XML::Simple;
      my $string = shift;
      defined($string) or return;
      my $xml = undef;
      try {
          $xml = XMLin($string, forcearray => 1, keyattr => []);
      };
      return $xml;
  }
  
  
  sub isKrb5Princ ($) {
      my $principal = shift;
      defined($principal) or return;
      $principal =~ /^($krb5_principal_regex)$/ or return;
      return $1;
  }
  
  
  # Primarily for Nagios perfdata labels
  sub isLabel ($) {
      my $label = shift;
      defined($label) or return;
      $label =~ /^$label_regex$/ or return;
      return $label;
  }
  
  
  sub isLdapDn ($) {
      #subtrace(@_);
      my $dn = shift;
      defined($dn) or return;
      $dn =~ /^($ldap_dn_regex)$/ || return;
      return $1;
  }
  
  
  sub isMinVersion ($$) {
      my $version = shift;
      my $min     = shift;
      if(not isVersionLax($version)){
          warn(sprintf("'%s' is not a recognized version format", $version));
          return;
      }
      isFloat($min) or code_error("invalid second arg passed to min_version");
      if($version =~ /(\d+(?:\.\d+)?)/){
          my $detected_version = $1;
          if($detected_version >= $min){
              return $detected_version;
          }
      }
      return;
  }
  
  
  sub isNagiosUnit ($) {
      my $units = shift;
      defined($units) or return;
      foreach(@valid_units){
          if(lc $units eq lc $_){
              return $_;
          }
      }
      return;
  }
  
  
  sub isNoSqlKey ($) {
      my $key = shift;
      defined($key) or return;
      $key =~ /^([\w\_\,\.\:\+\-]+)$/ or return;
      $key = $1;
      return $key;
  }
  
  
  sub isObject ($) {
      my $object = shift;
      return blessed($object);
  }
  
  
  sub isPathQualified($){
      my $path = shift;
      $path =~ /^(?:\.?\/)/;
  }
  
  
  sub isPort ($) {
      my $port = shift;
      defined($port) or return;
      $port  =~ /^(\d+)$/ || return;
      $port = $1;
      ($port >= 1 && $port <= 65535) || return;
      return $port;
  }
  
  
  sub isProcessName ($) {
      my $process = shift;
      defined($process) or return;
      $process =~ /^($process_name_regex)$/ or return;
      return $1;
  }
  
  
  sub isPythonTraceback ($) {
      my $string = shift;
      if($string =~ /\bFile "$filename_regex", line \d+, in (?:<module>|[A-Za-z]+)/){
          #debug "skipping python traceback 'File "...", line \\d+, in ...';
          return 1;
      }
      if($string =~ /\bTraceback \(most recent call last\):/){
          #debug "skipping python traceback 'Traceback \(most recent call last\)'";
          return 1;
      }
      return;
  }
  
  # XXX: doesn't catch error before Perl errors out, only using for late loading of regex from files, not in validate_regex()
  sub isRegex ($) {
      my $regex = shift;
      defined($regex) || code_error "no regex arg passed to isRegex()";
      #defined($regex) || return;
      #vlog3("testing regex '$regex'");
      if(eval { qr/$regex/ }){
          return $regex;
      } else {
          return;
      }
  }
  
  
  sub isRef ($;$) {
      my $isRef = ref $_[0] eq "REF";
      if($_[1]){
          unless($isRef){
              code_error "non REF reference passed";
          }
      }
      return $isRef;
  }
  
  
  sub isScalar ($;$) {
      my $arg  = shift;
      my $quit = shift;
      my $ref = ref $arg;
      my $isScalar = 0;
      # needs more testing and thought before I can enable this
      #if(not $ref or $ref eq "SCALAR" or $ref eq "JSON::PP::Boolean"){
      if($ref eq "SCALAR"){
          $isScalar = 1;
      }
      if($quit and !$isScalar){
          code_error "non scalar reference passed";
      }
      return $isScalar;
  }
  
  
  sub isScientific($;$){
      my $num      = shift;
      my $negative = shift() ? "-?" : "";
      defined($num) or code_error "no arg passed to isScientific()";
      $num =~ /^$negative\d+(?:\.\d+)?e[+-]?\d+$/i or return;
      return $num;
  }
  
  
  #sub isSub {
  #    isCode(@_);
  #}
  *isSub = \&isCode;
  
  
  sub isThreshold($){
      my $threshold = shift;
      defined($threshold) or code_error "threshold arg to isThreshold() not defined";
      if($threshold =~ $threshold_range_regex){
          return 1;
      } elsif($threshold =~ $threshold_simple_regex){
          return 1;
      }
      return 0;
  }
  
  
  sub isUrl ($) {
      my $url = shift;
      defined($url) or return;
      #debug("url_regex: $url_regex");
      $url = trim($url);
      $url = "http://$url" unless $url =~ /:\/\//i;
      $url =~ /^($url_regex)$/ or return;
      return $1;
  }
  
  
  sub isUrlPathSuffix ($) {
      my $url = shift;
      defined($url) or return;
      $url =~ /^($url_path_suffix_regex)$/ or return;
      return $1;
  }
  
  
  sub isUser ($) {
      #subtrace(@_);
      my $user = shift;
      defined($user) or return; # code_error "user arg not passed to isUser()";
      $user =~ /^($user_regex)$/ || return;
      return $1;
  }
  
  
  sub isVersion($){
      my $version = shift;
      defined($version) or return;
      $version =~ /^($version_regex)$/ || return;
      return $1;
  }
  
  sub isVersionLax($){
      my $version = shift;
      defined($version) or return;
      # would use version_regex_lax but need to capture and don't want to force capture in the regex as that can mess with client code captures
      $version =~ /^($version_regex)-?.*$/ || return;
      return $1;
  }
  
  # =============================== OS CHECKS ================================== #
  sub isOS ($) {
      $^O eq shift;
  }
  
  sub isMac () {
      isOS "darwin";
  }
  
  sub isLinux () {
      isOS "linux";
  }
  
  sub isLinuxOrMac () {
      isLinux() or isMac();
  }
  
  our $supported_os_msg = "this program is only supported on %s at this time";
  sub mac_only () {
      isMac or quit("UNKNOWN", sprintf($supported_os_msg, "Mac/Darwin") );
  }
  
  sub linux_only () {
      isLinux or quit("UNKNOWN", sprintf($supported_os_msg, "Linux") );
  }
  
  sub linux_mac_only () {
      isLinuxOrMac or quit("UNKNOWN", sprintf($supported_os_msg, "Linux or Mac/Darwin") );
  }
  # ============================================================================ #
  
  
  sub loginit () {
      # This can cause plugins to fail if there is no connection to syslog available at plugin INIT
      # Let's only use this for something that really needs it
      #INIT {
          #require Sys::Syslog;
          #import Sys::Syslog qw(:standard :macros);
          # Can't actually require/import optimize here because barewards aren't recognized early enough which breaks strict
          use Sys::Syslog qw(:standard :macros);
          # nofatal doesn't appear in earlier 5.x versions
          #openlog $progname, "ndelay,nofatal,nowait,perror,pid", LOG_LOCAL0;
          openlog $progname, "ndelay,nowait,perror,pid", LOG_LOCAL0;
          $syslog_initialized = 1;
      #}
  }
  
  
  sub log (@) {
      loginit() unless $syslog_initialized;
      # For some reason perror doesn't seem to print so do it manually here
      print strftime("%F %T", localtime) . "  $progname\[$$\]: @_\n";
      syslog LOG_INFO, "%s", "@_";
  }
  
  
  sub logdie (@) {
      &log("ERROR: @_");
      exit get_status_code("CRITICAL");
  }
  
  
  sub lstrip ($) {
      my $string = shift;
      #defined($string) or code_error "no arg passed to lstrip()";
      $string =~ s/^\s+//o;
      return $string;
  }
  #sub ltrim { lstrip(@_) }
  *ltrim = \&lstrip;
  
  
  sub minimum_value ($$) {
      my $value = shift;
      my $min   = shift;
      isFloat($value) or code_error "invalid first arg passed to minimum_value(), must be float";
      isFloat($min)   or code_error "invalid second arg passed to minimum_value(), must be float";
      if($value < $min){
          return $min;
      }
      return $value;
  }
  
  
  sub msg_perf_thresholds (;$$$) {
      my $return = shift;
      my $type   = shift() ? "lower" : "upper";
      my $name   = shift() || "";
      $name .= " " if $name and $name !~ / $/;
      my $tmp = ";";
      $tmp .= $thresholds{"${name}warning"}{$type}  if defined($thresholds{"${name}warning"}{$type});
      $tmp .= ";";
      $tmp .= $thresholds{"${name}critical"}{$type} if defined($thresholds{"${name}critical"}{$type});
      $tmp .= ";";
      if(defined($return) and $return){
          return $tmp;
      } else {
          $msg .= $tmp;
      }
  }
  
  
  sub msg_thresholds (;$$) {
      my $no_msg_thresholds = shift || 0;
      my $name = shift() || "";
      my $msg2 = "";
      if (defined($thresholds{"${name}critical"}{"error"}) or
          defined($thresholds{"${name}warning"}{"error"})  or
              ($verbose and (
                              defined($thresholds{"${name}warning"}{"range"}) or
                              defined($thresholds{"${name}critical"}{"range"})
                            )
              )
          ) {
          $msg2 .= " (";
          if(defined($thresholds{"${name}critical"}{"error"})){
              $msg2 .= $thresholds{"${name}critical"}{"error"} . ", ";
          }
          elsif(defined($thresholds{"${name}warning"}{"error"})){
              $msg2 .= $thresholds{"${name}warning"}{"error"} . ", ";
          }
          if(defined($thresholds{"${name}warning"}{"range"})){
              $msg2 .= "w=" . $thresholds{"${name}warning"}{"range"};
          }
          if(defined($thresholds{"${name}warning"}{"range"}) and defined($thresholds{"${name}critical"}{"range"})){
              $msg2 .= "/";
          }
          if(defined($thresholds{"${name}critical"}{"range"})){
              $msg2 .= "c=" . $thresholds{"${name}critical"}{"range"};
          }
          $msg2 .= ")";
      }
      unless($no_msg_thresholds){
          $msg .= $msg2 if $msg2;
      }
      return $msg2;
  }
  
  
  sub month2int($){
      my $month = shift;
      defined($month) or code_error "no arg passed to month2int";
      my %months = (
          "Jan" => 0,
          "Feb" => 1,
          "Mar" => 2,
          "Apr" => 3,
          "May" => 4,
          "Jun" => 5,
          "Jul" => 6,
          "Aug" => 7,
          "Sep" => 8,
          "Oct" => 9,
          "Nov" => 10,
          "Dec" => 11
      );
      grep { $month eq $_ } keys %months or code_error "non-month passed to month2int()";
      return $months{$month};
  }
  
  
  sub open_file ($;$) {
      my $filename = shift;
      my $lock = shift;
      #my $mode = shift;
      my $tmpfh;
      defined($filename) or code_error "no filename given to open_file()";
      ( -e $filename ) or quit("CRITICAL", "file not found: '$filename'");
      ( -f $filename ) or quit("CRITICAL", "not a valid file: '$filename'");
      ( -r $filename ) or quit("CRITICAL", "file not readable: '$filename'");
      vlog2("opening file: '$filename'");
      open $tmpfh, "$filename" or quit("UNKNOWN", "Error: failed to open file '$filename': $!");
      if($lock){
          flock($tmpfh, LOCK_EX | LOCK_NB) or quit("UNKNOWN", "Failed to aquire a lock on file '$filename', another instance of this code may be running?");
      }
      return $tmpfh;
  }
  
  
  sub parse_file_option($;$){
      my $file      = shift;
      my $file_args = shift;
      my @files;
      my @tmp;
      if($file){
          my @tmp = split(/\s*[\s,]\s*/, $file);
          push(@files, @tmp);
      }
  
      if($file_args){
          # @ARGV should only be used after get_options()
          foreach(@ARGV){
              push(@files, $_);
          }
      }
  
      foreach my $f (@files){
          if(not -f $f ){
              print STDERR "File not found: '$f'\n";
              @files = grep { $_ ne $f } @files;
          }
      }
      if($file or ($file_args and @ARGV)){
          if(not @files){
              die "Error: no files found\n";
          }
      }
  
      vlog_option("files", "[ '" . join("', '", @files) . "' ]");
  
      return @files;
  }
  
  
  sub perf_suffix($){
      my $key = shift;
      my $prefix = '[\b\s\._-]';
      if($key =~ /${prefix}bytes$/){
          return "b";
      } elsif($key =~ /${prefix}millis$/){
          return "ms";
      }
      return "";
  }
  
  
  # parsing ps aux is more portable than pkill -f command. Useful for alarm sub
  # Be careful to validate and make sure you use taint mode before calling this sub
  sub pkill ($;$) {
      my $search    = $_[0] || code_error "No search arg specified for pkill sub";
      my $kill_args = $_[1] || "";
      $search =~ s/(\/)/\\$1/g;
      $search =~ s/'/./g;
      return `ps aux | awk '/$search/ {print \$2}' | while read pid; do kill $kill_args \$pid >/dev/null 2>&1; done`;
  }
  
  
  our $plural;
  sub plural ($) {
      my $var = $_[0];
      #print "var = $var\n";
      #print "var ref = " . ref($var) . "\n";
      if(isArray($var)){
          $var = scalar(@{$var});
      } elsif (isHash($var)){
          $var = scalar keys %{$var};
      # TODO: enable this, currently doesn't work
      #} elsif (not isFloat($var)) {
      #    code_error "non-scalar, non-array ref and non-hash ref passed to plural()";
      }
      isFloat($var) or code_error("arg passed to plural() is not a float");
      ( $var == 1 ) ? ( $plural = "" ) : ( $plural = "s" );
  }
  
  
  my ($wchar, $hchar, $wpixels, $hpixels);
  sub print_options (@) {
      check_terminal_size();
      #subtrace(@_);
      my $switch_width = $short_options_len + 2 + $long_options_len + 4 - 1;
      my $desc_width   = $wchar - $switch_width;
      foreach my $option (@_){
          my $option_regex = $option;
          $option_regex  =~ s/^\w\|//;
          $option_regex  =~ s/=.*$//;
          # pointless since this is hardcoded Perl interpreter will always error out first
          #$option_regex  = isRegex($option_regex) || code_error "invalid option regex '$option_regex' passed in \@options array to print_options()";
          #debug "\noption is $option";
          if($option =~ /debug/){
              #debug "skipping debug option";
              next;
          }
          foreach(keys %options){
              #debug $_;
              #debug $options{$_};
              #debug "options long value is $options{$_}{desc}";
              if($options{$_}{"long"} =~ /^.*--(?:$option_regex)\s*$/ or $options{$_}{"short"} =~ /^-(?:$option_regex)\s*$/){
                  # This format string must match the length of $switch_width at top of sub
                  printf STDERR "%-${short_options_len}s  %-${long_options_len}s    ", $options{$_}{"short"}, $options{$_}{"long"};
                  my $option_desc_len = length($options{$_}{"desc"});
                  for(my $start=0; $start < $option_desc_len; ){
                      my ($len, $end);
                      if($option_desc_len - $start < $desc_width){
                          $end = $option_desc_len;
                      } else {
                          my $space_index   = rindex($options{$_}{"desc"}, " ",  $start + $desc_width - 1);
                          if($space_index > $start){
                              $end = $space_index;
                          } else{
                              $space_index = index($options{$_}{"desc"}, " ", $start);
                              if($space_index > $start){
                                  $end = $space_index;
                              } else {
                                  $end = $option_desc_len;
                              }
                          }
                      }
                      $end > $start or $end = $option_desc_len;
                      $len = $end - $start;
                      if($start > 0){ # and $end <= $option_desc_len){
                          printf STDERR "%${switch_width}s", "";
                      }
                      printf STDERR "%s\n", substr($options{$_}{"desc"}, $start, $len);
                      $start = $end;
                  }
                  delete $options{$_};
                  last;
              }
          }
      }
      1;
  }
  
  sub prompt($){
      my $question = shift;
      print "\n$question ";
      my $response = <STDIN>;
      chomp $response;
      vlog();
      return $response;
  }
  
  sub isYes($;$$){
      my $val  = shift;
      my $name = shift() || "";
      my $noquit = shift;
      $name = " for $name";
      unless($val =~ /^\s*(?:y(?:es)?|n(?:o)?)?\s*$/i){
          die "invalid response$name, must be 'yes' or 'no'\n" unless $noquit;
      }
      if($val =~ /^\s*y(?:es)?\s*$/i){
          return 1;
      } else {
          return 0;
      }
  }
  
  # Also prototyped at top to allow me to call it earlier
  sub quit (@) {
      if($status_prefix ne ""){
          $status_prefix .= " ";
      }
      if(@_ eq 0){
          chomp $msg;
          # This ends up bit shifting to 255 instead of 0
          grep(/^$status$/, keys %ERRORS) or die "Code error: unrecognized exit code '$status' specified on quit call, not found in %ERRORS hash\n";
          # XXX: do not use die function, some modules call die without setting $? to something other than zero, causing an OK: prefix and zero exit code :-/
          #$? = $ERRORS{$status};
          #die "${status_prefix}$status: $msg\n";
          #die "$msg\n";
          print "${status_prefix}$status: $msg\n";
          exit $ERRORS{$status};
      } elsif(@_ eq 1){
          $msg = $_[0];
          chomp $msg;
          #$? = $ERRORS{"CRITICAL"};
          #die "${status_prefix}CRITICAL: $msg\n";
          #die "$msg\n";
          print "${status_prefix}CRITICAL: $msg\n";
          exit $ERRORS{"CRITICAL"};
      } elsif(@_ eq 2) {
          $status = $_[0];
          $msg    = $_[1];
          $msg or $msg = "msg not defined";
          chomp $msg;
          grep(/^$status$/, keys %ERRORS) or die "Code error: unrecognized exit code '$status' specified on quit call, not found in %ERRORS hash\n";
          #$? = $ERRORS{$status};
          #die "${status_prefix}$status: $msg\n";
          #die "$msg\n";
          print "${status_prefix}$status: $msg\n";
          exit $ERRORS{$status};
      } else {
          #print "UNKNOWN: Code Error - Invalid number of arguments passed to quit function (" . scalar(@_). ", should be 0 - 2)\n";
          #exit $ERRORS{"UNKNOWN"};
          code_error("invalid number of arguments passed to quit function (" . scalar(@_) . ", should be 0 - 2)");
      }
  }
  
  
  sub random_alnum($){
      my $length = shift;
      isInt($length) or code_error "invalid length passed to random_alnum";
      my @chars  = ("A".."Z", "a".."z", 0..9);
      my $string = "";
      $string .= $chars[rand @chars] for 1..$length;
      return $string;
  }
  
  
  sub remove_timeout(){
      delete $HariSekhonUtils::default_options{"t|timeout=i"};
  }
  
  
  sub resolve_ip ($) {
      require Socket;
      import Socket;
      my $ip;
      defined($_[0]) or return;
      # returns packed binary address
      $ip = inet_aton($_[0])  || return;
      # returns human readable x.x.x.x - only supporting IPv4 for now
      $ip = inet_ntoa($ip)    || return;
      # validate what we have is a correct IP address
      $ip = isIP($ip)         || return;
      return $ip;
  }
  
  
  sub rstrip ($) {
      my $string = shift;
      defined($string) or code_error "no arg passed to rstrip()";
      $string =~ s/\s+$//;
      return $string;
  }
  #sub rtrim { rstrip(@_) }
  *rtrim = \&rstrip;
  
  
  sub sec2min ($){
      my $secs = shift;
      isFloat($secs) or return;
      return sprintf("%d:%.2d", int($secs / 60), $secs % 60);
  }
  
  
  # Time::Seconds and Time::Piece are available from Perl v5.9.5 but CentOS 5 is v5.8
  sub sec2human ($){
      my $secs = shift;
      isFloat($secs) or code_error "invalid non-float argument passed to sec2human";
      my $human_time = "";
      if($secs >= 86400){
          my $days = int($secs / 86400);
          plural $days;
          $human_time .= sprintf("%d day$plural ", $days);
          $secs %= 86400;
      }
      if($secs >= 3600){
          my $hours = int($secs / 3600);
          plural $hours;
          $human_time .= sprintf("%d hour$plural ", $hours);
          $secs %= 3600;
      }
      if($secs >= 60){
          my $mins = int($secs / 60);
          plural $mins;
          $human_time .= sprintf("%d min$plural ", $mins);
          $secs %= 60;
      }
      plural $secs;
      $human_time .= sprintf("%d sec$plural", int($secs));
      return $human_time;
  }
  
  
  sub set_http_timeout($){
      my $http_timeout = shift;
      isFloat($http_timeout) or code_error "invalid arg passed to set_http_timeout(), must be float";
      defined_main_ua();
      $http_timeout = sprintf("%.2f", minimum_value($http_timeout, 1) );
      vlog2("setting http per request timeout to $http_timeout secs\n");
      $main::ua->timeout($http_timeout);
  }
  
  
  sub set_sudo (;$) {
      local $user = $_[0] if defined($_[0]);
      defined($user) or code_error "user arg not passed to set_sudo() and \$user not defined in outer scope";
      # Quit if we're not the right user to ensure we don't sudo command and hang or return with a generic timeout error message
      #quit "UNKNOWN", "not running as '$hadoop_user' user";
      # only Mac has -n switch for non-interactive :-/
      #$sudo = "sudo -n -u $hadoop_user ";
      if(getpwuid($>) eq $user){
          $sudo = "";
      } else {
          vlog2("EUID doesn't match user $user, using sudo\n");
          $sudo = "echo | sudo -S -u $user ";
      }
  }
  
  
  sub set_timeout (;$$) {
      $timeout    = $_[0] if $_[0];
      my $sub_ref;
      $sub_ref = $_[1] if $_[1];
      $timeout =~ /^\d+$/ || usage("timeout value must be a positive integer\n");
      ($timeout >= $timeout_min && $timeout <= $timeout_max) || usage("timeout value must be between $timeout_min - $timeout_max secs\n");
      if(defined($sub_ref)){
          isSub($sub_ref) or code_error "invalid sub ref passed to set_timeout()";
      }
  
      $SIG{ALRM} = sub {
          &$sub_ref if defined($sub_ref);
          quit("UNKNOWN", "self timed out after $timeout seconds" . ($timeout_current_action ? " while $timeout_current_action" : ""));
      };
      #verbose_mode() unless $_[1];
      vlog2("setting timeout to $timeout secs\n");
      # alarm returns the time of the last timer, on first run this is zero so cannot die here
      alarm($timeout) ;#or die "Failed to set time to $timeout";
  }
  
  
  #sub sub_noarg {
  #    quit "UNKNOWN", "Code Error: no arg supplied to subroutine " . (caller(1))[3];
  #}
  
  sub skip_java_output($){
      @_ or code_error "no input passed to skip_java_output()";
      my $str = join(" ", @_);
      # warning due to Oracle 7 JDK bug fixed in 7u60
      # objc[54213]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/bin/java and /Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/libinstrument.dylib. One of the two will be used. Which one is undefined.
      if($str =~ /Class JavaLaunchHelper is implemented in both|^SLF4J/){
          return 1;
      }
      return 0;
  }
  
  
  sub strBool($){
      my $str = shift;
      # " " returns true otherwise
      $str = strip($str);
      return "false" if $str =~ /false/i;
      ( $str ? "true" : "false" );
  }
  
  
  sub strip ($) {
      my $string = shift;
      defined($string) or code_error "no arg passed to strip()";
      $string =~ s/^\s+//o;
      $string =~ s/\s+$//o;
      return $string;
  }
  *trim = \&strip;
  
  
  sub strip_ansi_escape_codes ($) {
      my $string = shift;
      # will only strip color codes, but want to strip all ansi escape codes for use in anoymize.pl to avoid non-printing chars from breaking anonymizations
      ##$string = colorstrip($string);
      #$string =~ s/\x1b\[[0-9;]*m//gio;
      #$string =~ s/\x1b\[[0-9;]*[a-zA-Z]//gio;
      # ported from https://github.com/HariSekhon/pylib
      $string =~ s/(\x9B|\x1B\[)[0-?]*[ -\/]*[@-~]//gio;
      return $string;
  }
  
  
  sub subtrace (@) {
      #@_ || code_error("\@_ not passed to subtrace");
      return unless ($debug >= 2);
      my ( $package, $filename, $line ) = caller;
      my $debug_msg = "entering with args: @_";
      $debug_msg =~ s/^(\n+)//;
      my $prefix_newline = $1 || "";
      # TODO: can improve this if we can go one level up, dedupe with debug, do this later
      printf "${prefix_newline}debug: %s() => $debug_msg\n", (caller(1))[3];
  }
  
  
  sub timecomponents2days($$$$$$){
      my $year  = shift;
      my $month = shift;
      my $day   = shift;
      my $hour  = shift;
      my $min   = shift;
      my $sec   = shift;
      my $month_int;
      if(isInt($month)){
          $month_int = $month - 1;
      } else {
          $month_int = month2int($month);
      }
      my $epoch = timegm($sec, $min, $hour, $day, $month_int, $year - 1900) || code_error "failed to convert timestamp $year-$month-$day $hour:$min:$sec";
      my $now   = time || code_error "failed to get epoch timestamp";
      return ($epoch - $now) / (86400);
  }
  
  
  sub tstamp () {
      return strftime("%F %T %z  ", localtime);
  }
  
  sub tprint ($) {
      my $msg = shift;
      defined($msg) or code_error "tprint msg arg not defined";
      print tstamp() . "$msg\n";
  }
  
  
  sub trim_float ($) {
      my $num = shift;
      defined($num) or code_error "no arg passed to trim_float()";
      $num =~ s/\.0+$//;
      $num =~ s/\.([1-9]*)0+$/\.$1/;
      return $num;
  }
  
  
  #sub type {
  #    my $builtin = $_[0] || code_error "no arg supplied to which() subroutine";
  #    my $quit    = $_[1] || 0;
  #    $builtin =~ /^([\w-]+)$/ or quit "UNKNOWN", "invalid command/builtin passed to type subroutine";
  #    $builtin = $1;
  #   `type $builtin`;
  #    return 1 if($? == 0);
  #    quit "UNKNOWN", "$builtin is not a shell built-in" if $quit;
  #    return;
  #}
  
  
  sub sort_insensitive (@) {
      my @array = @_; # or code_error "no arg passed to sort_insensitive()";
      isArray(\@array) or code_error "sort_insensitive() was passed a non-array";
      scalar @array or code_error "sort_insensitive() was passed an empty array";
      return sort { "\L$a" cmp "\L$b" } @array;
  }
  
  
  sub uniq_array (@) {
      my @array = @_; # or code_error "no arg passed to uniq_array";
      isArray(\@array) or code_error "uniq_array was passed a non-array";
      scalar @array or code_error "uniq_array was passed an empty array";
      return sort keys %{{ map { $_ => 1 } @array }};
  }
  
  
  sub uniq_array2(@){
      my @array = @_; # or code_error "no arg passed to uniq_array";
      isArray(\@array) or code_error "uniq_array2 was passed a non-array";
      scalar @array or code_error "uniq_array2 was passed an empty array";
      my @array2;
      my $item;
      foreach $item (@array){
          grep { $item eq $_ } @array2 and next;
          push(@array2, $item);
      }
      return @array2;
  }
  *uniq_array_ordered = \&uniq_array2;
  
  sub get_terminal_size(){
      eval {
          local $SIG{__WARN__} = sub {};
          try {
              ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();
          };
          catch {
              ($wchar, $hchar) = (80, 25);
          }
      };
      check_terminal_size();
  }
  
  sub check_terminal_size(){
      unless(defined($wchar) and defined($hchar) and defined($wpixels) and defined($hpixels)){
          #warn "\nTerm::ReadKey GetTerminalSize() failed to return values! Ignore this warning if you are teeing to a logfile (otherwise your terminal is messed up...)\n\n\n";
          $wchar   = 99999999;
          $hchar   = 99999999;
          $wpixels = 99999999;
          $hpixels = 99999999;
      }
      # Travis gets suspiciously small width
      if($wchar < 80){
          $wchar = 80;
      }
      if($hchar < 25){
          $hchar = 25;
      }
      1;
  }
  
  sub usage (;@) {
      get_terminal_size();
      print STDERR "@_\n\n" if (@_);
      if(not @_ and $main::DESCRIPTION){
          print STDERR "Hari Sekhon - https://github.com/harisekhon";
          if($github_repo){
              print STDERR "/$github_repo";
          } elsif(dirname(abs_path(__FILE__)) =~ /nagios-plugins/i or $main::DESCRIPTION =~ /Nagios/i){
              print STDERR "/nagios-plugins";
          } elsif(dirname(abs_path(__FILE__)) =~ /tools/i){
              print STDERR "/devops-perl-tools";
          } elsif(dirname(abs_path(__FILE__)) =~ /lib/i){
              print STDERR "/lib";
          }
          print STDERR "\n\n$progname\n\n";
          #print STDERR "$main::DESCRIPTION\n\n";
          my $desc_len = length($main::DESCRIPTION);
          for(my $start=0; $start < $desc_len; ){
              #print "desc len $desc_len\n";
              #print "start $start\n";
              my ($len, $end);
              # reset the start to after newlines
              # the problem is that the start is taken across newlines
              if(($desc_len - $start) < $wchar){
                  $end = $desc_len;
              } else {
                  my $newline_index = rindex($main::DESCRIPTION, "\n", $start + $wchar - 1);
                  my $space_index   = rindex($main::DESCRIPTION, " ",  $start + $wchar - 1);
                  if($newline_index > $start){
                      #print "newline index $newline_index\n";
                      $end = $newline_index;
                  } elsif($space_index > $start){
                      $end = $space_index;
                  } else{
                      $newline_index = index($main::DESCRIPTION, "\n", $start);
                      if($newline_index > $start){
                          $end = $newline_index;
                      } else {
                          $end = $desc_len;
                      }
                  }
              }
              #print "end $end\n";
              $end > $start or $end = $desc_len;
              $len = $end - $start;
              #print "len $len\n";
              printf STDERR "%s\n", substr($main::DESCRIPTION, $start, $len);
              $start = $end + 1;
          }
          print STDERR "\n";
      }
      print STDERR "$usage_line\n\n";
      foreach my $key_orig (sort keys %options){
          my $key = $key_orig;
          $key =~ s/=.*$//;
          $key =~ s/\+//;
          code_error("invalid array count in value for key '$key' in options hash") unless(scalar(@{$options{$key_orig}}) == 2);
          $options{$key} = $options{$key_orig}[1];
          #debug "key: $key  key_orig: $key_orig";
          delete $options{$key_orig} if($key ne $key_orig);
      }
      foreach(sort keys %options){
          my $option = "";
          my @short_options = ();
          my @long_options  = ();
          if($_ =~ /\|/){
              @_ = split('\|', $_);
              foreach(@_){
                  if(length($_) == 1){
                      push(@short_options, "-$_");
                  } else {
                      push(@long_options, "--$_");
                  }
              }
          } else {
              if(length($_) == 1){
                  push(@short_options, "-$_");
              } else {
                  push(@long_options, "--$_");
              }
          }
          #debug "$_ short_options: " . join(",", @short_options) . "  long_options:" . join(",", @long_options) . "  desc: $options{$_}";
          $options{$_} = {
              "short" => join(" ", @short_options),
              "long"  => join(" ", @long_options),
              "desc"  => $options{$_}
          };
      }
  
      foreach(sort keys %options){
          $short_options_len = length($options{$_}{"short"}) if($short_options_len < length($options{$_}{"short"}));
          $long_options_len  = length($options{$_}{"long"} ) if($long_options_len  < length($options{$_}{"long"} ));
      }
      # First print options in the order specified in @usage_order
      print_options(@usage_order);
      # Now print any unspecified order options in alphabetical order
      foreach my $option (sort keys %options){
          #debug "iterating over general options $option";
          # TODO: improve this matching for more than one long opt
          my $option_regex = escape_regex($option);
          if(grep($_ =~ /\A$option_regex\Z/, keys %default_options)){
              #debug "skipping $option cos it matched \%default_options";
              next;
          }
          print_options($option);
          #printf "%-${short_options_len}s  %-${long_options_len}s \t%s\n", $options{$option}{"short"}, $options{$option}{"long"}, $options{$option}{"desc"};
      }
      # Finally print base common options, verbosity, timeout etc
      print_options(sort { lc($a) cmp lc($b) } keys %default_options);
      exit $ERRORS{"UNKNOWN"};
  }
  
  
  sub user_exists ($) {
      my $user = shift; # if $_[0];
      #defined($user) or code_error("no user passed to user_exists()");
      #$user = isUser($user) || return;
  
      # using id command since this should exist on most unix systems
      #which("id", 1);
      #`id "$user" >/dev/null 2>&1`;
      #return 1 if ( $? eq 0 );
      #return;
  
      # More efficient
      return defined(getpwnam($user));
  }
  
  
  sub validate_alnum($$){
      my $arg  = shift;
      my $name = shift || croak "second argument (name) not defined when calling validate_alnum()";
      defined($arg) or usage "$name not defined";
      $arg = isAlNum($arg);
      # isAlNum returns zero as valid and undef when not valid so must check explicitly for undef and avoid 0 which is false in Perl
      defined($arg) || usage "invalid $name defined: must be alphanumeric";
      vlog_option($name, $arg);
      return $arg;
  }
  
  
  sub validate_aws_access_key($){
      my $aws_access_key = shift;
      defined($aws_access_key) or usage "aws access key not defined";
      $aws_access_key = isAwsAccessKey($aws_access_key) || usage "invalid aws access key defined: must be 20 uppercase alphanumeric characters";
      vlog_option("aws access key", "X"x18 . substr($aws_access_key, 18, 2));
      return $aws_access_key;
  }
  
  
  sub validate_aws_bucket($){
      my $bucket = shift;
      defined($bucket) or usage "no aws bucket specified";
      $bucket = isDnsShortname($bucket) || usage "invalid aws bucket name defined: must be alphanumeric between 3 and 63 characters long";
      isIP($bucket) and usage "invalid aws bucket name defined: may not be formatted as an IP address";
      vlog_option("aws bucket", $bucket);
      return $bucket;
  }
  
  
  sub validate_aws_secret_key($){
      my $aws_secret_key = shift;
      defined($aws_secret_key) or usage "aws secret key not defined";
      $aws_secret_key = isAwsSecretKey($aws_secret_key) || usage "invalid aws secret key defined: must be 40 alphanumeric characters";
      vlog_option("aws secret key", "X"x38 . substr($aws_secret_key,38, 2));
      return $aws_secret_key;
  }
  
  
  # Takes a 3rd arg as a regex char range
  sub validate_chars($$$){
      my $string   = shift;
      my $name  = shift || croak "second argument (name) not defined when calling validate_chars()";
      my $chars = shift;
      defined($string) or usage "$name not defined";
      $string = isChars($string, $chars) || usage "invalid $name defined: must contain only the following chars - $chars";
      vlog_option($name, $string);
      return $string;
  }
  
  
  sub validate_collection ($;$) {
      my $collection = shift;
      my $name       = shift || "";
      $name .= " " if $name;
      defined($collection) or usage "${name}collection not defined";
      $collection = isCollection($collection) || usage "invalid ${name}collection defined: must be alphanumeric, with optional periods in the middle";
      vlog_option("${name}collection", $collection);
      return $collection;
  }
  
  
  sub validate_database ($;$) {
      my $database = shift;
      my $name     = shift || "";
      $name .= " " if $name;
      defined($database)      || usage "${name}database not defined";
      $database = isDatabaseName($database) || usage "invalid ${name}database defined: must be alphanumeric";
      vlog_option("${name}database", $database);
      return $database;
  }
  
  
  sub validate_database_columnname ($) {
      my $column = shift;
      defined($column) || usage "column not defined";
      $column = isDatabaseColumnName($column) || usage "invalid column defined: must be alphanumeric";
      vlog_option("column", $column);
      return $column;
  }
  
  
  sub validate_database_fieldname ($) {
      my $field = shift;
      defined($field) || usage "field not defined";
      $field = isDatabaseFieldName($field) || usage "invalid field defined: must be a positive integer, or a valid field name";
      ($field eq "0") and usage "invalid field defined: cannot be zero";
      vlog_option("field", $field);
      return $field;
  }
  
  
  sub validate_database_tablename ($;$$) {
      my $table           = shift;
      my $name            = shift;
      my $allow_qualified = shift;
      $name .= " " if $name;
      defined($table) || usage "${name}table not defined";
      $table = isDatabaseTableName($table, $allow_qualified) || usage "invalid ${name}table defined: must be alphanumeric";
      vlog_option("${name}table", $table);
      return $table;
  }
  
  
  sub validate_database_viewname ($;$$) {
      my $view           = shift;
      my $name            = shift;
      my $allow_qualified = shift;
      $name .= " " if $name;
      defined($view) || usage "${name}view not defined";
      $view = isDatabaseViewName($view, $allow_qualified) || usage "invalid ${name}view defined: must be alphanumeric";
      vlog_option("${name}view", $view);
      return $view;
  }
  
  
  sub validate_database_query_select_show ($;$) {
      my $query = shift;
      my $name  = shift || "";
      $name .= " " if $name;
      defined($query) || usage "${name}query not defined";
      #$query =~ /^\s*((?i:SHOW|SELECT)\s[\w\s;:,\.\?\(\)*='"-]+)$/ || usage "invalid query supplied";
      #debug("regex validating query: $query");
      $query =~ /^\s*((?:SHOW|SELECT)\s+.+)$/i || usage "invalid ${name}query defined: may only be a SELECT or SHOW statement";
      $query = $1;
      $query =~ /\b(?:insert|update|delete|create|drop|alter|truncate)\b/i and usage "invalid ${name}query defined: found DML statement keywords!";
      # this trips up users who put ; at the end of their query and doesn't offer that much protection anyway since DML is already checked for and it may be convenient to comment out end of query for testing
      #$query =~ /;|--/i and usage "invalid ${name}query defined: suspect chars ';' or '--' detected in query!";
      $query =~ /;/ and usage "invalid ${name}query defined: you may not add semi-colons to your queries, while it works on the command line, Nagios ends up choking by prematurely terminating the check command resulting in a null shell error before this plugin executes so the error handlers in this code do not have any chance to catch it";
      vlog_option("${name}query", $query);
      return $query;
  }
  
  
  #sub validate_dir ($;$) {
  #    validate_directory(@_);
  #}
  
  
  sub validate_dirname ($;$$$) {
      my $dirname = shift;
      my $name     = shift || "";
      my $noquit   = shift;
      my $no_vlog  = shift;
      $name .= " " if $name;
      if(not defined($dirname) or $dirname =~ /^\s*$/){
          usage "${name}directory not defined";
          return;
      }
      my $dirname2;
      unless($dirname2 = isDirname($dirname)){
          usage "invalid ${name}directory (does not match regex critera): '$dirname'" unless $noquit;
          return;
      }
      vlog_option("${name}directory", $dirname2) unless $no_vlog;
      return $dirname2;
  }
  
  
  sub validate_directory ($;$$$) {
      my $dir     = shift;
      my $name    = shift || "";
      my $noquit  = shift;
      my $no_vlog = shift;
      $name .= " " if $name;
      if($noquit){
          return validate_dirname($dir, $name, "noquit");
      }
      defined($dir) || usage "${name}directory not defined";
      $dir = validate_dirname($dir, $name, "noquit", $no_vlog) || usage "invalid ${name}directory (does not match regex criteria): '$dir'";
      ( -d $dir) || usage "cannot find ${name}directory: '$dir'";
      return $dir;
  }
  *validate_dir = \&validate_directory;
  
  
  sub validate_domain ($;$) {
      my $domain = shift;
      my $name   = shift || "";
      $name .= " " if $name;
      defined($domain) || usage "${name}domain name not defined";
      # don't print the domain as it gets reset to undef and results in "Use of uninitialized value $domain in concatenation (.) or string"
      my $domain2 = $domain;
      $domain = isDomain($domain) or usage "invalid ${name}domain name '$domain2' defined";
      vlog_option("${name}domain", $domain);
      return $domain;
  }
  
  
  # SECURITY NOTE: this only validates the email address is valid, it's doesn't make it safe to arbitrarily pass to commands or SQL etc!
  sub validate_email ($) {
      my $email = shift;
      defined($email) || usage "email not defined";
      isEmail($email) || usage "invalid email address defined: failed regex validation";
      # Not passing it through regex as I don't want to untaint it due to the addition of the valid ' char in email addresses
      return $email;
  }
  
  
  sub validate_filename ($;$$$) {
      my $filename = shift;
      my $name     = shift || "filename";
      my $noquit   = shift;
      my $no_vlog  = shift;
      if(not defined($filename) or $filename =~ /^\s*$/){
          usage "$name not defined";
          return;
      }
      my $filename2;
      unless($filename2 = isFilename($filename)){
          usage "invalid $name (does not match regex critera): '$filename'" unless $noquit;
          return;
      }
      vlog_option($name, $filename2) unless $no_vlog;
      return $filename2;
  }
  
  
  sub validate_file ($;$$$) {
      my $filename = shift;
      my $name     = shift || "";
      my $noquit   = shift;
      my $no_vlog  = shift;
      $filename = validate_filename($filename, $name, $noquit, $no_vlog) or return;
      unless( -f $filename ){
          $name .= " " if $name;
          usage "${name}file not found: '$filename' ($!)" unless $noquit;
          return
      }
      return $filename;
  }
  
  
  sub validate_float ($$$$) {
      my ($float, $name, $min, $max) = @_;
      defined($float) || usage "$name not defined";
      isFloat($float,1) or usage "invalid $name defined: must be a real number";
      if(
          not ( isFloat($min, "allow_negative") or isScientific($min, "allow_negative") )
          or
          not ( isFloat($max, "allow_negative") or isScientific($max, "allow_negative") )
      ){
          usage "invalid min/max ($min/$max) passed to validate_float()";
      }
      ($float >= $min && $float <= $max) or usage "invalid $name defined: must be real number between $min and $max";
      $float =~ /^(-?\d+(?:\.\d+)?)$/ or usage "invalid float $name passed to validate_float(), WARNING: caught LATE";
      $float = $1;
      vlog_option($name, $float);
      return $float;
  }
  
  
  sub validate_fqdn ($;$) {
      my $fqdn = shift;
      my $name = shift || "";
      $name .= " " if $name;
      defined($fqdn) || usage "${name}FQDN not defined";
      my $fqdn2 = $fqdn;
      $fqdn = isFqdn($fqdn) || usage "invalid ${name}FQDN '$fqdn' defined";
      vlog_option("${name}fqdn", $fqdn);
      return $fqdn
  }
  
  
  sub validate_host_port_user_password($$$$){
      return (validate_host($_[0]), validate_port($_[1]), validate_user($_[2]), validate_password($_[3]));
  }
  
  
  sub validate_host ($;$) {
      my $host = shift;
      my $name = shift || "";
      $name = "$name " if $name;
      defined($host) || usage "${name}host not defined";
      $host = isHost($host) || usage "invalid ${name}host '$host' defined: not a valid hostname or IP address";
      vlog_option("${name}host", $host);
      return $host;
  }
  
  
  sub validate_hosts($$){
      my $hosts = shift;
      my $port  = shift;
      $port = isPort($port) or usage "invalid port given";
      defined($hosts) or usage "hosts not defined";
      my @hosts = split(/\s*,\s*/, $hosts);
      @hosts or usage "no hosts defined";
      my $node_port;
      foreach(my $i = 0; $i < scalar @hosts; $i++){
          undef $node_port;
          if($hosts[$i] =~ /:(\d+)$/){
              $node_port = isPort($1) or usage "invalid port given for host " . $i+1;
              $hosts[$i] =~ s/:$node_port$//;
          }
          $hosts[$i]  = validate_host($hosts[$i]);
          # don't replace $host with IP as it can break load balancer routing with '503 Service Temporarily Unavailable'
          #$hosts[$i]  = validate_resolvable($hosts[$i]);
          #validate_resolvable($hosts[$i]);
          $node_port  = $port unless defined($node_port);
          $hosts[$i] .= ":$node_port";
          vlog_option("port", $node_port);
      }
      return @hosts;
  }
  
  
  sub validate_hostport ($;$) {
      my $hostport      = shift;
      my $name          = shift || "";
      my $port_required = shift;
      my $no_vlog       = shift;
      $name .= " " if $name;
      defined($hostport) || usage "${name}host:port option not defined";
      my ($host, $port) = split(":", $hostport, 2);
      $host = isHost($host) || usage "invalid ${name}host '$host' defined for host:port: not a valid hostname or IP address";
      if($port){
          $port = isPort($port) || usage "invalid ${name}port '$port' defined for host:port: must be a positive integer";
      } elsif($port_required){
          usage "':port' is required for ${name}host:port option";
      }
      $hostport = $host;
      $hostport .= ":$port" if $port;
      vlog_option("${name}host:port", $hostport) unless $no_vlog;
      return $hostport;
  }
  
  
  sub validate_hostname ($;$) {
      my $hostname = shift;
      my $name     = shift || "";
      $name = "$name " if $name;
      defined($hostname) || usage "${name}hostname not defined";
      $hostname = isHostname($hostname) || usage "invalid ${name}hostname defined";
      vlog_option("${name}hostname", $hostname);
      return $hostname;
  }
  
  
  sub validate_int ($$;$$) {
      my ($integer, $name, $min, $max) = @_;
      defined($name) || code_error "name not defined when calling validate_int()";
      defined($integer) || usage "$name not defined";
      isInt($integer, 1) or usage "invalid $name defined: must be an integer";
      if(defined($min)){
          isFloat($min, 1) or code_error "invalid min value '$min' passed to validate_int() for 2nd arg (min value): must be float value";
          $integer < $min and usage "invalid $name defined: cannot be lower than $min";
      }
      if(defined($max)){
          isFloat($max, 1) or code_error "invalid max value '$max' passed to validate_int() for 3rd arg (max value): must be float value";
          $integer > $max and usage "invalid $name defined: cannot be greater than $max";
      }
      $integer =~ /^(-?\d+)$/ or usage "invalid integer $name passed to validate_int() - WARNING: caught LATE code may need updating";
      $integer = $1;
      vlog_option($name, $integer);
      return $integer;
  }
  *validate_integer = \&validate_int;
  
  
  sub validate_interface ($) {
      my $interface = shift;
      defined($interface) || usage "interface not defined";
      $interface = isInterface($interface) || usage "invalid interface defined: must be either eth<N>, bond<N> or lo<N>";
      vlog_option("interface", $interface);
      return $interface;
  }
  
  
  sub validate_ip ($;$) {
      my $ip   = shift;
      my $name = shift || "";
      $name   .= " " if $name;
      defined($ip) || usage "${name}IP not defined";
      $ip = isIP($ip) || usage "invalid ${name}IP defined";
      vlog_option("${name}IP", $ip);
      return $ip;
  }
  
  
  sub validate_java_bean ($;$) {
      my $bean = shift;
      my $name = shift || "";
      $name .= " " if $name;
      defined($bean) or usage "java bean not defined";
      $bean = isJavaBean($bean) || usage "invalid ${name}java bean defined";
      vlog_option("${name}java bean", $bean);
      return $bean;
  }
  
  
  sub validate_krb5_princ ($;$) {
      my $principal = shift;
      my $name      = shift || "";
      $name .= " " if $name;
      defined($principal) or usage "krb5 principal not defined";
      $principal = isKrb5Princ($principal) || usage "invalid ${name}krb5 principal defined";
      vlog_option("${name}krb5 principal", $principal);
      return $principal;
  }
  
  
  sub validate_krb5_realm ($;$) {
      my $realm = shift;
      my $name   = shift || "";
      $name .= " " if $name;
      defined($realm) || usage "${name}krb5 realm name not defined";
      $realm = isDomain($realm) || usage "invalid ${name}krb5 realm name defined";
      vlog_option("${name}krb5 realm", $realm);
      return $realm;
  }
  
  
  sub validate_label ($) {
      my $label  = shift;
      defined($label) or usage "label not defined";
      $label = isLabel($label) || usage "invalid label defined: must be an alphanumeric identifier";
      vlog_option("label", $label);
      return $label;
  }
  
  
  sub validate_ldap_dn ($;$) {
      #subtrace(@_);
      my $dn   = shift;
      my $name = shift || "";
      $name .= " " if $name;
      defined($dn) or usage "ldap ${name}dn not defined";
      $dn = isLdapDn($dn) || usage "invalid ldap ${name}dn defined";
      vlog_option("ldap ${name}dn", $dn);
      return $dn;
  }
  
  
  sub validate_metrics ($) {
      my $metrics = shift;
      my @metrics;
      if($metrics){
          foreach(split(/\s*,\s*/, $metrics)){
              $_ = trim($_);
              /^\s*([A-Za-z0-9][\w\.]+[A-Za-z0-9])\s*$/ or usage "invalid metric '$_' given, must be alphanumeric, may contain underscores and dots in the middle";
              push(@metrics, $1);
          }
          @metrics or usage "no valid metrics given";
          @metrics = uniq_array @metrics;
          vlog_option("metrics", "[ " . join(" ", @metrics) . " ]");
      }
      return @metrics;
  }
  
  
  # Takes an array and for any items separated by spaces or commas also splits them into array components to be able to conveniently pass a string and/or arrays mixed together and do the right thing
  sub validate_node_list (@) {
      my @nodes = @_;
      @nodes or usage "node(s) not defined";
      my @nodes2;
      foreach(@nodes){
          push(@nodes2, split(/[,\s]+/, $_));
      }
      # do this validate_node_list
      #push(@nodes, @ARGV);
      scalar @nodes2 or usage "node list empty";
      @nodes = uniq_array(@nodes2);
      my $node_count = scalar @nodes;
      foreach (my $i = 0; $i < $node_count; $i++){
          $nodes[$i] = isHost($nodes[$i]) || usage "invalid node name '$nodes[$i]': must be hostname/FQDN or IP address";
      }
      vlog_option("node list", "[ '" . join("', '", @nodes) . "' ]");
      return @nodes;
  }
  
  
  # Takes an array and for any items separated by spaces or commas also splits them into array components to be able to conveniently pass a string and/or arrays mixed together and do the right thing
  sub validate_nodeport_list (@) {
      my @nodes = @_;
      @nodes or usage "node(s) not defined";
      my @nodes2;
      foreach(@nodes){
          defined($_) or next;
          push(@nodes2, split(/[,\s]+/, $_));
      }
      scalar @nodes2 or usage "node list empty";
      @nodes = uniq_array2(@nodes2);
      my $node_count = scalar @nodes;
      foreach(my $i = 0; $i < $node_count; $i++){
          $nodes[$i] = validate_hostport($nodes[$i]);
      }
      vlog_option("node list", "[ '" . join("', '", @nodes) . "' ]");
      return @nodes;
  }
  
  
  sub validate_nosql_key($;$){
      my $key  = shift;
      my $name = shift || "";
      $name .= " " if $name;
      defined($key) or usage "${name}key not defined";
      $key = isNoSqlKey($key) || usage "invalid ${name}key name defined: may only contain characters: alphanumeric, commas, colons, underscores, pluses, dashes";
      vlog_option("${name}key", $key);
      return $key;
  }
  
  
  sub validate_port ($;$) {
      my $port = shift;
      my $name = shift || "";
      $name    = "$name " if $name;
      defined($port)         || usage "${name}port not defined";
      $port  = isPort($port) || usage "invalid ${name}port number defined: must be a positive integer";
      vlog_option("${name}port", $port);
      return $port;
  }
  
  
  sub validate_process_name ($;$) {
      my $process = shift;
      my $name    = shift || "";
      $name .= " " if $name;
      defined($process) or usage "${name}process name not defined";
      $process = isProcessName($process) || usage "invalid ${name}process name defined";
      vlog_option("${name}process name", $process);
      return $process;
  }
  
  
  sub validate_program_path ($$;$) {
      my $path  = shift;
      my $name  = shift;
      my $regex = shift() || $name;
      defined($path) or usage "$name program path not defined";
      defined($name) or usage "$path program name not defined";
      if($path !~ /^[\.\/]/){
          $path = which($path);
          unless(defined($path)){
              usage "$name program not found in \$PATH ($ENV{PATH})";
          }
      }
      validate_regex($regex, "program path regex", 1) or code_error "invalid regex given to validate_program_path()";
      $path = validate_filename($path, undef, undef, "no vlog") or usage "invalid path given for $name, failed filename regex";
      $path =~ /(?:^|\/)$regex$/ || usage "invalid path given for $name, is not a path to the $name command";
      ( -f $path ) or usage "$path not found";
      ( -x $path ) or usage "$path not executable";
      vlog_option("${name} program path", $path);
      return $path;
  }
  
  
  # TODO: unify with isRegex and do not allow noquit
  sub validate_regex ($;$$$) {
      my $regex  = shift;
      my $name   = shift || "";
      my $noquit = shift;
      my $posix  = shift;
      $name = "${name} " if $name;
      my $regex2;
      if($noquit){
          defined($regex) or return;
      } else {
          defined($regex) or usage "${name}regex not defined";
      }
      if($posix){
          if($regex =~ /\$\(|\`/){
              quit "UNKNOWN", "invalid ${name}posix regex supplied: contains sub shell metachars ( \$( / ` ) that would be dangerous to pass to shell" unless $noquit;
              return;
          } else {
              # XXX: this behaviour is broken in busybox (used in Alpine linux on docker) - it doesn't detect the error in the regex - the validation must be too weak - must install proper grep in that case
              # cannot return exitcode and test that because the random regex won't match /dev/null
              my @output = cmd("egrep '$regex' < /dev/null");
              #if(grep({$_ =~ "Unmatched"} @output)){
              if(@output){
                  #quit "UNKNOWN", "invalid posix regex supplied: contains unbalanced () or []" unless $noquit;
                  quit "UNKNOWN", "invalid ${name}posix regex defined: @output" unless $noquit;
                  return;
              }
          }
      } else {
          #$regex2 = isRegex($regex);
          $regex2 = eval { qr/$regex/ };
          if($@){
              my $errstr = $@;
              $errstr =~ s/;.*?$//;
              $errstr =~ s/in regex m\/.*?$/in regex/;
              quit "UNKNOWN", "invalid ${name}regex defined: $errstr" unless $noquit;
              return;
          }
      }
      if($regex2){
          vlog_option("${name}regex", $regex2) unless $noquit;
          return $regex2;
      } else {
          vlog_option("${name}regex", $regex) unless $noquit;
          return $regex;
      }
  }
  
  
  sub validate_password ($;$$) {
      my $password  = shift;
      my $name      = shift || "";
      my $allow_all = shift;
      $name = "$name " if $name;
      defined($password) or usage "${name}password not defined";
      if($allow_all){
          # intentionally not untaining
          $password =~ /^(.+)$/ || usage "invalid ${name}password defined";
      } else {
          $password =~ /^([^'"`]+)$/ or usage "invalid ${name}password defined: may not contain quotes or backticks";
          $password = $1;
          $password =~ /\$\(/ and usage "invalid ${name}password defined: may not contain \$( as this is a subshell escape and could be dangerous to pass through to programs on the command line";
      }
      if($ENV{'PASSWORD_DEBUG'}){
          vlog_option("${name}password", "$password");
      } else {
          vlog_option("${name}password", "<omitted>");
      }
      return $password;
  }
  
  
  sub validate_resolvable($;$){
      my $host = shift;
      my $name = shift || "";
      $name .= " " if $name;
      defined($host) or code_error "${name}host not defined";
      return resolve_ip($host) || quit "CRITICAL", "failed to resolve ${name}host '$host'";
  }
  
  
  sub validate_ssl_opts(){
      if(defined($ssl_noverify)){
          $main::ua->ssl_opts( verify_hostname => 0 );
      }
      if(defined($ssl_ca_path)){
          $ssl_ca_path = validate_directory($ssl_ca_path, "SSL CA directory", undef, "no vlog");
          $main::ua->ssl_opts( SSL_ca_path => $ssl_ca_path );
      }
      if($ssl or $tls){
          vlog_option("SSL CA Path",  $ssl_ca_path) if defined($ssl_ca_path);
          vlog_option("SSL noverify", $ssl_noverify ? "true" : "false");
          $main::protocol = "https" if defined($main::protocol);
      }
  }
  
  sub validate_ssl(){
      defined_main_ua();
      $ssl = 1 if(defined($ssl_ca_path) or defined($ssl_noverify));
      if($ssl){
          vlog_option("SSL enabled",  "true");
      }
      validate_ssl_opts();
  }
  
  sub validate_tls(){
      defined_main_ua();
      $tls = 1 if(defined($ssl_ca_path) or defined($ssl_noverify));
      if($tls){
          vlog_option("TLS enabled",  "true");
      }
      validate_ssl_opts();
  }
  
  
  sub validate_threshold ($$;$) {
      #subtrace(@_);
      my $name        = shift;
      my $threshold   = shift;
      my $options_ref = shift() || {};
      isHash($options_ref) or code_error "3rd arg to validate_threshold() must be a hash ref of options";
      $options_ref->{"positive"} = 1 unless defined($options_ref->{"positive"});
      $options_ref->{"simple"} = "upper" unless $options_ref->{"simple"};
      my @valid_options = qw/simple positive integer min max/;
      foreach my $option (sort keys %$options_ref){
          grep(/^$option$/, @valid_options) or code_error "invalid option '$option' passed to validate_threshold(), must be one of " . join("/", @valid_options);
      }
      unless ($options_ref->{"simple"} eq "upper" or $options_ref->{"simple"} eq "lower") {
          code_error "simple => '$options_ref->{simple}' option to validate_threshold() must be either 'upper' or 'lower', not '$options_ref->{simple}'";
      }
      #debug("validating $name threshold against $threshold");
      my $invert_range = 0;
      defined($threshold) or code_error "no threshold (arg 2) given to validate_threshold subroutine";
      $thresholds{"$name"}{"invert_range"} = 0;
      # Make this more flexible
      if ($threshold =~ $threshold_range_regex) {
          $thresholds{$name}{"invert_range"} = 1 if $1;
          if(defined($3)){
              $thresholds{$name}{"upper"} = $4 if defined($4);
              $thresholds{$name}{"lower"} = $2;
          } else {
              $thresholds{$name}{"upper"} = $2;
          }
          if(defined($thresholds{$name}{"upper"}) and defined($thresholds{$name}{"lower"})){
              $thresholds{$name}{"upper"} < $thresholds{$name}{"lower"} and usage "invalid args: upper $name threshold cannot be lower than lower $name threshold";
          }
      } elsif($threshold =~ $threshold_simple_regex) {
          if($options_ref->{"simple"} eq "upper"){
              $thresholds{$name}{"upper"} = $1;
          } elsif($options_ref->{"simple"} eq "lower"){
              $thresholds{$name}{"lower"} = $1;
          }
      } else {
          usage "invalid $name threshold given, must be in standard nagios threshold format [@][start:]end";
      }
      foreach(qw/upper lower/){
          if($options_ref->{"positive"} and defined($thresholds{$name}{$_}) and $thresholds{$name}{$_} < 0){
              usage "$name threshold may not be less than zero";
          }
          if($options_ref->{"integer"} and defined($thresholds{$name}{$_}) and not isInt($thresholds{$name}{$_}, 1)){
              usage "$name threshold must be an integer";
          }
          if($options_ref->{"min"} and defined($thresholds{$name}{$_}) and $thresholds{$name}{$_} < $options_ref->{"min"}){
              usage "$name threshold cannot be less than $options_ref->{min}";
          }
          if($options_ref->{"max"} and defined($thresholds{$name}{$_}) and $thresholds{$name}{$_} > $options_ref->{"max"}){
              usage "$name threshold cannot be greater than $options_ref->{max}";
          }
      }
      $thresholds{"defined"} = 1 if (defined($thresholds{$name}{"upper"}) or defined($thresholds{$name}{"lower"}));
      $thresholds{$name}{"range"} = "";
      $thresholds{$name}{"range"} .= $thresholds{$name}{"lower"} if defined($thresholds{$name}{"lower"});
      $thresholds{$name}{"range"} .= ":" if (defined($thresholds{$name}{"lower"}) and defined($thresholds{$name}{"upper"}));
      $thresholds{$name}{"range"}.= $thresholds{$name}{"upper"} if defined($thresholds{$name}{"upper"});
      vlog_option(sprintf("%-8s lower", $name), $thresholds{"$name"}{"lower"}) if defined($thresholds{"$name"}{"lower"});
      vlog_option(sprintf("%-8s upper", $name), $thresholds{"$name"}{"upper"}) if defined($thresholds{"$name"}{"upper"});
      vlog_option(sprintf("%-8s range inversion", $name), "on") if $thresholds{$name}{"invert_range"};
      1;
  }
  
  
  sub validate_thresholds (;$$$$$) {
      # TODO: CRITICAL vs WARNING threshold logic is only applied to simple thresholds, not to range ones, figure out if I can reasonably do range ones later
      my $require_warning  = shift;
      my $require_critical = shift;
      my $options          = shift;
      my $name             = shift() || "";
      my $dual_threshold   = shift;
      my $warning          = $warning;
      my $critical         = $critical;
      if($name){
          $name .= " ";
          if(defined($dual_threshold)){
              ($warning, $critical) = split(",", $dual_threshold, 2);
              if(defined($warning) and not defined($critical)){
                  $critical = $warning;
                  $warning  = undef;
              }
          } else {
              if($require_warning or $require_critical){
                  code_error "no threshold given for $name";
              }
          }
      }
      if($require_warning){
          defined($warning)  || usage "${name}warning threshold not defined";
      }
      if($require_critical){
          defined($critical) || usage "${name}critical threshold not defined";
      }
      # replace $warning and $critical with $name options somehow
      validate_threshold("${name}warning",  $warning,  $options) if(defined($warning));
      validate_threshold("${name}critical", $critical, $options) if(defined($critical));
      # sanity checking on thresholds for simple upper or lower thresholds only
      if(isHash($options) and $options->{"simple"} and $options->{"simple"} eq "lower"){
          if (defined($thresholds{"${name}warning"}{"lower"})
          and defined($thresholds{"${name}critical"}{"lower"})
          and $thresholds{"${name}warning"}{"lower"} < $thresholds{"${name}critical"}{"lower"}){
              usage "${name}warning threshold (" . $thresholds{"${name}warning"}{"lower"} . ") cannot be lower than ${name}critical threshold (" . $thresholds{"${name}critical"}{"lower"} . ") for lower limit thresholds";
          }
      } elsif(isHash($options) and $options->{"simple"} and $options->{"simple"} eq "upper"){
          if (defined($thresholds{"${name}warning"}{"upper"})
          and defined($thresholds{"${name}critical"}{"upper"})
          and $thresholds{"${name}warning"}{"upper"} > $thresholds{"${name}critical"}{"upper"}){
              usage "${name}warning threshold (" . $thresholds{"${name}warning"}{"upper"} . ") cannot be higher than ${name}critical threshold (" . $thresholds{"${name}critical"}{"upper"} . ") for upper limit thresholds";
          }
      }
      1;
  }
  
  
  # Not sure if I can relax the case sensitivity on these according to the Nagios Developer guidelines
  sub validate_units ($;$) {
      my $units = shift;
      my $name  = shift || "";
      $name .= " " if $name;
      $units or usage("${name}units not defined");
      $units = isNagiosUnit($units) || usage("invalid ${name}units defined, must be one of: " . join(" ", @valid_units));
      vlog_option("${name}units", $units);
      return $units;
  }
  
  
  sub validate_url ($;$) {
      my $url  = $_[0] if $_[0];
      my $name = $_[1] || "";
      $name .= " " if $name;
      defined($url) or usage "${name}url not defined";
      $url = isUrl($url) || usage "invalid ${name}url defined: '$url'";
      vlog_option("${name}url", $url);
      return $url;
  }
  
  
  sub validate_url_path_suffix ($;$) {
      my $url  = $_[0] if $_[0];
      my $name = $_[1] || "";
      $name .= " " if $name;
      defined($url) or usage "${name}url not defined";
      $url = isUrlPathSuffix($url) || usage "invalid ${name}url defined: '$url'";
      vlog_option("${name}url", $url);
      return $url;
  }
  
  
  sub validate_user ($;$) {
      #subtrace(@_);
      my $user = shift;
      my $name = shift || "";
      $name .= " " if $name;
      defined($user) or usage "${name}username not defined";
      $user = isUser($user) || usage "invalid ${name}username defined: must be alphanumeric";
      vlog_option("${name}user", $user);
      return $user;
  }
  *validate_username = \&validate_user;
  
  
  sub validate_user_exists ($;$) {
      #subtrace(@_);
      my $user = shift;
      my $name = shift || "";
      $name .= " " if $name;
      $user = validate_user($user);
      user_exists($user) or usage "invalid ${name}user defined, not found on local system";
      return $user;
  }
  
  
  sub verbose_mode () {
      vlog2("verbose mode on\n");
      vlog3(version_string() . "\n");
      return $verbose >= 1;
  }
  
  sub version_string () {
      my $version_str = "";
      $version_str .= "$progname version $main::VERSION  =>  " if defined($progname and $main::VERSION);
      $version_str .= "Hari Sekhon Utils version $HariSekhonUtils::VERSION";
      return $version_str;
  }
  
  sub version () {
      defined($main::VERSION) or $main::VERSION = "unset";
      usage version_string();
  }
  
  
  sub vlog (@) {
      if($debug){
          print STDERR strftime("%F %T %z  ", localtime);
      }
      print STDERR "@_\n" if $verbose;
  }
  sub vlog2 (@) {
      vlog @_ if ($verbose >= 2);
  }
  
  sub vlog3 (@) {
      vlog @_ if ($verbose >= 3);
  }
  
  sub vlogt (@) {
      vlog tstamp() . "@_";
  }
  
  sub vlog2t (@) {
      vlog2 tstamp . "@_";
  }
  
  sub vlog3t (@) {
      vlog3 tstamp . "@_";
  }
  
  # TODO: check this
  # $progname: prefixed
  sub vlog4 (@){
      if($verbose){
          foreach(@_){
              foreach (split(/\n/, $_)){
                  vlog "$progname\[$$\]: $_";
              }
          }
          1;
      }
  }
  
  
  sub vlog_option ($$) {
      #scalar @_ eq 2 or code_error "incorrect number of args passed to vlog_option()";
      vlog2 sprintf("%-25s %s", "$_[0]:", $_[1]);
  }
  
  sub vlog_option_bool ($$) {
      vlog_option $_[0], ( $_[1] ? "true" : "false" );
  }
  
  
  #my %download_tries;
  #my %lock_tries;
  #sub wget ($$) {
  #    require LWP::Simple;
  #    import LWP::Simple;
  #    my $url        = shift;
  #    my $local_file = shift;
  #
  #    $download_tries{$url}++;
  #    $lock_tries{$url} = 0;
  #    until(go_flock_yourself){
  #        $lock_tries{$url}++;
  #        if($lock_tries{$url} > $LOCK_TRY_ATTEMPTS){
  #            vlog "Hit max lock attempts on url '$url' ($LOCK_TRY_ATTEMPTS attempts, $LOCK_TRY_INTERVAL secs apart) while waiting for download lock, aborting download...\n";
  #            return;
  #        }
  #        vlog "sleeping for $LOCK_TRY_INTERVAL secs before retrying download lock for url '$url'";
  #        sleep $LOCK_TRY_INTERVAL;
  #    }
  #    vlog "download lock acquired, fetcing '$url' (attempt $download_tries{$url}/$DOWNLOAD_TRIES)";
  #    my $rc = mirror($url, $local_file);
  #    if ($rc == RC_NOT_MODIFIED){
  #        vlog "local file '$local_file' is up to date, not redownloaded";
  #        return 1;
  #    } elsif(is_success($rc)){
  #        vlog "download successful";
  #        return 1;
  #    } else {
  #        vlog "error downloading $url: return code is '$rc'";
  #        flock_off;
  #        if($download_tries{$url} >= $DOWNLOAD_TRIES){
  #            vlog "failed to download url '$url' $DOWNLOAD_TRIES times";
  #            return;
  #        }
  #        vlog "sleeping for $DOWNLOAD_RETRY_INTERVAL secs before trying again";
  #        sleep $DOWNLOAD_RETRY_INTERVAL;
  #        return wget($url, $local_file);
  #    }
  #    return;
  #    #vlog "fetching $url.md5...";
  #    #getstore("$url.md5", "$local_file.md5");
  ##    if(open(my $fh, "$local_file.md5")){
  ##        #vlog ".md5 file present, checking md5sum against '$local_file'";
  ##        $md5sum = do { local $/; <$fh> };
  ##        chomp $md5sum;
  ##        my $md5 = md5sum($local_file);
  ##        if($md5 eq $md5sum){
  ##            vlog "$local_file .md5 file matched '$md5' == '$md5sum', proceeding...";
  ##            last;
  ##        } else {
  ##            vlog "attempt $tries: $local_file did not match yet, file is '$md5' but .md5 file contains '$md5sum'";
  ##            wget($url, $local_file);
  ##        }
  ##    }
  #}
  
  
  sub which ($;$) {
      my $bin  = $_[0] || code_error "no arg supplied to which() subroutine";
      my $quit = $_[1] || 0;
      $bin = isFilename($bin) || quit "UNKNOWN", "invalid filename '$bin' supplied";
      if($bin =~ /^(?:\/|\.\/)/){
          if(-f $bin){
              if(-x $bin){
                  return $bin;
              } else {
                  quit "UNKNOWN", "'$bin' is not executable" if $quit;
              }
          } else {
              quit "UNKNOWN", "couldn't find executable '$bin': $!" if $quit;
          }
      } else {
          foreach(split(":", $ENV{"PATH"})){
              (-x "$_/$bin") && return "$_/$bin";
          }
          quit "UNKNOWN", "couldn't find '$bin' in \$PATH ($ENV{PATH})" if $quit;
      }
      return;
  }
  
  
  1;
HARISEKHONUTILS

$fatpacked{"Hbase/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HBASE_CONSTANTS';
  #
  # Autogenerated by Thrift Compiler (0.13.0)
  #
  # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  #
  package Hbase::Constants;
  use 5.10.0;
  use strict;
  use warnings;
  use Thrift::Exception;
  use Thrift::MessageType;
  use Thrift::Type;
  
  
  1;
HBASE_CONSTANTS

$fatpacked{"Hbase/Hbase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HBASE_HBASE';
  #
  # Autogenerated by Thrift Compiler (0.13.0)
  #
  # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  #
  use 5.10.0;
  #use strict;
  use warnings;
  use Thrift::Exception;
  use Thrift::MessageType;
  use Thrift::Type;
  
  use Hbase::Types;
  
  
  # HELPER FUNCTIONS AND STRUCTURES
  
  package Hbase::Hbase_enableTable_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_enableTable_args->mk_accessors( qw( tableName ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_enableTable_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_enableTable_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_enableTable_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_enableTable_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_enableTable_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_enableTable_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_disableTable_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_disableTable_args->mk_accessors( qw( tableName ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_disableTable_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_disableTable_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_disableTable_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_disableTable_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_disableTable_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_disableTable_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_isTableEnabled_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_isTableEnabled_args->mk_accessors( qw( tableName ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_isTableEnabled_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_isTableEnabled_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_isTableEnabled_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_isTableEnabled_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_isTableEnabled_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
          $xfer += $input->readBool(\$self->{success});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_isTableEnabled_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
      $xfer += $output->writeBool($self->{success});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_compact_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_compact_args->mk_accessors( qw( tableNameOrRegionName ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableNameOrRegionName} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableNameOrRegionName}) {
        $self->{tableNameOrRegionName} = $vals->{tableNameOrRegionName};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_compact_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableNameOrRegionName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_compact_args');
    if (defined $self->{tableNameOrRegionName}) {
      $xfer += $output->writeFieldBegin('tableNameOrRegionName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableNameOrRegionName});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_compact_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_compact_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_compact_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_compact_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_majorCompact_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_majorCompact_args->mk_accessors( qw( tableNameOrRegionName ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableNameOrRegionName} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableNameOrRegionName}) {
        $self->{tableNameOrRegionName} = $vals->{tableNameOrRegionName};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_majorCompact_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableNameOrRegionName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_majorCompact_args');
    if (defined $self->{tableNameOrRegionName}) {
      $xfer += $output->writeFieldBegin('tableNameOrRegionName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableNameOrRegionName});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_majorCompact_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_majorCompact_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_majorCompact_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_majorCompact_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getTableNames_args;
  use base qw(Class::Accessor);
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getTableNames_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getTableNames_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getTableNames_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getTableNames_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getTableNames_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size44 = 0;
            $self->{success} = [];
            my $_etype47 = 0;
            $xfer += $input->readListBegin(\$_etype47, \$_size44);
            for (my $_i48 = 0; $_i48 < $_size44; ++$_i48)
            {
              my $elem49 = undef;
              $xfer += $input->readString(\$elem49);
              push(@{$self->{success}},$elem49);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getTableNames_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
        {
          foreach my $iter50 (@{$self->{success}})
          {
            $xfer += $output->writeString($iter50);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getColumnDescriptors_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getColumnDescriptors_args->mk_accessors( qw( tableName ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getColumnDescriptors_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getColumnDescriptors_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getColumnDescriptors_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getColumnDescriptors_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getColumnDescriptors_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size51 = 0;
            $self->{success} = {};
            my $_ktype52 = 0;
            my $_vtype53 = 0;
            $xfer += $input->readMapBegin(\$_ktype52, \$_vtype53, \$_size51);
            for (my $_i55 = 0; $_i55 < $_size51; ++$_i55)
            {
              my $key56 = '';
              my $val57 = Hbase::ColumnDescriptor->new();
              $xfer += $input->readString(\$key56);
              $val57 = Hbase::ColumnDescriptor->new();
              $xfer += $val57->read($input);
              $self->{success}->{$key56} = $val57;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getColumnDescriptors_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{success}}));
        {
          while( my ($kiter58,$viter59) = each %{$self->{success}})
          {
            $xfer += $output->writeString($kiter58);
            $xfer += ${viter59}->write($output);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getTableRegions_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getTableRegions_args->mk_accessors( qw( tableName ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getTableRegions_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getTableRegions_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getTableRegions_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getTableRegions_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getTableRegions_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size60 = 0;
            $self->{success} = [];
            my $_etype63 = 0;
            $xfer += $input->readListBegin(\$_etype63, \$_size60);
            for (my $_i64 = 0; $_i64 < $_size60; ++$_i64)
            {
              my $elem65 = undef;
              $elem65 = Hbase::TRegionInfo->new();
              $xfer += $elem65->read($input);
              push(@{$self->{success}},$elem65);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getTableRegions_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter66 (@{$self->{success}})
          {
            $xfer += ${iter66}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_createTable_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_createTable_args->mk_accessors( qw( tableName columnFamilies ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{columnFamilies} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{columnFamilies}) {
        $self->{columnFamilies} = $vals->{columnFamilies};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_createTable_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size67 = 0;
            $self->{columnFamilies} = [];
            my $_etype70 = 0;
            $xfer += $input->readListBegin(\$_etype70, \$_size67);
            for (my $_i71 = 0; $_i71 < $_size67; ++$_i71)
            {
              my $elem72 = undef;
              $elem72 = Hbase::ColumnDescriptor->new();
              $xfer += $elem72->read($input);
              push(@{$self->{columnFamilies}},$elem72);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_createTable_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columnFamilies}) {
      $xfer += $output->writeFieldBegin('columnFamilies', Thrift::TType::LIST, 2);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{columnFamilies}}));
        {
          foreach my $iter73 (@{$self->{columnFamilies}})
          {
            $xfer += ${iter73}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_createTable_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_createTable_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    $self->{ia} = undef;
    $self->{exist} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
      if (defined $vals->{ia}) {
        $self->{ia} = $vals->{ia};
      }
      if (defined $vals->{exist}) {
        $self->{exist} = $vals->{exist};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_createTable_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{ia} = Hbase::IllegalArgument->new();
          $xfer += $self->{ia}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{exist} = Hbase::AlreadyExists->new();
          $xfer += $self->{exist}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_createTable_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ia}) {
      $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
      $xfer += $self->{ia}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{exist}) {
      $xfer += $output->writeFieldBegin('exist', Thrift::TType::STRUCT, 3);
      $xfer += $self->{exist}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_deleteTable_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_deleteTable_args->mk_accessors( qw( tableName ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_deleteTable_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteTable_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_deleteTable_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_deleteTable_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_deleteTable_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteTable_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_get_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_get_args->mk_accessors( qw( tableName row column attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{column} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{column}) {
        $self->{column} = $vals->{column};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_get_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{column});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size74 = 0;
            $self->{attributes} = {};
            my $_ktype75 = 0;
            my $_vtype76 = 0;
            $xfer += $input->readMapBegin(\$_ktype75, \$_vtype76, \$_size74);
            for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
            {
              my $key79 = '';
              my $val80 = '';
              $xfer += $input->readString(\$key79);
              $xfer += $input->readString(\$val80);
              $self->{attributes}->{$key79} = $val80;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_get_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{column}) {
      $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{column});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter81,$viter82) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter81);
            $xfer += $output->writeString($viter82);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_get_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_get_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_get_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size83 = 0;
            $self->{success} = [];
            my $_etype86 = 0;
            $xfer += $input->readListBegin(\$_etype86, \$_size83);
            for (my $_i87 = 0; $_i87 < $_size83; ++$_i87)
            {
              my $elem88 = undef;
              $elem88 = Hbase::TCell->new();
              $xfer += $elem88->read($input);
              push(@{$self->{success}},$elem88);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_get_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter89 (@{$self->{success}})
          {
            $xfer += ${iter89}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getVer_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getVer_args->mk_accessors( qw( tableName row column numVersions attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{column} = undef;
    $self->{numVersions} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{column}) {
        $self->{column} = $vals->{column};
      }
      if (defined $vals->{numVersions}) {
        $self->{numVersions} = $vals->{numVersions};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getVer_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{column});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{numVersions});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size90 = 0;
            $self->{attributes} = {};
            my $_ktype91 = 0;
            my $_vtype92 = 0;
            $xfer += $input->readMapBegin(\$_ktype91, \$_vtype92, \$_size90);
            for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
            {
              my $key95 = '';
              my $val96 = '';
              $xfer += $input->readString(\$key95);
              $xfer += $input->readString(\$val96);
              $self->{attributes}->{$key95} = $val96;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getVer_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{column}) {
      $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{column});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{numVersions}) {
      $xfer += $output->writeFieldBegin('numVersions', Thrift::TType::I32, 4);
      $xfer += $output->writeI32($self->{numVersions});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter97,$viter98) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter97);
            $xfer += $output->writeString($viter98);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getVer_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getVer_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getVer_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size99 = 0;
            $self->{success} = [];
            my $_etype102 = 0;
            $xfer += $input->readListBegin(\$_etype102, \$_size99);
            for (my $_i103 = 0; $_i103 < $_size99; ++$_i103)
            {
              my $elem104 = undef;
              $elem104 = Hbase::TCell->new();
              $xfer += $elem104->read($input);
              push(@{$self->{success}},$elem104);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getVer_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter105 (@{$self->{success}})
          {
            $xfer += ${iter105}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getVerTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getVerTs_args->mk_accessors( qw( tableName row column timestamp numVersions attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{column} = undef;
    $self->{timestamp} = undef;
    $self->{numVersions} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{column}) {
        $self->{column} = $vals->{column};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{numVersions}) {
        $self->{numVersions} = $vals->{numVersions};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getVerTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{column});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{numVersions});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^6$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size106 = 0;
            $self->{attributes} = {};
            my $_ktype107 = 0;
            my $_vtype108 = 0;
            $xfer += $input->readMapBegin(\$_ktype107, \$_vtype108, \$_size106);
            for (my $_i110 = 0; $_i110 < $_size106; ++$_i110)
            {
              my $key111 = '';
              my $val112 = '';
              $xfer += $input->readString(\$key111);
              $xfer += $input->readString(\$val112);
              $self->{attributes}->{$key111} = $val112;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getVerTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{column}) {
      $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{column});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{numVersions}) {
      $xfer += $output->writeFieldBegin('numVersions', Thrift::TType::I32, 5);
      $xfer += $output->writeI32($self->{numVersions});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 6);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter113,$viter114) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter113);
            $xfer += $output->writeString($viter114);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getVerTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getVerTs_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getVerTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size115 = 0;
            $self->{success} = [];
            my $_etype118 = 0;
            $xfer += $input->readListBegin(\$_etype118, \$_size115);
            for (my $_i119 = 0; $_i119 < $_size115; ++$_i119)
            {
              my $elem120 = undef;
              $elem120 = Hbase::TCell->new();
              $xfer += $elem120->read($input);
              push(@{$self->{success}},$elem120);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getVerTs_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter121 (@{$self->{success}})
          {
            $xfer += ${iter121}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRow_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRow_args->mk_accessors( qw( tableName row attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRow_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size122 = 0;
            $self->{attributes} = {};
            my $_ktype123 = 0;
            my $_vtype124 = 0;
            $xfer += $input->readMapBegin(\$_ktype123, \$_vtype124, \$_size122);
            for (my $_i126 = 0; $_i126 < $_size122; ++$_i126)
            {
              my $key127 = '';
              my $val128 = '';
              $xfer += $input->readString(\$key127);
              $xfer += $input->readString(\$val128);
              $self->{attributes}->{$key127} = $val128;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRow_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 3);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter129,$viter130) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter129);
            $xfer += $output->writeString($viter130);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRow_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRow_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRow_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size131 = 0;
            $self->{success} = [];
            my $_etype134 = 0;
            $xfer += $input->readListBegin(\$_etype134, \$_size131);
            for (my $_i135 = 0; $_i135 < $_size131; ++$_i135)
            {
              my $elem136 = undef;
              $elem136 = Hbase::TRowResult->new();
              $xfer += $elem136->read($input);
              push(@{$self->{success}},$elem136);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRow_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter137 (@{$self->{success}})
          {
            $xfer += ${iter137}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowWithColumns_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowWithColumns_args->mk_accessors( qw( tableName row columns attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{columns} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowWithColumns_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size138 = 0;
            $self->{columns} = [];
            my $_etype141 = 0;
            $xfer += $input->readListBegin(\$_etype141, \$_size138);
            for (my $_i142 = 0; $_i142 < $_size138; ++$_i142)
            {
              my $elem143 = undef;
              $xfer += $input->readString(\$elem143);
              push(@{$self->{columns}},$elem143);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size144 = 0;
            $self->{attributes} = {};
            my $_ktype145 = 0;
            my $_vtype146 = 0;
            $xfer += $input->readMapBegin(\$_ktype145, \$_vtype146, \$_size144);
            for (my $_i148 = 0; $_i148 < $_size144; ++$_i148)
            {
              my $key149 = '';
              my $val150 = '';
              $xfer += $input->readString(\$key149);
              $xfer += $input->readString(\$val150);
              $self->{attributes}->{$key149} = $val150;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumns_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter151 (@{$self->{columns}})
          {
            $xfer += $output->writeString($iter151);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter152,$viter153) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter152);
            $xfer += $output->writeString($viter153);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowWithColumns_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowWithColumns_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowWithColumns_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size154 = 0;
            $self->{success} = [];
            my $_etype157 = 0;
            $xfer += $input->readListBegin(\$_etype157, \$_size154);
            for (my $_i158 = 0; $_i158 < $_size154; ++$_i158)
            {
              my $elem159 = undef;
              $elem159 = Hbase::TRowResult->new();
              $xfer += $elem159->read($input);
              push(@{$self->{success}},$elem159);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumns_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter160 (@{$self->{success}})
          {
            $xfer += ${iter160}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowTs_args->mk_accessors( qw( tableName row timestamp attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{timestamp} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size161 = 0;
            $self->{attributes} = {};
            my $_ktype162 = 0;
            my $_vtype163 = 0;
            $xfer += $input->readMapBegin(\$_ktype162, \$_vtype163, \$_size161);
            for (my $_i165 = 0; $_i165 < $_size161; ++$_i165)
            {
              my $key166 = '';
              my $val167 = '';
              $xfer += $input->readString(\$key166);
              $xfer += $input->readString(\$val167);
              $self->{attributes}->{$key166} = $val167;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter168,$viter169) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter168);
            $xfer += $output->writeString($viter169);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowTs_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size170 = 0;
            $self->{success} = [];
            my $_etype173 = 0;
            $xfer += $input->readListBegin(\$_etype173, \$_size170);
            for (my $_i174 = 0; $_i174 < $_size170; ++$_i174)
            {
              my $elem175 = undef;
              $elem175 = Hbase::TRowResult->new();
              $xfer += $elem175->read($input);
              push(@{$self->{success}},$elem175);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowTs_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter176 (@{$self->{success}})
          {
            $xfer += ${iter176}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowWithColumnsTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowWithColumnsTs_args->mk_accessors( qw( tableName row columns timestamp attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{columns} = undef;
    $self->{timestamp} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowWithColumnsTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size177 = 0;
            $self->{columns} = [];
            my $_etype180 = 0;
            $xfer += $input->readListBegin(\$_etype180, \$_size177);
            for (my $_i181 = 0; $_i181 < $_size177; ++$_i181)
            {
              my $elem182 = undef;
              $xfer += $input->readString(\$elem182);
              push(@{$self->{columns}},$elem182);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size183 = 0;
            $self->{attributes} = {};
            my $_ktype184 = 0;
            my $_vtype185 = 0;
            $xfer += $input->readMapBegin(\$_ktype184, \$_vtype185, \$_size183);
            for (my $_i187 = 0; $_i187 < $_size183; ++$_i187)
            {
              my $key188 = '';
              my $val189 = '';
              $xfer += $input->readString(\$key188);
              $xfer += $input->readString(\$val189);
              $self->{attributes}->{$key188} = $val189;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter190 (@{$self->{columns}})
          {
            $xfer += $output->writeString($iter190);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter191,$viter192) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter191);
            $xfer += $output->writeString($viter192);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowWithColumnsTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowWithColumnsTs_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowWithColumnsTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size193 = 0;
            $self->{success} = [];
            my $_etype196 = 0;
            $xfer += $input->readListBegin(\$_etype196, \$_size193);
            for (my $_i197 = 0; $_i197 < $_size193; ++$_i197)
            {
              my $elem198 = undef;
              $elem198 = Hbase::TRowResult->new();
              $xfer += $elem198->read($input);
              push(@{$self->{success}},$elem198);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTs_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter199 (@{$self->{success}})
          {
            $xfer += ${iter199}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRows_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRows_args->mk_accessors( qw( tableName rows attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{rows} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{rows}) {
        $self->{rows} = $vals->{rows};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRows_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size200 = 0;
            $self->{rows} = [];
            my $_etype203 = 0;
            $xfer += $input->readListBegin(\$_etype203, \$_size200);
            for (my $_i204 = 0; $_i204 < $_size200; ++$_i204)
            {
              my $elem205 = undef;
              $xfer += $input->readString(\$elem205);
              push(@{$self->{rows}},$elem205);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size206 = 0;
            $self->{attributes} = {};
            my $_ktype207 = 0;
            my $_vtype208 = 0;
            $xfer += $input->readMapBegin(\$_ktype207, \$_vtype208, \$_size206);
            for (my $_i210 = 0; $_i210 < $_size206; ++$_i210)
            {
              my $key211 = '';
              my $val212 = '';
              $xfer += $input->readString(\$key211);
              $xfer += $input->readString(\$val212);
              $self->{attributes}->{$key211} = $val212;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRows_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{rows}) {
      $xfer += $output->writeFieldBegin('rows', Thrift::TType::LIST, 2);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{rows}}));
        {
          foreach my $iter213 (@{$self->{rows}})
          {
            $xfer += $output->writeString($iter213);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 3);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter214,$viter215) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter214);
            $xfer += $output->writeString($viter215);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRows_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRows_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRows_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size216 = 0;
            $self->{success} = [];
            my $_etype219 = 0;
            $xfer += $input->readListBegin(\$_etype219, \$_size216);
            for (my $_i220 = 0; $_i220 < $_size216; ++$_i220)
            {
              my $elem221 = undef;
              $elem221 = Hbase::TRowResult->new();
              $xfer += $elem221->read($input);
              push(@{$self->{success}},$elem221);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRows_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter222 (@{$self->{success}})
          {
            $xfer += ${iter222}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowsWithColumns_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowsWithColumns_args->mk_accessors( qw( tableName rows columns attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{rows} = undef;
    $self->{columns} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{rows}) {
        $self->{rows} = $vals->{rows};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowsWithColumns_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size223 = 0;
            $self->{rows} = [];
            my $_etype226 = 0;
            $xfer += $input->readListBegin(\$_etype226, \$_size223);
            for (my $_i227 = 0; $_i227 < $_size223; ++$_i227)
            {
              my $elem228 = undef;
              $xfer += $input->readString(\$elem228);
              push(@{$self->{rows}},$elem228);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size229 = 0;
            $self->{columns} = [];
            my $_etype232 = 0;
            $xfer += $input->readListBegin(\$_etype232, \$_size229);
            for (my $_i233 = 0; $_i233 < $_size229; ++$_i233)
            {
              my $elem234 = undef;
              $xfer += $input->readString(\$elem234);
              push(@{$self->{columns}},$elem234);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size235 = 0;
            $self->{attributes} = {};
            my $_ktype236 = 0;
            my $_vtype237 = 0;
            $xfer += $input->readMapBegin(\$_ktype236, \$_vtype237, \$_size235);
            for (my $_i239 = 0; $_i239 < $_size235; ++$_i239)
            {
              my $key240 = '';
              my $val241 = '';
              $xfer += $input->readString(\$key240);
              $xfer += $input->readString(\$val241);
              $self->{attributes}->{$key240} = $val241;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsWithColumns_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{rows}) {
      $xfer += $output->writeFieldBegin('rows', Thrift::TType::LIST, 2);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{rows}}));
        {
          foreach my $iter242 (@{$self->{rows}})
          {
            $xfer += $output->writeString($iter242);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter243 (@{$self->{columns}})
          {
            $xfer += $output->writeString($iter243);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter244,$viter245) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter244);
            $xfer += $output->writeString($viter245);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowsWithColumns_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowsWithColumns_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowsWithColumns_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size246 = 0;
            $self->{success} = [];
            my $_etype249 = 0;
            $xfer += $input->readListBegin(\$_etype249, \$_size246);
            for (my $_i250 = 0; $_i250 < $_size246; ++$_i250)
            {
              my $elem251 = undef;
              $elem251 = Hbase::TRowResult->new();
              $xfer += $elem251->read($input);
              push(@{$self->{success}},$elem251);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsWithColumns_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter252 (@{$self->{success}})
          {
            $xfer += ${iter252}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowsTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowsTs_args->mk_accessors( qw( tableName rows timestamp attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{rows} = undef;
    $self->{timestamp} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{rows}) {
        $self->{rows} = $vals->{rows};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowsTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size253 = 0;
            $self->{rows} = [];
            my $_etype256 = 0;
            $xfer += $input->readListBegin(\$_etype256, \$_size253);
            for (my $_i257 = 0; $_i257 < $_size253; ++$_i257)
            {
              my $elem258 = undef;
              $xfer += $input->readString(\$elem258);
              push(@{$self->{rows}},$elem258);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size259 = 0;
            $self->{attributes} = {};
            my $_ktype260 = 0;
            my $_vtype261 = 0;
            $xfer += $input->readMapBegin(\$_ktype260, \$_vtype261, \$_size259);
            for (my $_i263 = 0; $_i263 < $_size259; ++$_i263)
            {
              my $key264 = '';
              my $val265 = '';
              $xfer += $input->readString(\$key264);
              $xfer += $input->readString(\$val265);
              $self->{attributes}->{$key264} = $val265;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{rows}) {
      $xfer += $output->writeFieldBegin('rows', Thrift::TType::LIST, 2);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{rows}}));
        {
          foreach my $iter266 (@{$self->{rows}})
          {
            $xfer += $output->writeString($iter266);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter267,$viter268) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter267);
            $xfer += $output->writeString($viter268);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowsTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowsTs_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowsTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size269 = 0;
            $self->{success} = [];
            my $_etype272 = 0;
            $xfer += $input->readListBegin(\$_etype272, \$_size269);
            for (my $_i273 = 0; $_i273 < $_size269; ++$_i273)
            {
              my $elem274 = undef;
              $elem274 = Hbase::TRowResult->new();
              $xfer += $elem274->read($input);
              push(@{$self->{success}},$elem274);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsTs_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter275 (@{$self->{success}})
          {
            $xfer += ${iter275}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowsWithColumnsTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowsWithColumnsTs_args->mk_accessors( qw( tableName rows columns timestamp attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{rows} = undef;
    $self->{columns} = undef;
    $self->{timestamp} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{rows}) {
        $self->{rows} = $vals->{rows};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowsWithColumnsTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size276 = 0;
            $self->{rows} = [];
            my $_etype279 = 0;
            $xfer += $input->readListBegin(\$_etype279, \$_size276);
            for (my $_i280 = 0; $_i280 < $_size276; ++$_i280)
            {
              my $elem281 = undef;
              $xfer += $input->readString(\$elem281);
              push(@{$self->{rows}},$elem281);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size282 = 0;
            $self->{columns} = [];
            my $_etype285 = 0;
            $xfer += $input->readListBegin(\$_etype285, \$_size282);
            for (my $_i286 = 0; $_i286 < $_size282; ++$_i286)
            {
              my $elem287 = undef;
              $xfer += $input->readString(\$elem287);
              push(@{$self->{columns}},$elem287);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size288 = 0;
            $self->{attributes} = {};
            my $_ktype289 = 0;
            my $_vtype290 = 0;
            $xfer += $input->readMapBegin(\$_ktype289, \$_vtype290, \$_size288);
            for (my $_i292 = 0; $_i292 < $_size288; ++$_i292)
            {
              my $key293 = '';
              my $val294 = '';
              $xfer += $input->readString(\$key293);
              $xfer += $input->readString(\$val294);
              $self->{attributes}->{$key293} = $val294;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsWithColumnsTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{rows}) {
      $xfer += $output->writeFieldBegin('rows', Thrift::TType::LIST, 2);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{rows}}));
        {
          foreach my $iter295 (@{$self->{rows}})
          {
            $xfer += $output->writeString($iter295);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter296 (@{$self->{columns}})
          {
            $xfer += $output->writeString($iter296);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter297,$viter298) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter297);
            $xfer += $output->writeString($viter298);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRowsWithColumnsTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRowsWithColumnsTs_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRowsWithColumnsTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size299 = 0;
            $self->{success} = [];
            my $_etype302 = 0;
            $xfer += $input->readListBegin(\$_etype302, \$_size299);
            for (my $_i303 = 0; $_i303 < $_size299; ++$_i303)
            {
              my $elem304 = undef;
              $elem304 = Hbase::TRowResult->new();
              $xfer += $elem304->read($input);
              push(@{$self->{success}},$elem304);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsWithColumnsTs_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter305 (@{$self->{success}})
          {
            $xfer += ${iter305}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_mutateRow_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_mutateRow_args->mk_accessors( qw( tableName row mutations attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{mutations} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{mutations}) {
        $self->{mutations} = $vals->{mutations};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_mutateRow_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size306 = 0;
            $self->{mutations} = [];
            my $_etype309 = 0;
            $xfer += $input->readListBegin(\$_etype309, \$_size306);
            for (my $_i310 = 0; $_i310 < $_size306; ++$_i310)
            {
              my $elem311 = undef;
              $elem311 = Hbase::Mutation->new();
              $xfer += $elem311->read($input);
              push(@{$self->{mutations}},$elem311);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size312 = 0;
            $self->{attributes} = {};
            my $_ktype313 = 0;
            my $_vtype314 = 0;
            $xfer += $input->readMapBegin(\$_ktype313, \$_vtype314, \$_size312);
            for (my $_i316 = 0; $_i316 < $_size312; ++$_i316)
            {
              my $key317 = '';
              my $val318 = '';
              $xfer += $input->readString(\$key317);
              $xfer += $input->readString(\$val318);
              $self->{attributes}->{$key317} = $val318;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRow_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{mutations}) {
      $xfer += $output->writeFieldBegin('mutations', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{mutations}}));
        {
          foreach my $iter319 (@{$self->{mutations}})
          {
            $xfer += ${iter319}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter320,$viter321) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter320);
            $xfer += $output->writeString($viter321);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_mutateRow_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_mutateRow_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    $self->{ia} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
      if (defined $vals->{ia}) {
        $self->{ia} = $vals->{ia};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_mutateRow_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{ia} = Hbase::IllegalArgument->new();
          $xfer += $self->{ia}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRow_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ia}) {
      $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
      $xfer += $self->{ia}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_mutateRowTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_mutateRowTs_args->mk_accessors( qw( tableName row mutations timestamp attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{mutations} = undef;
    $self->{timestamp} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{mutations}) {
        $self->{mutations} = $vals->{mutations};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_mutateRowTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size322 = 0;
            $self->{mutations} = [];
            my $_etype325 = 0;
            $xfer += $input->readListBegin(\$_etype325, \$_size322);
            for (my $_i326 = 0; $_i326 < $_size322; ++$_i326)
            {
              my $elem327 = undef;
              $elem327 = Hbase::Mutation->new();
              $xfer += $elem327->read($input);
              push(@{$self->{mutations}},$elem327);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size328 = 0;
            $self->{attributes} = {};
            my $_ktype329 = 0;
            my $_vtype330 = 0;
            $xfer += $input->readMapBegin(\$_ktype329, \$_vtype330, \$_size328);
            for (my $_i332 = 0; $_i332 < $_size328; ++$_i332)
            {
              my $key333 = '';
              my $val334 = '';
              $xfer += $input->readString(\$key333);
              $xfer += $input->readString(\$val334);
              $self->{attributes}->{$key333} = $val334;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRowTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{mutations}) {
      $xfer += $output->writeFieldBegin('mutations', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{mutations}}));
        {
          foreach my $iter335 (@{$self->{mutations}})
          {
            $xfer += ${iter335}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter336,$viter337) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter336);
            $xfer += $output->writeString($viter337);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_mutateRowTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_mutateRowTs_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    $self->{ia} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
      if (defined $vals->{ia}) {
        $self->{ia} = $vals->{ia};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_mutateRowTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{ia} = Hbase::IllegalArgument->new();
          $xfer += $self->{ia}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRowTs_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ia}) {
      $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
      $xfer += $self->{ia}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_mutateRows_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_mutateRows_args->mk_accessors( qw( tableName rowBatches attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{rowBatches} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{rowBatches}) {
        $self->{rowBatches} = $vals->{rowBatches};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_mutateRows_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size338 = 0;
            $self->{rowBatches} = [];
            my $_etype341 = 0;
            $xfer += $input->readListBegin(\$_etype341, \$_size338);
            for (my $_i342 = 0; $_i342 < $_size338; ++$_i342)
            {
              my $elem343 = undef;
              $elem343 = Hbase::BatchMutation->new();
              $xfer += $elem343->read($input);
              push(@{$self->{rowBatches}},$elem343);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size344 = 0;
            $self->{attributes} = {};
            my $_ktype345 = 0;
            my $_vtype346 = 0;
            $xfer += $input->readMapBegin(\$_ktype345, \$_vtype346, \$_size344);
            for (my $_i348 = 0; $_i348 < $_size344; ++$_i348)
            {
              my $key349 = '';
              my $val350 = '';
              $xfer += $input->readString(\$key349);
              $xfer += $input->readString(\$val350);
              $self->{attributes}->{$key349} = $val350;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRows_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{rowBatches}) {
      $xfer += $output->writeFieldBegin('rowBatches', Thrift::TType::LIST, 2);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{rowBatches}}));
        {
          foreach my $iter351 (@{$self->{rowBatches}})
          {
            $xfer += ${iter351}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 3);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter352,$viter353) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter352);
            $xfer += $output->writeString($viter353);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_mutateRows_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_mutateRows_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    $self->{ia} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
      if (defined $vals->{ia}) {
        $self->{ia} = $vals->{ia};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_mutateRows_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{ia} = Hbase::IllegalArgument->new();
          $xfer += $self->{ia}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRows_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ia}) {
      $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
      $xfer += $self->{ia}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_mutateRowsTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_mutateRowsTs_args->mk_accessors( qw( tableName rowBatches timestamp attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{rowBatches} = undef;
    $self->{timestamp} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{rowBatches}) {
        $self->{rowBatches} = $vals->{rowBatches};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_mutateRowsTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size354 = 0;
            $self->{rowBatches} = [];
            my $_etype357 = 0;
            $xfer += $input->readListBegin(\$_etype357, \$_size354);
            for (my $_i358 = 0; $_i358 < $_size354; ++$_i358)
            {
              my $elem359 = undef;
              $elem359 = Hbase::BatchMutation->new();
              $xfer += $elem359->read($input);
              push(@{$self->{rowBatches}},$elem359);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size360 = 0;
            $self->{attributes} = {};
            my $_ktype361 = 0;
            my $_vtype362 = 0;
            $xfer += $input->readMapBegin(\$_ktype361, \$_vtype362, \$_size360);
            for (my $_i364 = 0; $_i364 < $_size360; ++$_i364)
            {
              my $key365 = '';
              my $val366 = '';
              $xfer += $input->readString(\$key365);
              $xfer += $input->readString(\$val366);
              $self->{attributes}->{$key365} = $val366;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRowsTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{rowBatches}) {
      $xfer += $output->writeFieldBegin('rowBatches', Thrift::TType::LIST, 2);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{rowBatches}}));
        {
          foreach my $iter367 (@{$self->{rowBatches}})
          {
            $xfer += ${iter367}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter368,$viter369) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter368);
            $xfer += $output->writeString($viter369);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_mutateRowsTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_mutateRowsTs_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    $self->{ia} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
      if (defined $vals->{ia}) {
        $self->{ia} = $vals->{ia};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_mutateRowsTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{ia} = Hbase::IllegalArgument->new();
          $xfer += $self->{ia}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRowsTs_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ia}) {
      $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
      $xfer += $self->{ia}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_atomicIncrement_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_atomicIncrement_args->mk_accessors( qw( tableName row column value ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{column} = undef;
    $self->{value} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{column}) {
        $self->{column} = $vals->{column};
      }
      if (defined $vals->{value}) {
        $self->{value} = $vals->{value};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_atomicIncrement_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{column});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{value});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_atomicIncrement_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{column}) {
      $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{column});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{value}) {
      $xfer += $output->writeFieldBegin('value', Thrift::TType::I64, 4);
      $xfer += $output->writeI64($self->{value});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_atomicIncrement_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_atomicIncrement_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    $self->{ia} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
      if (defined $vals->{ia}) {
        $self->{ia} = $vals->{ia};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_atomicIncrement_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{success});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{ia} = Hbase::IllegalArgument->new();
          $xfer += $self->{ia}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_atomicIncrement_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
      $xfer += $output->writeI64($self->{success});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ia}) {
      $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
      $xfer += $self->{ia}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_deleteAll_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_deleteAll_args->mk_accessors( qw( tableName row column attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{column} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{column}) {
        $self->{column} = $vals->{column};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_deleteAll_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{column});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size370 = 0;
            $self->{attributes} = {};
            my $_ktype371 = 0;
            my $_vtype372 = 0;
            $xfer += $input->readMapBegin(\$_ktype371, \$_vtype372, \$_size370);
            for (my $_i374 = 0; $_i374 < $_size370; ++$_i374)
            {
              my $key375 = '';
              my $val376 = '';
              $xfer += $input->readString(\$key375);
              $xfer += $input->readString(\$val376);
              $self->{attributes}->{$key375} = $val376;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAll_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{column}) {
      $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{column});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter377,$viter378) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter377);
            $xfer += $output->writeString($viter378);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_deleteAll_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_deleteAll_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_deleteAll_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAll_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_deleteAllTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_deleteAllTs_args->mk_accessors( qw( tableName row column timestamp attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{column} = undef;
    $self->{timestamp} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{column}) {
        $self->{column} = $vals->{column};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_deleteAllTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{column});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size379 = 0;
            $self->{attributes} = {};
            my $_ktype380 = 0;
            my $_vtype381 = 0;
            $xfer += $input->readMapBegin(\$_ktype380, \$_vtype381, \$_size379);
            for (my $_i383 = 0; $_i383 < $_size379; ++$_i383)
            {
              my $key384 = '';
              my $val385 = '';
              $xfer += $input->readString(\$key384);
              $xfer += $input->readString(\$val385);
              $self->{attributes}->{$key384} = $val385;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{column}) {
      $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{column});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter386,$viter387) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter386);
            $xfer += $output->writeString($viter387);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_deleteAllTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_deleteAllTs_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_deleteAllTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllTs_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_deleteAllRow_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_deleteAllRow_args->mk_accessors( qw( tableName row attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_deleteAllRow_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size388 = 0;
            $self->{attributes} = {};
            my $_ktype389 = 0;
            my $_vtype390 = 0;
            $xfer += $input->readMapBegin(\$_ktype389, \$_vtype390, \$_size388);
            for (my $_i392 = 0; $_i392 < $_size388; ++$_i392)
            {
              my $key393 = '';
              my $val394 = '';
              $xfer += $input->readString(\$key393);
              $xfer += $input->readString(\$val394);
              $self->{attributes}->{$key393} = $val394;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllRow_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 3);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter395,$viter396) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter395);
            $xfer += $output->writeString($viter396);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_deleteAllRow_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_deleteAllRow_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_deleteAllRow_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllRow_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_increment_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_increment_args->mk_accessors( qw( increment ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{increment} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{increment}) {
        $self->{increment} = $vals->{increment};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_increment_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{increment} = Hbase::TIncrement->new();
          $xfer += $self->{increment}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_increment_args');
    if (defined $self->{increment}) {
      $xfer += $output->writeFieldBegin('increment', Thrift::TType::STRUCT, 1);
      $xfer += $self->{increment}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_increment_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_increment_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_increment_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_increment_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_incrementRows_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_incrementRows_args->mk_accessors( qw( increments ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{increments} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{increments}) {
        $self->{increments} = $vals->{increments};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_incrementRows_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size397 = 0;
            $self->{increments} = [];
            my $_etype400 = 0;
            $xfer += $input->readListBegin(\$_etype400, \$_size397);
            for (my $_i401 = 0; $_i401 < $_size397; ++$_i401)
            {
              my $elem402 = undef;
              $elem402 = Hbase::TIncrement->new();
              $xfer += $elem402->read($input);
              push(@{$self->{increments}},$elem402);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_incrementRows_args');
    if (defined $self->{increments}) {
      $xfer += $output->writeFieldBegin('increments', Thrift::TType::LIST, 1);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{increments}}));
        {
          foreach my $iter403 (@{$self->{increments}})
          {
            $xfer += ${iter403}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_incrementRows_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_incrementRows_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_incrementRows_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_incrementRows_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_deleteAllRowTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_deleteAllRowTs_args->mk_accessors( qw( tableName row timestamp attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{timestamp} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_deleteAllRowTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size404 = 0;
            $self->{attributes} = {};
            my $_ktype405 = 0;
            my $_vtype406 = 0;
            $xfer += $input->readMapBegin(\$_ktype405, \$_vtype406, \$_size404);
            for (my $_i408 = 0; $_i408 < $_size404; ++$_i408)
            {
              my $key409 = '';
              my $val410 = '';
              $xfer += $input->readString(\$key409);
              $xfer += $input->readString(\$val410);
              $self->{attributes}->{$key409} = $val410;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllRowTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter411,$viter412) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter411);
            $xfer += $output->writeString($viter412);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_deleteAllRowTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_deleteAllRowTs_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_deleteAllRowTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllRowTs_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpenWithScan_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpenWithScan_args->mk_accessors( qw( tableName scan attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{scan} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{scan}) {
        $self->{scan} = $vals->{scan};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpenWithScan_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{scan} = Hbase::TScan->new();
          $xfer += $self->{scan}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size413 = 0;
            $self->{attributes} = {};
            my $_ktype414 = 0;
            my $_vtype415 = 0;
            $xfer += $input->readMapBegin(\$_ktype414, \$_vtype415, \$_size413);
            for (my $_i417 = 0; $_i417 < $_size413; ++$_i417)
            {
              my $key418 = '';
              my $val419 = '';
              $xfer += $input->readString(\$key418);
              $xfer += $input->readString(\$val419);
              $self->{attributes}->{$key418} = $val419;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithScan_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{scan}) {
      $xfer += $output->writeFieldBegin('scan', Thrift::TType::STRUCT, 2);
      $xfer += $self->{scan}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 3);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter420,$viter421) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter420);
            $xfer += $output->writeString($viter421);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpenWithScan_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpenWithScan_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpenWithScan_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{success});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithScan_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
      $xfer += $output->writeI32($self->{success});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpen_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpen_args->mk_accessors( qw( tableName startRow columns attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{startRow} = undef;
    $self->{columns} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{startRow}) {
        $self->{startRow} = $vals->{startRow};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpen_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{startRow});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size422 = 0;
            $self->{columns} = [];
            my $_etype425 = 0;
            $xfer += $input->readListBegin(\$_etype425, \$_size422);
            for (my $_i426 = 0; $_i426 < $_size422; ++$_i426)
            {
              my $elem427 = undef;
              $xfer += $input->readString(\$elem427);
              push(@{$self->{columns}},$elem427);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size428 = 0;
            $self->{attributes} = {};
            my $_ktype429 = 0;
            my $_vtype430 = 0;
            $xfer += $input->readMapBegin(\$_ktype429, \$_vtype430, \$_size428);
            for (my $_i432 = 0; $_i432 < $_size428; ++$_i432)
            {
              my $key433 = '';
              my $val434 = '';
              $xfer += $input->readString(\$key433);
              $xfer += $input->readString(\$val434);
              $self->{attributes}->{$key433} = $val434;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpen_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{startRow}) {
      $xfer += $output->writeFieldBegin('startRow', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{startRow});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter435 (@{$self->{columns}})
          {
            $xfer += $output->writeString($iter435);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter436,$viter437) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter436);
            $xfer += $output->writeString($viter437);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpen_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpen_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpen_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{success});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpen_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
      $xfer += $output->writeI32($self->{success});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpenWithStop_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpenWithStop_args->mk_accessors( qw( tableName startRow stopRow columns attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{startRow} = undef;
    $self->{stopRow} = undef;
    $self->{columns} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{startRow}) {
        $self->{startRow} = $vals->{startRow};
      }
      if (defined $vals->{stopRow}) {
        $self->{stopRow} = $vals->{stopRow};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpenWithStop_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{startRow});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{stopRow});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size438 = 0;
            $self->{columns} = [];
            my $_etype441 = 0;
            $xfer += $input->readListBegin(\$_etype441, \$_size438);
            for (my $_i442 = 0; $_i442 < $_size438; ++$_i442)
            {
              my $elem443 = undef;
              $xfer += $input->readString(\$elem443);
              push(@{$self->{columns}},$elem443);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size444 = 0;
            $self->{attributes} = {};
            my $_ktype445 = 0;
            my $_vtype446 = 0;
            $xfer += $input->readMapBegin(\$_ktype445, \$_vtype446, \$_size444);
            for (my $_i448 = 0; $_i448 < $_size444; ++$_i448)
            {
              my $key449 = '';
              my $val450 = '';
              $xfer += $input->readString(\$key449);
              $xfer += $input->readString(\$val450);
              $self->{attributes}->{$key449} = $val450;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStop_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{startRow}) {
      $xfer += $output->writeFieldBegin('startRow', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{startRow});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{stopRow}) {
      $xfer += $output->writeFieldBegin('stopRow', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{stopRow});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 4);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter451 (@{$self->{columns}})
          {
            $xfer += $output->writeString($iter451);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter452,$viter453) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter452);
            $xfer += $output->writeString($viter453);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpenWithStop_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpenWithStop_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpenWithStop_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{success});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStop_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
      $xfer += $output->writeI32($self->{success});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpenWithPrefix_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpenWithPrefix_args->mk_accessors( qw( tableName startAndPrefix columns attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{startAndPrefix} = undef;
    $self->{columns} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{startAndPrefix}) {
        $self->{startAndPrefix} = $vals->{startAndPrefix};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpenWithPrefix_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{startAndPrefix});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size454 = 0;
            $self->{columns} = [];
            my $_etype457 = 0;
            $xfer += $input->readListBegin(\$_etype457, \$_size454);
            for (my $_i458 = 0; $_i458 < $_size454; ++$_i458)
            {
              my $elem459 = undef;
              $xfer += $input->readString(\$elem459);
              push(@{$self->{columns}},$elem459);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size460 = 0;
            $self->{attributes} = {};
            my $_ktype461 = 0;
            my $_vtype462 = 0;
            $xfer += $input->readMapBegin(\$_ktype461, \$_vtype462, \$_size460);
            for (my $_i464 = 0; $_i464 < $_size460; ++$_i464)
            {
              my $key465 = '';
              my $val466 = '';
              $xfer += $input->readString(\$key465);
              $xfer += $input->readString(\$val466);
              $self->{attributes}->{$key465} = $val466;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithPrefix_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{startAndPrefix}) {
      $xfer += $output->writeFieldBegin('startAndPrefix', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{startAndPrefix});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter467 (@{$self->{columns}})
          {
            $xfer += $output->writeString($iter467);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter468,$viter469) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter468);
            $xfer += $output->writeString($viter469);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpenWithPrefix_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpenWithPrefix_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpenWithPrefix_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{success});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithPrefix_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
      $xfer += $output->writeI32($self->{success});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpenTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpenTs_args->mk_accessors( qw( tableName startRow columns timestamp attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{startRow} = undef;
    $self->{columns} = undef;
    $self->{timestamp} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{startRow}) {
        $self->{startRow} = $vals->{startRow};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpenTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{startRow});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size470 = 0;
            $self->{columns} = [];
            my $_etype473 = 0;
            $xfer += $input->readListBegin(\$_etype473, \$_size470);
            for (my $_i474 = 0; $_i474 < $_size470; ++$_i474)
            {
              my $elem475 = undef;
              $xfer += $input->readString(\$elem475);
              push(@{$self->{columns}},$elem475);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size476 = 0;
            $self->{attributes} = {};
            my $_ktype477 = 0;
            my $_vtype478 = 0;
            $xfer += $input->readMapBegin(\$_ktype477, \$_vtype478, \$_size476);
            for (my $_i480 = 0; $_i480 < $_size476; ++$_i480)
            {
              my $key481 = '';
              my $val482 = '';
              $xfer += $input->readString(\$key481);
              $xfer += $input->readString(\$val482);
              $self->{attributes}->{$key481} = $val482;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{startRow}) {
      $xfer += $output->writeFieldBegin('startRow', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{startRow});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter483 (@{$self->{columns}})
          {
            $xfer += $output->writeString($iter483);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter484,$viter485) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter484);
            $xfer += $output->writeString($viter485);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpenTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpenTs_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpenTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{success});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenTs_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
      $xfer += $output->writeI32($self->{success});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpenWithStopTs_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpenWithStopTs_args->mk_accessors( qw( tableName startRow stopRow columns timestamp attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{startRow} = undef;
    $self->{stopRow} = undef;
    $self->{columns} = undef;
    $self->{timestamp} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{startRow}) {
        $self->{startRow} = $vals->{startRow};
      }
      if (defined $vals->{stopRow}) {
        $self->{stopRow} = $vals->{stopRow};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpenWithStopTs_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{startRow});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{stopRow});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size486 = 0;
            $self->{columns} = [];
            my $_etype489 = 0;
            $xfer += $input->readListBegin(\$_etype489, \$_size486);
            for (my $_i490 = 0; $_i490 < $_size486; ++$_i490)
            {
              my $elem491 = undef;
              $xfer += $input->readString(\$elem491);
              push(@{$self->{columns}},$elem491);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^6$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size492 = 0;
            $self->{attributes} = {};
            my $_ktype493 = 0;
            my $_vtype494 = 0;
            $xfer += $input->readMapBegin(\$_ktype493, \$_vtype494, \$_size492);
            for (my $_i496 = 0; $_i496 < $_size492; ++$_i496)
            {
              my $key497 = '';
              my $val498 = '';
              $xfer += $input->readString(\$key497);
              $xfer += $input->readString(\$val498);
              $self->{attributes}->{$key497} = $val498;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopTs_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{startRow}) {
      $xfer += $output->writeFieldBegin('startRow', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{startRow});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{stopRow}) {
      $xfer += $output->writeFieldBegin('stopRow', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{stopRow});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 4);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter499 (@{$self->{columns}})
          {
            $xfer += $output->writeString($iter499);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 5);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 6);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter500,$viter501) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter500);
            $xfer += $output->writeString($viter501);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerOpenWithStopTs_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerOpenWithStopTs_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerOpenWithStopTs_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{success});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopTs_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
      $xfer += $output->writeI32($self->{success});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerGet_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerGet_args->mk_accessors( qw( id ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{id} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{id}) {
        $self->{id} = $vals->{id};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerGet_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{id});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerGet_args');
    if (defined $self->{id}) {
      $xfer += $output->writeFieldBegin('id', Thrift::TType::I32, 1);
      $xfer += $output->writeI32($self->{id});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerGet_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerGet_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    $self->{ia} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
      if (defined $vals->{ia}) {
        $self->{ia} = $vals->{ia};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerGet_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size502 = 0;
            $self->{success} = [];
            my $_etype505 = 0;
            $xfer += $input->readListBegin(\$_etype505, \$_size502);
            for (my $_i506 = 0; $_i506 < $_size502; ++$_i506)
            {
              my $elem507 = undef;
              $elem507 = Hbase::TRowResult->new();
              $xfer += $elem507->read($input);
              push(@{$self->{success}},$elem507);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{ia} = Hbase::IllegalArgument->new();
          $xfer += $self->{ia}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerGet_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter508 (@{$self->{success}})
          {
            $xfer += ${iter508}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ia}) {
      $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
      $xfer += $self->{ia}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerGetList_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerGetList_args->mk_accessors( qw( id nbRows ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{id} = undef;
    $self->{nbRows} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{id}) {
        $self->{id} = $vals->{id};
      }
      if (defined $vals->{nbRows}) {
        $self->{nbRows} = $vals->{nbRows};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerGetList_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{id});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{nbRows});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerGetList_args');
    if (defined $self->{id}) {
      $xfer += $output->writeFieldBegin('id', Thrift::TType::I32, 1);
      $xfer += $output->writeI32($self->{id});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{nbRows}) {
      $xfer += $output->writeFieldBegin('nbRows', Thrift::TType::I32, 2);
      $xfer += $output->writeI32($self->{nbRows});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerGetList_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerGetList_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    $self->{ia} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
      if (defined $vals->{ia}) {
        $self->{ia} = $vals->{ia};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerGetList_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size509 = 0;
            $self->{success} = [];
            my $_etype512 = 0;
            $xfer += $input->readListBegin(\$_etype512, \$_size509);
            for (my $_i513 = 0; $_i513 < $_size509; ++$_i513)
            {
              my $elem514 = undef;
              $elem514 = Hbase::TRowResult->new();
              $xfer += $elem514->read($input);
              push(@{$self->{success}},$elem514);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{ia} = Hbase::IllegalArgument->new();
          $xfer += $self->{ia}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerGetList_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter515 (@{$self->{success}})
          {
            $xfer += ${iter515}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ia}) {
      $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
      $xfer += $self->{ia}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerClose_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerClose_args->mk_accessors( qw( id ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{id} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{id}) {
        $self->{id} = $vals->{id};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerClose_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{id});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerClose_args');
    if (defined $self->{id}) {
      $xfer += $output->writeFieldBegin('id', Thrift::TType::I32, 1);
      $xfer += $output->writeI32($self->{id});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_scannerClose_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_scannerClose_result->mk_accessors( qw( ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{io} = undef;
    $self->{ia} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
      if (defined $vals->{ia}) {
        $self->{ia} = $vals->{ia};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_scannerClose_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{ia} = Hbase::IllegalArgument->new();
          $xfer += $self->{ia}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerClose_result');
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ia}) {
      $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
      $xfer += $self->{ia}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRegionInfo_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRegionInfo_args->mk_accessors( qw( row ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{row} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRegionInfo_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRegionInfo_args');
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_getRegionInfo_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_getRegionInfo_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_getRegionInfo_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{success} = Hbase::TRegionInfo->new();
          $xfer += $self->{success}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_getRegionInfo_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
      $xfer += $self->{success}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_append_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_append_args->mk_accessors( qw( append ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{append} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{append}) {
        $self->{append} = $vals->{append};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_append_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{append} = Hbase::TAppend->new();
          $xfer += $self->{append}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_append_args');
    if (defined $self->{append}) {
      $xfer += $output->writeFieldBegin('append', Thrift::TType::STRUCT, 1);
      $xfer += $self->{append}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_append_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_append_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_append_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size516 = 0;
            $self->{success} = [];
            my $_etype519 = 0;
            $xfer += $input->readListBegin(\$_etype519, \$_size516);
            for (my $_i520 = 0; $_i520 < $_size516; ++$_i520)
            {
              my $elem521 = undef;
              $elem521 = Hbase::TCell->new();
              $xfer += $elem521->read($input);
              push(@{$self->{success}},$elem521);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_append_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
        {
          foreach my $iter522 (@{$self->{success}})
          {
            $xfer += ${iter522}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_checkAndPut_args;
  use base qw(Class::Accessor);
  Hbase::Hbase_checkAndPut_args->mk_accessors( qw( tableName row column value mput attributes ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{tableName} = undef;
    $self->{row} = undef;
    $self->{column} = undef;
    $self->{value} = undef;
    $self->{mput} = undef;
    $self->{attributes} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{tableName}) {
        $self->{tableName} = $vals->{tableName};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{column}) {
        $self->{column} = $vals->{column};
      }
      if (defined $vals->{value}) {
        $self->{value} = $vals->{value};
      }
      if (defined $vals->{mput}) {
        $self->{mput} = $vals->{mput};
      }
      if (defined $vals->{attributes}) {
        $self->{attributes} = $vals->{attributes};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_checkAndPut_args';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{tableName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{column});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{value});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^6$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{mput} = Hbase::Mutation->new();
          $xfer += $self->{mput}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^7$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size523 = 0;
            $self->{attributes} = {};
            my $_ktype524 = 0;
            my $_vtype525 = 0;
            $xfer += $input->readMapBegin(\$_ktype524, \$_vtype525, \$_size523);
            for (my $_i527 = 0; $_i527 < $_size523; ++$_i527)
            {
              my $key528 = '';
              my $val529 = '';
              $xfer += $input->readString(\$key528);
              $xfer += $input->readString(\$val529);
              $self->{attributes}->{$key528} = $val529;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_checkAndPut_args');
    if (defined $self->{tableName}) {
      $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{tableName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{column}) {
      $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{column});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{value}) {
      $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 5);
      $xfer += $output->writeString($self->{value});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{mput}) {
      $xfer += $output->writeFieldBegin('mput', Thrift::TType::STRUCT, 6);
      $xfer += $self->{mput}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{attributes}) {
      $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 7);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
        {
          while( my ($kiter530,$viter531) = each %{$self->{attributes}})
          {
            $xfer += $output->writeString($kiter530);
            $xfer += $output->writeString($viter531);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Hbase_checkAndPut_result;
  use base qw(Class::Accessor);
  Hbase::Hbase_checkAndPut_result->mk_accessors( qw( success ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{success} = undef;
    $self->{io} = undef;
    $self->{ia} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{success}) {
        $self->{success} = $vals->{success};
      }
      if (defined $vals->{io}) {
        $self->{io} = $vals->{io};
      }
      if (defined $vals->{ia}) {
        $self->{ia} = $vals->{ia};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Hbase_checkAndPut_result';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
          $xfer += $input->readBool(\$self->{success});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{io} = Hbase::IOError->new();
          $xfer += $self->{io}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{ia} = Hbase::IllegalArgument->new();
          $xfer += $self->{ia}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Hbase_checkAndPut_result');
    if (defined $self->{success}) {
      $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
      $xfer += $output->writeBool($self->{success});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{io}) {
      $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
      $xfer += $self->{io}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ia}) {
      $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
      $xfer += $self->{ia}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::HbaseIf;
  
  #use strict;
  
  
  sub enableTable{
    my $self = shift;
    my $tableName = shift;
  
    die 'implement interface';
  }
  
  sub disableTable{
    my $self = shift;
    my $tableName = shift;
  
    die 'implement interface';
  }
  
  sub isTableEnabled{
    my $self = shift;
    my $tableName = shift;
  
    die 'implement interface';
  }
  
  sub compact{
    my $self = shift;
    my $tableNameOrRegionName = shift;
  
    die 'implement interface';
  }
  
  sub majorCompact{
    my $self = shift;
    my $tableNameOrRegionName = shift;
  
    die 'implement interface';
  }
  
  sub getTableNames{
    my $self = shift;
  
    die 'implement interface';
  }
  
  sub getColumnDescriptors{
    my $self = shift;
    my $tableName = shift;
  
    die 'implement interface';
  }
  
  sub getTableRegions{
    my $self = shift;
    my $tableName = shift;
  
    die 'implement interface';
  }
  
  sub createTable{
    my $self = shift;
    my $tableName = shift;
    my $columnFamilies = shift;
  
    die 'implement interface';
  }
  
  sub deleteTable{
    my $self = shift;
    my $tableName = shift;
  
    die 'implement interface';
  }
  
  sub get{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub getVer{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $numVersions = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub getVerTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $timestamp = shift;
    my $numVersions = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub getRow{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub getRowWithColumns{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $columns = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub getRowTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub getRowWithColumnsTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub getRows{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub getRowsWithColumns{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $columns = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub getRowsTs{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub getRowsWithColumnsTs{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub mutateRow{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $mutations = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub mutateRowTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $mutations = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub mutateRows{
    my $self = shift;
    my $tableName = shift;
    my $rowBatches = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub mutateRowsTs{
    my $self = shift;
    my $tableName = shift;
    my $rowBatches = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub atomicIncrement{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $value = shift;
  
    die 'implement interface';
  }
  
  sub deleteAll{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub deleteAllTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub deleteAllRow{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub increment{
    my $self = shift;
    my $increment = shift;
  
    die 'implement interface';
  }
  
  sub incrementRows{
    my $self = shift;
    my $increments = shift;
  
    die 'implement interface';
  }
  
  sub deleteAllRowTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub scannerOpenWithScan{
    my $self = shift;
    my $tableName = shift;
    my $scan = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub scannerOpen{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $columns = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub scannerOpenWithStop{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $stopRow = shift;
    my $columns = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub scannerOpenWithPrefix{
    my $self = shift;
    my $tableName = shift;
    my $startAndPrefix = shift;
    my $columns = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub scannerOpenTs{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub scannerOpenWithStopTs{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $stopRow = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  sub scannerGet{
    my $self = shift;
    my $id = shift;
  
    die 'implement interface';
  }
  
  sub scannerGetList{
    my $self = shift;
    my $id = shift;
    my $nbRows = shift;
  
    die 'implement interface';
  }
  
  sub scannerClose{
    my $self = shift;
    my $id = shift;
  
    die 'implement interface';
  }
  
  sub getRegionInfo{
    my $self = shift;
    my $row = shift;
  
    die 'implement interface';
  }
  
  sub append{
    my $self = shift;
    my $append = shift;
  
    die 'implement interface';
  }
  
  sub checkAndPut{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $value = shift;
    my $mput = shift;
    my $attributes = shift;
  
    die 'implement interface';
  }
  
  package Hbase::HbaseRest;
  
  #use strict;
  
  
  sub new {
    my ($classname, $impl) = @_;
    my $self     ={ impl => $impl };
  
    return bless($self,$classname);
  }
  
  sub enableTable{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    return $self->{impl}->enableTable($tableName);
  }
  
  sub disableTable{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    return $self->{impl}->disableTable($tableName);
  }
  
  sub isTableEnabled{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    return $self->{impl}->isTableEnabled($tableName);
  }
  
  sub compact{
    my ($self, $request) = @_;
  
    my $tableNameOrRegionName = ($request->{'tableNameOrRegionName'}) ? $request->{'tableNameOrRegionName'} : undef;
    return $self->{impl}->compact($tableNameOrRegionName);
  }
  
  sub majorCompact{
    my ($self, $request) = @_;
  
    my $tableNameOrRegionName = ($request->{'tableNameOrRegionName'}) ? $request->{'tableNameOrRegionName'} : undef;
    return $self->{impl}->majorCompact($tableNameOrRegionName);
  }
  
  sub getTableNames{
    my ($self, $request) = @_;
  
    return $self->{impl}->getTableNames();
  }
  
  sub getColumnDescriptors{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    return $self->{impl}->getColumnDescriptors($tableName);
  }
  
  sub getTableRegions{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    return $self->{impl}->getTableRegions($tableName);
  }
  
  sub createTable{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $columnFamilies = ($request->{'columnFamilies'}) ? $request->{'columnFamilies'} : undef;
    return $self->{impl}->createTable($tableName, $columnFamilies);
  }
  
  sub deleteTable{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    return $self->{impl}->deleteTable($tableName);
  }
  
  sub get{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $column = ($request->{'column'}) ? $request->{'column'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->get($tableName, $row, $column, $attributes);
  }
  
  sub getVer{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $column = ($request->{'column'}) ? $request->{'column'} : undef;
    my $numVersions = ($request->{'numVersions'}) ? $request->{'numVersions'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->getVer($tableName, $row, $column, $numVersions, $attributes);
  }
  
  sub getVerTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $column = ($request->{'column'}) ? $request->{'column'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $numVersions = ($request->{'numVersions'}) ? $request->{'numVersions'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->getVerTs($tableName, $row, $column, $timestamp, $numVersions, $attributes);
  }
  
  sub getRow{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->getRow($tableName, $row, $attributes);
  }
  
  sub getRowWithColumns{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->getRowWithColumns($tableName, $row, $columns, $attributes);
  }
  
  sub getRowTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->getRowTs($tableName, $row, $timestamp, $attributes);
  }
  
  sub getRowWithColumnsTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->getRowWithColumnsTs($tableName, $row, $columns, $timestamp, $attributes);
  }
  
  sub getRows{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->getRows($tableName, $rows, $attributes);
  }
  
  sub getRowsWithColumns{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
    my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->getRowsWithColumns($tableName, $rows, $columns, $attributes);
  }
  
  sub getRowsTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->getRowsTs($tableName, $rows, $timestamp, $attributes);
  }
  
  sub getRowsWithColumnsTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
    my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->getRowsWithColumnsTs($tableName, $rows, $columns, $timestamp, $attributes);
  }
  
  sub mutateRow{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->mutateRow($tableName, $row, $mutations, $attributes);
  }
  
  sub mutateRowTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->mutateRowTs($tableName, $row, $mutations, $timestamp, $attributes);
  }
  
  sub mutateRows{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $rowBatches = ($request->{'rowBatches'}) ? $request->{'rowBatches'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->mutateRows($tableName, $rowBatches, $attributes);
  }
  
  sub mutateRowsTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $rowBatches = ($request->{'rowBatches'}) ? $request->{'rowBatches'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->mutateRowsTs($tableName, $rowBatches, $timestamp, $attributes);
  }
  
  sub atomicIncrement{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $column = ($request->{'column'}) ? $request->{'column'} : undef;
    my $value = ($request->{'value'}) ? $request->{'value'} : undef;
    return $self->{impl}->atomicIncrement($tableName, $row, $column, $value);
  }
  
  sub deleteAll{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $column = ($request->{'column'}) ? $request->{'column'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->deleteAll($tableName, $row, $column, $attributes);
  }
  
  sub deleteAllTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $column = ($request->{'column'}) ? $request->{'column'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->deleteAllTs($tableName, $row, $column, $timestamp, $attributes);
  }
  
  sub deleteAllRow{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->deleteAllRow($tableName, $row, $attributes);
  }
  
  sub increment{
    my ($self, $request) = @_;
  
    my $increment = ($request->{'increment'}) ? $request->{'increment'} : undef;
    return $self->{impl}->increment($increment);
  }
  
  sub incrementRows{
    my ($self, $request) = @_;
  
    my $increments = ($request->{'increments'}) ? $request->{'increments'} : undef;
    return $self->{impl}->incrementRows($increments);
  }
  
  sub deleteAllRowTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->deleteAllRowTs($tableName, $row, $timestamp, $attributes);
  }
  
  sub scannerOpenWithScan{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $scan = ($request->{'scan'}) ? $request->{'scan'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->scannerOpenWithScan($tableName, $scan, $attributes);
  }
  
  sub scannerOpen{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
    my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->scannerOpen($tableName, $startRow, $columns, $attributes);
  }
  
  sub scannerOpenWithStop{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
    my $stopRow = ($request->{'stopRow'}) ? $request->{'stopRow'} : undef;
    my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->scannerOpenWithStop($tableName, $startRow, $stopRow, $columns, $attributes);
  }
  
  sub scannerOpenWithPrefix{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $startAndPrefix = ($request->{'startAndPrefix'}) ? $request->{'startAndPrefix'} : undef;
    my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->scannerOpenWithPrefix($tableName, $startAndPrefix, $columns, $attributes);
  }
  
  sub scannerOpenTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
    my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->scannerOpenTs($tableName, $startRow, $columns, $timestamp, $attributes);
  }
  
  sub scannerOpenWithStopTs{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
    my $stopRow = ($request->{'stopRow'}) ? $request->{'stopRow'} : undef;
    my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
    my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp, $attributes);
  }
  
  sub scannerGet{
    my ($self, $request) = @_;
  
    my $id = ($request->{'id'}) ? $request->{'id'} : undef;
    return $self->{impl}->scannerGet($id);
  }
  
  sub scannerGetList{
    my ($self, $request) = @_;
  
    my $id = ($request->{'id'}) ? $request->{'id'} : undef;
    my $nbRows = ($request->{'nbRows'}) ? $request->{'nbRows'} : undef;
    return $self->{impl}->scannerGetList($id, $nbRows);
  }
  
  sub scannerClose{
    my ($self, $request) = @_;
  
    my $id = ($request->{'id'}) ? $request->{'id'} : undef;
    return $self->{impl}->scannerClose($id);
  }
  
  sub getRegionInfo{
    my ($self, $request) = @_;
  
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    return $self->{impl}->getRegionInfo($row);
  }
  
  sub append{
    my ($self, $request) = @_;
  
    my $append = ($request->{'append'}) ? $request->{'append'} : undef;
    return $self->{impl}->append($append);
  }
  
  sub checkAndPut{
    my ($self, $request) = @_;
  
    my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
    my $row = ($request->{'row'}) ? $request->{'row'} : undef;
    my $column = ($request->{'column'}) ? $request->{'column'} : undef;
    my $value = ($request->{'value'}) ? $request->{'value'} : undef;
    my $mput = ($request->{'mput'}) ? $request->{'mput'} : undef;
    my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
    return $self->{impl}->checkAndPut($tableName, $row, $column, $value, $mput, $attributes);
  }
  
  package Hbase::HbaseClient;
  
  
  use base qw(Hbase::HbaseIf);
  sub new {
    my ($classname, $input, $output) = @_;
    my $self      = {};
    $self->{input}  = $input;
    $self->{output} = defined $output ? $output : $input;
    $self->{seqid}  = 0;
    return bless($self,$classname);
  }
  
  sub enableTable{
    my $self = shift;
    my $tableName = shift;
  
      $self->send_enableTable($tableName);
    $self->recv_enableTable();
  }
  
  sub send_enableTable{
    my $self = shift;
    my $tableName = shift;
  
    $self->{output}->writeMessageBegin('enableTable', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_enableTable_args->new();
    $args->{tableName} = $tableName;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_enableTable{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_enableTable_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub disableTable{
    my $self = shift;
    my $tableName = shift;
  
      $self->send_disableTable($tableName);
    $self->recv_disableTable();
  }
  
  sub send_disableTable{
    my $self = shift;
    my $tableName = shift;
  
    $self->{output}->writeMessageBegin('disableTable', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_disableTable_args->new();
    $args->{tableName} = $tableName;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_disableTable{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_disableTable_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub isTableEnabled{
    my $self = shift;
    my $tableName = shift;
  
      $self->send_isTableEnabled($tableName);
    return $self->recv_isTableEnabled();
  }
  
  sub send_isTableEnabled{
    my $self = shift;
    my $tableName = shift;
  
    $self->{output}->writeMessageBegin('isTableEnabled', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_isTableEnabled_args->new();
    $args->{tableName} = $tableName;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_isTableEnabled{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_isTableEnabled_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "isTableEnabled failed: unknown result";
  }
  sub compact{
    my $self = shift;
    my $tableNameOrRegionName = shift;
  
      $self->send_compact($tableNameOrRegionName);
    $self->recv_compact();
  }
  
  sub send_compact{
    my $self = shift;
    my $tableNameOrRegionName = shift;
  
    $self->{output}->writeMessageBegin('compact', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_compact_args->new();
    $args->{tableNameOrRegionName} = $tableNameOrRegionName;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_compact{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_compact_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub majorCompact{
    my $self = shift;
    my $tableNameOrRegionName = shift;
  
      $self->send_majorCompact($tableNameOrRegionName);
    $self->recv_majorCompact();
  }
  
  sub send_majorCompact{
    my $self = shift;
    my $tableNameOrRegionName = shift;
  
    $self->{output}->writeMessageBegin('majorCompact', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_majorCompact_args->new();
    $args->{tableNameOrRegionName} = $tableNameOrRegionName;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_majorCompact{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_majorCompact_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub getTableNames{
    my $self = shift;
  
      $self->send_getTableNames();
    return $self->recv_getTableNames();
  }
  
  sub send_getTableNames{
    my $self = shift;
  
    $self->{output}->writeMessageBegin('getTableNames', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getTableNames_args->new();
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getTableNames{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getTableNames_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getTableNames failed: unknown result";
  }
  sub getColumnDescriptors{
    my $self = shift;
    my $tableName = shift;
  
      $self->send_getColumnDescriptors($tableName);
    return $self->recv_getColumnDescriptors();
  }
  
  sub send_getColumnDescriptors{
    my $self = shift;
    my $tableName = shift;
  
    $self->{output}->writeMessageBegin('getColumnDescriptors', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getColumnDescriptors_args->new();
    $args->{tableName} = $tableName;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getColumnDescriptors{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getColumnDescriptors_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getColumnDescriptors failed: unknown result";
  }
  sub getTableRegions{
    my $self = shift;
    my $tableName = shift;
  
      $self->send_getTableRegions($tableName);
    return $self->recv_getTableRegions();
  }
  
  sub send_getTableRegions{
    my $self = shift;
    my $tableName = shift;
  
    $self->{output}->writeMessageBegin('getTableRegions', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getTableRegions_args->new();
    $args->{tableName} = $tableName;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getTableRegions{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getTableRegions_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getTableRegions failed: unknown result";
  }
  sub createTable{
    my $self = shift;
    my $tableName = shift;
    my $columnFamilies = shift;
  
      $self->send_createTable($tableName, $columnFamilies);
    $self->recv_createTable();
  }
  
  sub send_createTable{
    my $self = shift;
    my $tableName = shift;
    my $columnFamilies = shift;
  
    $self->{output}->writeMessageBegin('createTable', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_createTable_args->new();
    $args->{tableName} = $tableName;
    $args->{columnFamilies} = $columnFamilies;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_createTable{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_createTable_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    if (defined $result->{ia}) {
      die $result->{ia};
    }
    if (defined $result->{exist}) {
      die $result->{exist};
    }
    return;
  }
  sub deleteTable{
    my $self = shift;
    my $tableName = shift;
  
      $self->send_deleteTable($tableName);
    $self->recv_deleteTable();
  }
  
  sub send_deleteTable{
    my $self = shift;
    my $tableName = shift;
  
    $self->{output}->writeMessageBegin('deleteTable', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_deleteTable_args->new();
    $args->{tableName} = $tableName;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_deleteTable{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_deleteTable_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub get{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $attributes = shift;
  
      $self->send_get($tableName, $row, $column, $attributes);
    return $self->recv_get();
  }
  
  sub send_get{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('get', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_get_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{column} = $column;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_get{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_get_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "get failed: unknown result";
  }
  sub getVer{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $numVersions = shift;
    my $attributes = shift;
  
      $self->send_getVer($tableName, $row, $column, $numVersions, $attributes);
    return $self->recv_getVer();
  }
  
  sub send_getVer{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $numVersions = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('getVer', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getVer_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{column} = $column;
    $args->{numVersions} = $numVersions;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getVer{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getVer_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getVer failed: unknown result";
  }
  sub getVerTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $timestamp = shift;
    my $numVersions = shift;
    my $attributes = shift;
  
      $self->send_getVerTs($tableName, $row, $column, $timestamp, $numVersions, $attributes);
    return $self->recv_getVerTs();
  }
  
  sub send_getVerTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $timestamp = shift;
    my $numVersions = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('getVerTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getVerTs_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{column} = $column;
    $args->{timestamp} = $timestamp;
    $args->{numVersions} = $numVersions;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getVerTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getVerTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getVerTs failed: unknown result";
  }
  sub getRow{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $attributes = shift;
  
      $self->send_getRow($tableName, $row, $attributes);
    return $self->recv_getRow();
  }
  
  sub send_getRow{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('getRow', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getRow_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getRow{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getRow_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getRow failed: unknown result";
  }
  sub getRowWithColumns{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $columns = shift;
    my $attributes = shift;
  
      $self->send_getRowWithColumns($tableName, $row, $columns, $attributes);
    return $self->recv_getRowWithColumns();
  }
  
  sub send_getRowWithColumns{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $columns = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('getRowWithColumns', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getRowWithColumns_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{columns} = $columns;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getRowWithColumns{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getRowWithColumns_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getRowWithColumns failed: unknown result";
  }
  sub getRowTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
      $self->send_getRowTs($tableName, $row, $timestamp, $attributes);
    return $self->recv_getRowTs();
  }
  
  sub send_getRowTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('getRowTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getRowTs_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{timestamp} = $timestamp;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getRowTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getRowTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getRowTs failed: unknown result";
  }
  sub getRowWithColumnsTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
      $self->send_getRowWithColumnsTs($tableName, $row, $columns, $timestamp, $attributes);
    return $self->recv_getRowWithColumnsTs();
  }
  
  sub send_getRowWithColumnsTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('getRowWithColumnsTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getRowWithColumnsTs_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{columns} = $columns;
    $args->{timestamp} = $timestamp;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getRowWithColumnsTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getRowWithColumnsTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getRowWithColumnsTs failed: unknown result";
  }
  sub getRows{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $attributes = shift;
  
      $self->send_getRows($tableName, $rows, $attributes);
    return $self->recv_getRows();
  }
  
  sub send_getRows{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('getRows', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getRows_args->new();
    $args->{tableName} = $tableName;
    $args->{rows} = $rows;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getRows{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getRows_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getRows failed: unknown result";
  }
  sub getRowsWithColumns{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $columns = shift;
    my $attributes = shift;
  
      $self->send_getRowsWithColumns($tableName, $rows, $columns, $attributes);
    return $self->recv_getRowsWithColumns();
  }
  
  sub send_getRowsWithColumns{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $columns = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('getRowsWithColumns', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getRowsWithColumns_args->new();
    $args->{tableName} = $tableName;
    $args->{rows} = $rows;
    $args->{columns} = $columns;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getRowsWithColumns{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getRowsWithColumns_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getRowsWithColumns failed: unknown result";
  }
  sub getRowsTs{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
      $self->send_getRowsTs($tableName, $rows, $timestamp, $attributes);
    return $self->recv_getRowsTs();
  }
  
  sub send_getRowsTs{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('getRowsTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getRowsTs_args->new();
    $args->{tableName} = $tableName;
    $args->{rows} = $rows;
    $args->{timestamp} = $timestamp;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getRowsTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getRowsTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getRowsTs failed: unknown result";
  }
  sub getRowsWithColumnsTs{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
      $self->send_getRowsWithColumnsTs($tableName, $rows, $columns, $timestamp, $attributes);
    return $self->recv_getRowsWithColumnsTs();
  }
  
  sub send_getRowsWithColumnsTs{
    my $self = shift;
    my $tableName = shift;
    my $rows = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('getRowsWithColumnsTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getRowsWithColumnsTs_args->new();
    $args->{tableName} = $tableName;
    $args->{rows} = $rows;
    $args->{columns} = $columns;
    $args->{timestamp} = $timestamp;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getRowsWithColumnsTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getRowsWithColumnsTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getRowsWithColumnsTs failed: unknown result";
  }
  sub mutateRow{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $mutations = shift;
    my $attributes = shift;
  
      $self->send_mutateRow($tableName, $row, $mutations, $attributes);
    $self->recv_mutateRow();
  }
  
  sub send_mutateRow{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $mutations = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('mutateRow', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_mutateRow_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{mutations} = $mutations;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_mutateRow{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_mutateRow_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    if (defined $result->{ia}) {
      die $result->{ia};
    }
    return;
  }
  sub mutateRowTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $mutations = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
      $self->send_mutateRowTs($tableName, $row, $mutations, $timestamp, $attributes);
    $self->recv_mutateRowTs();
  }
  
  sub send_mutateRowTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $mutations = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('mutateRowTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_mutateRowTs_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{mutations} = $mutations;
    $args->{timestamp} = $timestamp;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_mutateRowTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_mutateRowTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    if (defined $result->{ia}) {
      die $result->{ia};
    }
    return;
  }
  sub mutateRows{
    my $self = shift;
    my $tableName = shift;
    my $rowBatches = shift;
    my $attributes = shift;
  
      $self->send_mutateRows($tableName, $rowBatches, $attributes);
    $self->recv_mutateRows();
  }
  
  sub send_mutateRows{
    my $self = shift;
    my $tableName = shift;
    my $rowBatches = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('mutateRows', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_mutateRows_args->new();
    $args->{tableName} = $tableName;
    $args->{rowBatches} = $rowBatches;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_mutateRows{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_mutateRows_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    if (defined $result->{ia}) {
      die $result->{ia};
    }
    return;
  }
  sub mutateRowsTs{
    my $self = shift;
    my $tableName = shift;
    my $rowBatches = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
      $self->send_mutateRowsTs($tableName, $rowBatches, $timestamp, $attributes);
    $self->recv_mutateRowsTs();
  }
  
  sub send_mutateRowsTs{
    my $self = shift;
    my $tableName = shift;
    my $rowBatches = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('mutateRowsTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_mutateRowsTs_args->new();
    $args->{tableName} = $tableName;
    $args->{rowBatches} = $rowBatches;
    $args->{timestamp} = $timestamp;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_mutateRowsTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_mutateRowsTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    if (defined $result->{ia}) {
      die $result->{ia};
    }
    return;
  }
  sub atomicIncrement{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $value = shift;
  
      $self->send_atomicIncrement($tableName, $row, $column, $value);
    return $self->recv_atomicIncrement();
  }
  
  sub send_atomicIncrement{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $value = shift;
  
    $self->{output}->writeMessageBegin('atomicIncrement', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_atomicIncrement_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{column} = $column;
    $args->{value} = $value;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_atomicIncrement{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_atomicIncrement_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    if (defined $result->{ia}) {
      die $result->{ia};
    }
    die "atomicIncrement failed: unknown result";
  }
  sub deleteAll{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $attributes = shift;
  
      $self->send_deleteAll($tableName, $row, $column, $attributes);
    $self->recv_deleteAll();
  }
  
  sub send_deleteAll{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('deleteAll', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_deleteAll_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{column} = $column;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_deleteAll{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_deleteAll_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub deleteAllTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
      $self->send_deleteAllTs($tableName, $row, $column, $timestamp, $attributes);
    $self->recv_deleteAllTs();
  }
  
  sub send_deleteAllTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('deleteAllTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_deleteAllTs_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{column} = $column;
    $args->{timestamp} = $timestamp;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_deleteAllTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_deleteAllTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub deleteAllRow{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $attributes = shift;
  
      $self->send_deleteAllRow($tableName, $row, $attributes);
    $self->recv_deleteAllRow();
  }
  
  sub send_deleteAllRow{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('deleteAllRow', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_deleteAllRow_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_deleteAllRow{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_deleteAllRow_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub increment{
    my $self = shift;
    my $increment = shift;
  
      $self->send_increment($increment);
    $self->recv_increment();
  }
  
  sub send_increment{
    my $self = shift;
    my $increment = shift;
  
    $self->{output}->writeMessageBegin('increment', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_increment_args->new();
    $args->{increment} = $increment;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_increment{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_increment_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub incrementRows{
    my $self = shift;
    my $increments = shift;
  
      $self->send_incrementRows($increments);
    $self->recv_incrementRows();
  }
  
  sub send_incrementRows{
    my $self = shift;
    my $increments = shift;
  
    $self->{output}->writeMessageBegin('incrementRows', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_incrementRows_args->new();
    $args->{increments} = $increments;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_incrementRows{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_incrementRows_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub deleteAllRowTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
      $self->send_deleteAllRowTs($tableName, $row, $timestamp, $attributes);
    $self->recv_deleteAllRowTs();
  }
  
  sub send_deleteAllRowTs{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('deleteAllRowTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_deleteAllRowTs_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{timestamp} = $timestamp;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_deleteAllRowTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_deleteAllRowTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    return;
  }
  sub scannerOpenWithScan{
    my $self = shift;
    my $tableName = shift;
    my $scan = shift;
    my $attributes = shift;
  
      $self->send_scannerOpenWithScan($tableName, $scan, $attributes);
    return $self->recv_scannerOpenWithScan();
  }
  
  sub send_scannerOpenWithScan{
    my $self = shift;
    my $tableName = shift;
    my $scan = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('scannerOpenWithScan', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_scannerOpenWithScan_args->new();
    $args->{tableName} = $tableName;
    $args->{scan} = $scan;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_scannerOpenWithScan{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_scannerOpenWithScan_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "scannerOpenWithScan failed: unknown result";
  }
  sub scannerOpen{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $columns = shift;
    my $attributes = shift;
  
      $self->send_scannerOpen($tableName, $startRow, $columns, $attributes);
    return $self->recv_scannerOpen();
  }
  
  sub send_scannerOpen{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $columns = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('scannerOpen', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_scannerOpen_args->new();
    $args->{tableName} = $tableName;
    $args->{startRow} = $startRow;
    $args->{columns} = $columns;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_scannerOpen{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_scannerOpen_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "scannerOpen failed: unknown result";
  }
  sub scannerOpenWithStop{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $stopRow = shift;
    my $columns = shift;
    my $attributes = shift;
  
      $self->send_scannerOpenWithStop($tableName, $startRow, $stopRow, $columns, $attributes);
    return $self->recv_scannerOpenWithStop();
  }
  
  sub send_scannerOpenWithStop{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $stopRow = shift;
    my $columns = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('scannerOpenWithStop', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_scannerOpenWithStop_args->new();
    $args->{tableName} = $tableName;
    $args->{startRow} = $startRow;
    $args->{stopRow} = $stopRow;
    $args->{columns} = $columns;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_scannerOpenWithStop{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_scannerOpenWithStop_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "scannerOpenWithStop failed: unknown result";
  }
  sub scannerOpenWithPrefix{
    my $self = shift;
    my $tableName = shift;
    my $startAndPrefix = shift;
    my $columns = shift;
    my $attributes = shift;
  
      $self->send_scannerOpenWithPrefix($tableName, $startAndPrefix, $columns, $attributes);
    return $self->recv_scannerOpenWithPrefix();
  }
  
  sub send_scannerOpenWithPrefix{
    my $self = shift;
    my $tableName = shift;
    my $startAndPrefix = shift;
    my $columns = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('scannerOpenWithPrefix', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_scannerOpenWithPrefix_args->new();
    $args->{tableName} = $tableName;
    $args->{startAndPrefix} = $startAndPrefix;
    $args->{columns} = $columns;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_scannerOpenWithPrefix{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_scannerOpenWithPrefix_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "scannerOpenWithPrefix failed: unknown result";
  }
  sub scannerOpenTs{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
      $self->send_scannerOpenTs($tableName, $startRow, $columns, $timestamp, $attributes);
    return $self->recv_scannerOpenTs();
  }
  
  sub send_scannerOpenTs{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('scannerOpenTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_scannerOpenTs_args->new();
    $args->{tableName} = $tableName;
    $args->{startRow} = $startRow;
    $args->{columns} = $columns;
    $args->{timestamp} = $timestamp;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_scannerOpenTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_scannerOpenTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "scannerOpenTs failed: unknown result";
  }
  sub scannerOpenWithStopTs{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $stopRow = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
      $self->send_scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp, $attributes);
    return $self->recv_scannerOpenWithStopTs();
  }
  
  sub send_scannerOpenWithStopTs{
    my $self = shift;
    my $tableName = shift;
    my $startRow = shift;
    my $stopRow = shift;
    my $columns = shift;
    my $timestamp = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('scannerOpenWithStopTs', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_scannerOpenWithStopTs_args->new();
    $args->{tableName} = $tableName;
    $args->{startRow} = $startRow;
    $args->{stopRow} = $stopRow;
    $args->{columns} = $columns;
    $args->{timestamp} = $timestamp;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_scannerOpenWithStopTs{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_scannerOpenWithStopTs_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "scannerOpenWithStopTs failed: unknown result";
  }
  sub scannerGet{
    my $self = shift;
    my $id = shift;
  
      $self->send_scannerGet($id);
    return $self->recv_scannerGet();
  }
  
  sub send_scannerGet{
    my $self = shift;
    my $id = shift;
  
    $self->{output}->writeMessageBegin('scannerGet', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_scannerGet_args->new();
    $args->{id} = $id;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_scannerGet{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_scannerGet_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    if (defined $result->{ia}) {
      die $result->{ia};
    }
    die "scannerGet failed: unknown result";
  }
  sub scannerGetList{
    my $self = shift;
    my $id = shift;
    my $nbRows = shift;
  
      $self->send_scannerGetList($id, $nbRows);
    return $self->recv_scannerGetList();
  }
  
  sub send_scannerGetList{
    my $self = shift;
    my $id = shift;
    my $nbRows = shift;
  
    $self->{output}->writeMessageBegin('scannerGetList', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_scannerGetList_args->new();
    $args->{id} = $id;
    $args->{nbRows} = $nbRows;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_scannerGetList{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_scannerGetList_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    if (defined $result->{ia}) {
      die $result->{ia};
    }
    die "scannerGetList failed: unknown result";
  }
  sub scannerClose{
    my $self = shift;
    my $id = shift;
  
      $self->send_scannerClose($id);
    $self->recv_scannerClose();
  }
  
  sub send_scannerClose{
    my $self = shift;
    my $id = shift;
  
    $self->{output}->writeMessageBegin('scannerClose', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_scannerClose_args->new();
    $args->{id} = $id;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_scannerClose{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_scannerClose_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{io}) {
      die $result->{io};
    }
    if (defined $result->{ia}) {
      die $result->{ia};
    }
    return;
  }
  sub getRegionInfo{
    my $self = shift;
    my $row = shift;
  
      $self->send_getRegionInfo($row);
    return $self->recv_getRegionInfo();
  }
  
  sub send_getRegionInfo{
    my $self = shift;
    my $row = shift;
  
    $self->{output}->writeMessageBegin('getRegionInfo', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_getRegionInfo_args->new();
    $args->{row} = $row;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_getRegionInfo{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_getRegionInfo_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "getRegionInfo failed: unknown result";
  }
  sub append{
    my $self = shift;
    my $append = shift;
  
      $self->send_append($append);
    return $self->recv_append();
  }
  
  sub send_append{
    my $self = shift;
    my $append = shift;
  
    $self->{output}->writeMessageBegin('append', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_append_args->new();
    $args->{append} = $append;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_append{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_append_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    die "append failed: unknown result";
  }
  sub checkAndPut{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $value = shift;
    my $mput = shift;
    my $attributes = shift;
  
      $self->send_checkAndPut($tableName, $row, $column, $value, $mput, $attributes);
    return $self->recv_checkAndPut();
  }
  
  sub send_checkAndPut{
    my $self = shift;
    my $tableName = shift;
    my $row = shift;
    my $column = shift;
    my $value = shift;
    my $mput = shift;
    my $attributes = shift;
  
    $self->{output}->writeMessageBegin('checkAndPut', Thrift::TMessageType::CALL, $self->{seqid});
    my $args = Hbase::Hbase_checkAndPut_args->new();
    $args->{tableName} = $tableName;
    $args->{row} = $row;
    $args->{column} = $column;
    $args->{value} = $value;
    $args->{mput} = $mput;
    $args->{attributes} = $attributes;
    $args->write($self->{output});
    $self->{output}->writeMessageEnd();
    $self->{output}->getTransport()->flush();
  }
  
  sub recv_checkAndPut{
    my $self = shift;
  
    my $rseqid = 0;
    my $fname;
    my $mtype = 0;
  
    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
    if ($mtype == Thrift::TMessageType::EXCEPTION) {
      my $x = Thrift::TApplicationException->new();
      $x->read($self->{input});
      $self->{input}->readMessageEnd();
      die $x;
    }
    my $result = Hbase::Hbase_checkAndPut_result->new();
    $result->read($self->{input});
    $self->{input}->readMessageEnd();
  
    if (defined $result->{success} ) {
      return $result->{success};
    }
    if (defined $result->{io}) {
      die $result->{io};
    }
    if (defined $result->{ia}) {
      die $result->{ia};
    }
    die "checkAndPut failed: unknown result";
  }
  package Hbase::HbaseProcessor;
  
  #use strict;
  
  
  sub new {
      my ($classname, $handler) = @_;
      my $self      = {};
      $self->{handler} = $handler;
      return bless ($self, $classname);
  }
  
  sub process {
      my ($self, $input, $output) = @_;
      my $rseqid = 0;
      my $fname  = undef;
      my $mtype  = 0;
  
      $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
      my $methodname = 'process_'.$fname;
      if (!$self->can($methodname)) {
        $input->skip(Thrift::TType::STRUCT);
        $input->readMessageEnd();
        my $x = Thrift::TApplicationException->new('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
        $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
        $x->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        return;
      }
      $self->$methodname($rseqid, $input, $output);
      return 1;
  }
  
  sub process_enableTable {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_enableTable_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_enableTable_result->new();
      eval {
        $self->{handler}->enableTable($args->tableName);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('enableTable', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('enableTable', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_disableTable {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_disableTable_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_disableTable_result->new();
      eval {
        $self->{handler}->disableTable($args->tableName);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('disableTable', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('disableTable', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_isTableEnabled {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_isTableEnabled_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_isTableEnabled_result->new();
      eval {
        $result->{success} = $self->{handler}->isTableEnabled($args->tableName);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('isTableEnabled', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('isTableEnabled', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_compact {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_compact_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_compact_result->new();
      eval {
        $self->{handler}->compact($args->tableNameOrRegionName);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('compact', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('compact', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_majorCompact {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_majorCompact_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_majorCompact_result->new();
      eval {
        $self->{handler}->majorCompact($args->tableNameOrRegionName);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('majorCompact', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('majorCompact', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getTableNames {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getTableNames_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getTableNames_result->new();
      eval {
        $result->{success} = $self->{handler}->getTableNames();
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getTableNames', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getTableNames', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getColumnDescriptors {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getColumnDescriptors_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getColumnDescriptors_result->new();
      eval {
        $result->{success} = $self->{handler}->getColumnDescriptors($args->tableName);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getColumnDescriptors', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getColumnDescriptors', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getTableRegions {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getTableRegions_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getTableRegions_result->new();
      eval {
        $result->{success} = $self->{handler}->getTableRegions($args->tableName);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getTableRegions', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getTableRegions', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_createTable {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_createTable_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_createTable_result->new();
      eval {
        $self->{handler}->createTable($args->tableName, $args->columnFamilies);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){
        $result->{ia} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::AlreadyExists') ){
        $result->{exist} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('createTable', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('createTable', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_deleteTable {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_deleteTable_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_deleteTable_result->new();
      eval {
        $self->{handler}->deleteTable($args->tableName);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('deleteTable', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('deleteTable', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_get {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_get_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_get_result->new();
      eval {
        $result->{success} = $self->{handler}->get($args->tableName, $args->row, $args->column, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('get', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('get', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getVer {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getVer_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getVer_result->new();
      eval {
        $result->{success} = $self->{handler}->getVer($args->tableName, $args->row, $args->column, $args->numVersions, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getVer', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getVer', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getVerTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getVerTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getVerTs_result->new();
      eval {
        $result->{success} = $self->{handler}->getVerTs($args->tableName, $args->row, $args->column, $args->timestamp, $args->numVersions, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getVerTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getVerTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getRow {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getRow_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getRow_result->new();
      eval {
        $result->{success} = $self->{handler}->getRow($args->tableName, $args->row, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getRow', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getRow', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getRowWithColumns {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getRowWithColumns_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getRowWithColumns_result->new();
      eval {
        $result->{success} = $self->{handler}->getRowWithColumns($args->tableName, $args->row, $args->columns, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getRowWithColumns', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getRowWithColumns', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getRowTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getRowTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getRowTs_result->new();
      eval {
        $result->{success} = $self->{handler}->getRowTs($args->tableName, $args->row, $args->timestamp, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getRowTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getRowTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getRowWithColumnsTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getRowWithColumnsTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getRowWithColumnsTs_result->new();
      eval {
        $result->{success} = $self->{handler}->getRowWithColumnsTs($args->tableName, $args->row, $args->columns, $args->timestamp, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getRowWithColumnsTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getRowWithColumnsTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getRows {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getRows_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getRows_result->new();
      eval {
        $result->{success} = $self->{handler}->getRows($args->tableName, $args->rows, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getRows', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getRows', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getRowsWithColumns {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getRowsWithColumns_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getRowsWithColumns_result->new();
      eval {
        $result->{success} = $self->{handler}->getRowsWithColumns($args->tableName, $args->rows, $args->columns, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getRowsWithColumns', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getRowsWithColumns', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getRowsTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getRowsTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getRowsTs_result->new();
      eval {
        $result->{success} = $self->{handler}->getRowsTs($args->tableName, $args->rows, $args->timestamp, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getRowsTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getRowsTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getRowsWithColumnsTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getRowsWithColumnsTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getRowsWithColumnsTs_result->new();
      eval {
        $result->{success} = $self->{handler}->getRowsWithColumnsTs($args->tableName, $args->rows, $args->columns, $args->timestamp, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getRowsWithColumnsTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getRowsWithColumnsTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_mutateRow {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_mutateRow_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_mutateRow_result->new();
      eval {
        $self->{handler}->mutateRow($args->tableName, $args->row, $args->mutations, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){
        $result->{ia} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('mutateRow', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('mutateRow', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_mutateRowTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_mutateRowTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_mutateRowTs_result->new();
      eval {
        $self->{handler}->mutateRowTs($args->tableName, $args->row, $args->mutations, $args->timestamp, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){
        $result->{ia} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('mutateRowTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('mutateRowTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_mutateRows {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_mutateRows_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_mutateRows_result->new();
      eval {
        $self->{handler}->mutateRows($args->tableName, $args->rowBatches, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){
        $result->{ia} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('mutateRows', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('mutateRows', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_mutateRowsTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_mutateRowsTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_mutateRowsTs_result->new();
      eval {
        $self->{handler}->mutateRowsTs($args->tableName, $args->rowBatches, $args->timestamp, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){
        $result->{ia} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('mutateRowsTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('mutateRowsTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_atomicIncrement {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_atomicIncrement_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_atomicIncrement_result->new();
      eval {
        $result->{success} = $self->{handler}->atomicIncrement($args->tableName, $args->row, $args->column, $args->value);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){
        $result->{ia} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('atomicIncrement', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('atomicIncrement', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_deleteAll {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_deleteAll_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_deleteAll_result->new();
      eval {
        $self->{handler}->deleteAll($args->tableName, $args->row, $args->column, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('deleteAll', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('deleteAll', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_deleteAllTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_deleteAllTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_deleteAllTs_result->new();
      eval {
        $self->{handler}->deleteAllTs($args->tableName, $args->row, $args->column, $args->timestamp, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('deleteAllTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('deleteAllTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_deleteAllRow {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_deleteAllRow_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_deleteAllRow_result->new();
      eval {
        $self->{handler}->deleteAllRow($args->tableName, $args->row, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('deleteAllRow', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('deleteAllRow', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_increment {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_increment_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_increment_result->new();
      eval {
        $self->{handler}->increment($args->increment);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('increment', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('increment', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_incrementRows {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_incrementRows_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_incrementRows_result->new();
      eval {
        $self->{handler}->incrementRows($args->increments);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('incrementRows', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('incrementRows', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_deleteAllRowTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_deleteAllRowTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_deleteAllRowTs_result->new();
      eval {
        $self->{handler}->deleteAllRowTs($args->tableName, $args->row, $args->timestamp, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('deleteAllRowTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('deleteAllRowTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_scannerOpenWithScan {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_scannerOpenWithScan_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_scannerOpenWithScan_result->new();
      eval {
        $result->{success} = $self->{handler}->scannerOpenWithScan($args->tableName, $args->scan, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('scannerOpenWithScan', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('scannerOpenWithScan', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_scannerOpen {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_scannerOpen_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_scannerOpen_result->new();
      eval {
        $result->{success} = $self->{handler}->scannerOpen($args->tableName, $args->startRow, $args->columns, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('scannerOpen', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('scannerOpen', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_scannerOpenWithStop {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_scannerOpenWithStop_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_scannerOpenWithStop_result->new();
      eval {
        $result->{success} = $self->{handler}->scannerOpenWithStop($args->tableName, $args->startRow, $args->stopRow, $args->columns, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('scannerOpenWithStop', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('scannerOpenWithStop', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_scannerOpenWithPrefix {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_scannerOpenWithPrefix_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_scannerOpenWithPrefix_result->new();
      eval {
        $result->{success} = $self->{handler}->scannerOpenWithPrefix($args->tableName, $args->startAndPrefix, $args->columns, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('scannerOpenWithPrefix', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('scannerOpenWithPrefix', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_scannerOpenTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_scannerOpenTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_scannerOpenTs_result->new();
      eval {
        $result->{success} = $self->{handler}->scannerOpenTs($args->tableName, $args->startRow, $args->columns, $args->timestamp, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('scannerOpenTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('scannerOpenTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_scannerOpenWithStopTs {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_scannerOpenWithStopTs_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_scannerOpenWithStopTs_result->new();
      eval {
        $result->{success} = $self->{handler}->scannerOpenWithStopTs($args->tableName, $args->startRow, $args->stopRow, $args->columns, $args->timestamp, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('scannerOpenWithStopTs', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('scannerOpenWithStopTs', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_scannerGet {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_scannerGet_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_scannerGet_result->new();
      eval {
        $result->{success} = $self->{handler}->scannerGet($args->id);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){
        $result->{ia} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('scannerGet', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('scannerGet', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_scannerGetList {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_scannerGetList_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_scannerGetList_result->new();
      eval {
        $result->{success} = $self->{handler}->scannerGetList($args->id, $args->nbRows);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){
        $result->{ia} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('scannerGetList', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('scannerGetList', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_scannerClose {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_scannerClose_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_scannerClose_result->new();
      eval {
        $self->{handler}->scannerClose($args->id);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){
        $result->{ia} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('scannerClose', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('scannerClose', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_getRegionInfo {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_getRegionInfo_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_getRegionInfo_result->new();
      eval {
        $result->{success} = $self->{handler}->getRegionInfo($args->row);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('getRegionInfo', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('getRegionInfo', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_append {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_append_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_append_result->new();
      eval {
        $result->{success} = $self->{handler}->append($args->append);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('append', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('append', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  sub process_checkAndPut {
      my ($self, $seqid, $input, $output) = @_;
      my $args = Hbase::Hbase_checkAndPut_args->new();
      $args->read($input);
      $input->readMessageEnd();
      my $result = Hbase::Hbase_checkAndPut_result->new();
      eval {
        $result->{success} = $self->{handler}->checkAndPut($args->tableName, $args->row, $args->column, $args->value, $args->mput, $args->attributes);
      }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){
        $result->{io} = $@;
        $@ = undef;
          }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){
        $result->{ia} = $@;
        $@ = undef;
      }
      if ($@) {
        $@ =~ s/^\s+|\s+$//g;
        my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
        $output->writeMessageBegin('checkAndPut', Thrift::TMessageType::EXCEPTION, $seqid);
        $err->write($output);
        $output->writeMessageEnd();
        $output->getTransport()->flush();
        $@ = undef;
        return;
      }
      $output->writeMessageBegin('checkAndPut', Thrift::TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
  }
  
  1;
HBASE_HBASE

$fatpacked{"Hbase/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HBASE_TYPES';
  #
  # Autogenerated by Thrift Compiler (0.13.0)
  #
  # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  #
  use 5.10.0;
  use strict;
  use warnings;
  use Thrift::Exception;
  use Thrift::MessageType;
  use Thrift::Type;
  
  
  package Hbase::TCell;
  use base qw(Class::Accessor);
  Hbase::TCell->mk_accessors( qw( value timestamp ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{value} = undef;
    $self->{timestamp} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{value}) {
        $self->{value} = $vals->{value};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'TCell';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{value});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('TCell');
    if (defined $self->{value}) {
      $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{value});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 2);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::ColumnDescriptor;
  use base qw(Class::Accessor);
  Hbase::ColumnDescriptor->mk_accessors( qw( name maxVersions compression inMemory bloomFilterType bloomFilterVectorSize bloomFilterNbHashes blockCacheEnabled timeToLive ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{name} = undef;
    $self->{maxVersions} = 3;
    $self->{compression} = "NONE";
    $self->{inMemory} = 0;
    $self->{bloomFilterType} = "NONE";
    $self->{bloomFilterVectorSize} = 0;
    $self->{bloomFilterNbHashes} = 0;
    $self->{blockCacheEnabled} = 0;
    $self->{timeToLive} = 2147483647;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{name}) {
        $self->{name} = $vals->{name};
      }
      if (defined $vals->{maxVersions}) {
        $self->{maxVersions} = $vals->{maxVersions};
      }
      if (defined $vals->{compression}) {
        $self->{compression} = $vals->{compression};
      }
      if (defined $vals->{inMemory}) {
        $self->{inMemory} = $vals->{inMemory};
      }
      if (defined $vals->{bloomFilterType}) {
        $self->{bloomFilterType} = $vals->{bloomFilterType};
      }
      if (defined $vals->{bloomFilterVectorSize}) {
        $self->{bloomFilterVectorSize} = $vals->{bloomFilterVectorSize};
      }
      if (defined $vals->{bloomFilterNbHashes}) {
        $self->{bloomFilterNbHashes} = $vals->{bloomFilterNbHashes};
      }
      if (defined $vals->{blockCacheEnabled}) {
        $self->{blockCacheEnabled} = $vals->{blockCacheEnabled};
      }
      if (defined $vals->{timeToLive}) {
        $self->{timeToLive} = $vals->{timeToLive};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'ColumnDescriptor';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{name});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{maxVersions});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{compression});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::BOOL) {
          $xfer += $input->readBool(\$self->{inMemory});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{bloomFilterType});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^6$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{bloomFilterVectorSize});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^7$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{bloomFilterNbHashes});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^8$/ && do{      if ($ftype == Thrift::TType::BOOL) {
          $xfer += $input->readBool(\$self->{blockCacheEnabled});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^9$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{timeToLive});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('ColumnDescriptor');
    if (defined $self->{name}) {
      $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{name});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{maxVersions}) {
      $xfer += $output->writeFieldBegin('maxVersions', Thrift::TType::I32, 2);
      $xfer += $output->writeI32($self->{maxVersions});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{compression}) {
      $xfer += $output->writeFieldBegin('compression', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{compression});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{inMemory}) {
      $xfer += $output->writeFieldBegin('inMemory', Thrift::TType::BOOL, 4);
      $xfer += $output->writeBool($self->{inMemory});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{bloomFilterType}) {
      $xfer += $output->writeFieldBegin('bloomFilterType', Thrift::TType::STRING, 5);
      $xfer += $output->writeString($self->{bloomFilterType});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{bloomFilterVectorSize}) {
      $xfer += $output->writeFieldBegin('bloomFilterVectorSize', Thrift::TType::I32, 6);
      $xfer += $output->writeI32($self->{bloomFilterVectorSize});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{bloomFilterNbHashes}) {
      $xfer += $output->writeFieldBegin('bloomFilterNbHashes', Thrift::TType::I32, 7);
      $xfer += $output->writeI32($self->{bloomFilterNbHashes});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{blockCacheEnabled}) {
      $xfer += $output->writeFieldBegin('blockCacheEnabled', Thrift::TType::BOOL, 8);
      $xfer += $output->writeBool($self->{blockCacheEnabled});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timeToLive}) {
      $xfer += $output->writeFieldBegin('timeToLive', Thrift::TType::I32, 9);
      $xfer += $output->writeI32($self->{timeToLive});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::TRegionInfo;
  use base qw(Class::Accessor);
  Hbase::TRegionInfo->mk_accessors( qw( startKey endKey id name version serverName port ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{startKey} = undef;
    $self->{endKey} = undef;
    $self->{id} = undef;
    $self->{name} = undef;
    $self->{version} = undef;
    $self->{serverName} = undef;
    $self->{port} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{startKey}) {
        $self->{startKey} = $vals->{startKey};
      }
      if (defined $vals->{endKey}) {
        $self->{endKey} = $vals->{endKey};
      }
      if (defined $vals->{id}) {
        $self->{id} = $vals->{id};
      }
      if (defined $vals->{name}) {
        $self->{name} = $vals->{name};
      }
      if (defined $vals->{version}) {
        $self->{version} = $vals->{version};
      }
      if (defined $vals->{serverName}) {
        $self->{serverName} = $vals->{serverName};
      }
      if (defined $vals->{port}) {
        $self->{port} = $vals->{port};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'TRegionInfo';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{startKey});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{endKey});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{id});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{name});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::BYTE) {
          $xfer += $input->readByte(\$self->{version});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^6$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{serverName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^7$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{port});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('TRegionInfo');
    if (defined $self->{startKey}) {
      $xfer += $output->writeFieldBegin('startKey', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{startKey});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{endKey}) {
      $xfer += $output->writeFieldBegin('endKey', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{endKey});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{id}) {
      $xfer += $output->writeFieldBegin('id', Thrift::TType::I64, 3);
      $xfer += $output->writeI64($self->{id});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{name}) {
      $xfer += $output->writeFieldBegin('name', Thrift::TType::STRING, 4);
      $xfer += $output->writeString($self->{name});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{version}) {
      $xfer += $output->writeFieldBegin('version', Thrift::TType::BYTE, 5);
      $xfer += $output->writeByte($self->{version});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{serverName}) {
      $xfer += $output->writeFieldBegin('serverName', Thrift::TType::STRING, 6);
      $xfer += $output->writeString($self->{serverName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{port}) {
      $xfer += $output->writeFieldBegin('port', Thrift::TType::I32, 7);
      $xfer += $output->writeI32($self->{port});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::Mutation;
  use base qw(Class::Accessor);
  Hbase::Mutation->mk_accessors( qw( isDelete column value writeToWAL ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{isDelete} = 0;
    $self->{column} = undef;
    $self->{value} = undef;
    $self->{writeToWAL} = 1;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{isDelete}) {
        $self->{isDelete} = $vals->{isDelete};
      }
      if (defined $vals->{column}) {
        $self->{column} = $vals->{column};
      }
      if (defined $vals->{value}) {
        $self->{value} = $vals->{value};
      }
      if (defined $vals->{writeToWAL}) {
        $self->{writeToWAL} = $vals->{writeToWAL};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'Mutation';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::BOOL) {
          $xfer += $input->readBool(\$self->{isDelete});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{column});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{value});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::BOOL) {
          $xfer += $input->readBool(\$self->{writeToWAL});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('Mutation');
    if (defined $self->{isDelete}) {
      $xfer += $output->writeFieldBegin('isDelete', Thrift::TType::BOOL, 1);
      $xfer += $output->writeBool($self->{isDelete});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{column}) {
      $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{column});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{value}) {
      $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{value});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{writeToWAL}) {
      $xfer += $output->writeFieldBegin('writeToWAL', Thrift::TType::BOOL, 4);
      $xfer += $output->writeBool($self->{writeToWAL});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::BatchMutation;
  use base qw(Class::Accessor);
  Hbase::BatchMutation->mk_accessors( qw( row mutations ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{row} = undef;
    $self->{mutations} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{mutations}) {
        $self->{mutations} = $vals->{mutations};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'BatchMutation';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size0 = 0;
            $self->{mutations} = [];
            my $_etype3 = 0;
            $xfer += $input->readListBegin(\$_etype3, \$_size0);
            for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              my $elem5 = undef;
              $elem5 = Hbase::Mutation->new();
              $xfer += $elem5->read($input);
              push(@{$self->{mutations}},$elem5);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('BatchMutation');
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{mutations}) {
      $xfer += $output->writeFieldBegin('mutations', Thrift::TType::LIST, 2);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{mutations}}));
        {
          foreach my $iter6 (@{$self->{mutations}}) 
          {
            $xfer += ${iter6}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::TIncrement;
  use base qw(Class::Accessor);
  Hbase::TIncrement->mk_accessors( qw( table row column ammount ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{table} = undef;
    $self->{row} = undef;
    $self->{column} = undef;
    $self->{ammount} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{table}) {
        $self->{table} = $vals->{table};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{column}) {
        $self->{column} = $vals->{column};
      }
      if (defined $vals->{ammount}) {
        $self->{ammount} = $vals->{ammount};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'TIncrement';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{table});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{column});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{ammount});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('TIncrement');
    if (defined $self->{table}) {
      $xfer += $output->writeFieldBegin('table', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{table});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{column}) {
      $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
      $xfer += $output->writeString($self->{column});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{ammount}) {
      $xfer += $output->writeFieldBegin('ammount', Thrift::TType::I64, 4);
      $xfer += $output->writeI64($self->{ammount});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::TColumn;
  use base qw(Class::Accessor);
  Hbase::TColumn->mk_accessors( qw( columnName cell ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{columnName} = undef;
    $self->{cell} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{columnName}) {
        $self->{columnName} = $vals->{columnName};
      }
      if (defined $vals->{cell}) {
        $self->{cell} = $vals->{cell};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'TColumn';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{columnName});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
          $self->{cell} = Hbase::TCell->new();
          $xfer += $self->{cell}->read($input);
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('TColumn');
    if (defined $self->{columnName}) {
      $xfer += $output->writeFieldBegin('columnName', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{columnName});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{cell}) {
      $xfer += $output->writeFieldBegin('cell', Thrift::TType::STRUCT, 2);
      $xfer += $self->{cell}->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::TRowResult;
  use base qw(Class::Accessor);
  Hbase::TRowResult->mk_accessors( qw( row columns sortedColumns ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{row} = undef;
    $self->{columns} = undef;
    $self->{sortedColumns} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{sortedColumns}) {
        $self->{sortedColumns} = $vals->{sortedColumns};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'TRowResult';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::MAP) {
          {
            my $_size7 = 0;
            $self->{columns} = {};
            my $_ktype8 = 0;
            my $_vtype9 = 0;
            $xfer += $input->readMapBegin(\$_ktype8, \$_vtype9, \$_size7);
            for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              my $key12 = '';
              my $val13 = Hbase::TCell->new();
              $xfer += $input->readString(\$key12);
              $val13 = Hbase::TCell->new();
              $xfer += $val13->read($input);
              $self->{columns}->{$key12} = $val13;
            }
            $xfer += $input->readMapEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size14 = 0;
            $self->{sortedColumns} = [];
            my $_etype17 = 0;
            $xfer += $input->readListBegin(\$_etype17, \$_size14);
            for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              my $elem19 = undef;
              $elem19 = Hbase::TColumn->new();
              $xfer += $elem19->read($input);
              push(@{$self->{sortedColumns}},$elem19);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('TRowResult');
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::MAP, 2);
      {
        $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{columns}}));
        {
          while( my ($kiter20,$viter21) = each %{$self->{columns}}) 
          {
            $xfer += $output->writeString($kiter20);
            $xfer += ${viter21}->write($output);
          }
        }
        $xfer += $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{sortedColumns}) {
      $xfer += $output->writeFieldBegin('sortedColumns', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{sortedColumns}}));
        {
          foreach my $iter22 (@{$self->{sortedColumns}}) 
          {
            $xfer += ${iter22}->write($output);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::TScan;
  use base qw(Class::Accessor);
  Hbase::TScan->mk_accessors( qw( startRow stopRow timestamp columns caching filterString batchSize sortColumns reversed cacheBlocks ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{startRow} = undef;
    $self->{stopRow} = undef;
    $self->{timestamp} = undef;
    $self->{columns} = undef;
    $self->{caching} = undef;
    $self->{filterString} = undef;
    $self->{batchSize} = undef;
    $self->{sortColumns} = undef;
    $self->{reversed} = undef;
    $self->{cacheBlocks} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{startRow}) {
        $self->{startRow} = $vals->{startRow};
      }
      if (defined $vals->{stopRow}) {
        $self->{stopRow} = $vals->{stopRow};
      }
      if (defined $vals->{timestamp}) {
        $self->{timestamp} = $vals->{timestamp};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{caching}) {
        $self->{caching} = $vals->{caching};
      }
      if (defined $vals->{filterString}) {
        $self->{filterString} = $vals->{filterString};
      }
      if (defined $vals->{batchSize}) {
        $self->{batchSize} = $vals->{batchSize};
      }
      if (defined $vals->{sortColumns}) {
        $self->{sortColumns} = $vals->{sortColumns};
      }
      if (defined $vals->{reversed}) {
        $self->{reversed} = $vals->{reversed};
      }
      if (defined $vals->{cacheBlocks}) {
        $self->{cacheBlocks} = $vals->{cacheBlocks};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'TScan';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{startRow});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{stopRow});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
          $xfer += $input->readI64(\$self->{timestamp});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size23 = 0;
            $self->{columns} = [];
            my $_etype26 = 0;
            $xfer += $input->readListBegin(\$_etype26, \$_size23);
            for (my $_i27 = 0; $_i27 < $_size23; ++$_i27)
            {
              my $elem28 = undef;
              $xfer += $input->readString(\$elem28);
              push(@{$self->{columns}},$elem28);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^5$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{caching});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^6$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{filterString});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^7$/ && do{      if ($ftype == Thrift::TType::I32) {
          $xfer += $input->readI32(\$self->{batchSize});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^8$/ && do{      if ($ftype == Thrift::TType::BOOL) {
          $xfer += $input->readBool(\$self->{sortColumns});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^9$/ && do{      if ($ftype == Thrift::TType::BOOL) {
          $xfer += $input->readBool(\$self->{reversed});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^10$/ && do{      if ($ftype == Thrift::TType::BOOL) {
          $xfer += $input->readBool(\$self->{cacheBlocks});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('TScan');
    if (defined $self->{startRow}) {
      $xfer += $output->writeFieldBegin('startRow', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{startRow});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{stopRow}) {
      $xfer += $output->writeFieldBegin('stopRow', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{stopRow});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{timestamp}) {
      $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
      $xfer += $output->writeI64($self->{timestamp});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 4);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter29 (@{$self->{columns}}) 
          {
            $xfer += $output->writeString($iter29);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{caching}) {
      $xfer += $output->writeFieldBegin('caching', Thrift::TType::I32, 5);
      $xfer += $output->writeI32($self->{caching});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{filterString}) {
      $xfer += $output->writeFieldBegin('filterString', Thrift::TType::STRING, 6);
      $xfer += $output->writeString($self->{filterString});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{batchSize}) {
      $xfer += $output->writeFieldBegin('batchSize', Thrift::TType::I32, 7);
      $xfer += $output->writeI32($self->{batchSize});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{sortColumns}) {
      $xfer += $output->writeFieldBegin('sortColumns', Thrift::TType::BOOL, 8);
      $xfer += $output->writeBool($self->{sortColumns});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{reversed}) {
      $xfer += $output->writeFieldBegin('reversed', Thrift::TType::BOOL, 9);
      $xfer += $output->writeBool($self->{reversed});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{cacheBlocks}) {
      $xfer += $output->writeFieldBegin('cacheBlocks', Thrift::TType::BOOL, 10);
      $xfer += $output->writeBool($self->{cacheBlocks});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::TAppend;
  use base qw(Class::Accessor);
  Hbase::TAppend->mk_accessors( qw( table row columns values ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{table} = undef;
    $self->{row} = undef;
    $self->{columns} = undef;
    $self->{values} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{table}) {
        $self->{table} = $vals->{table};
      }
      if (defined $vals->{row}) {
        $self->{row} = $vals->{row};
      }
      if (defined $vals->{columns}) {
        $self->{columns} = $vals->{columns};
      }
      if (defined $vals->{values}) {
        $self->{values} = $vals->{values};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'TAppend';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{table});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{row});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size30 = 0;
            $self->{columns} = [];
            my $_etype33 = 0;
            $xfer += $input->readListBegin(\$_etype33, \$_size30);
            for (my $_i34 = 0; $_i34 < $_size30; ++$_i34)
            {
              my $elem35 = undef;
              $xfer += $input->readString(\$elem35);
              push(@{$self->{columns}},$elem35);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
        /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
          {
            my $_size36 = 0;
            $self->{values} = [];
            my $_etype39 = 0;
            $xfer += $input->readListBegin(\$_etype39, \$_size36);
            for (my $_i40 = 0; $_i40 < $_size36; ++$_i40)
            {
              my $elem41 = undef;
              $xfer += $input->readString(\$elem41);
              push(@{$self->{values}},$elem41);
            }
            $xfer += $input->readListEnd();
          }
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('TAppend');
    if (defined $self->{table}) {
      $xfer += $output->writeFieldBegin('table', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{table});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{row}) {
      $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
      $xfer += $output->writeString($self->{row});
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{columns}) {
      $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
        {
          foreach my $iter42 (@{$self->{columns}}) 
          {
            $xfer += $output->writeString($iter42);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if (defined $self->{values}) {
      $xfer += $output->writeFieldBegin('values', Thrift::TType::LIST, 4);
      {
        $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{values}}));
        {
          foreach my $iter43 (@{$self->{values}}) 
          {
            $xfer += $output->writeString($iter43);
          }
        }
        $xfer += $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::IOError;
  use base qw(Thrift::TException);
  use base qw(Class::Accessor);
  Hbase::IOError->mk_accessors( qw( message ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{message} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{message}) {
        $self->{message} = $vals->{message};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'IOError';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{message});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('IOError');
    if (defined $self->{message}) {
      $xfer += $output->writeFieldBegin('message', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{message});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::IllegalArgument;
  use base qw(Thrift::TException);
  use base qw(Class::Accessor);
  Hbase::IllegalArgument->mk_accessors( qw( message ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{message} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{message}) {
        $self->{message} = $vals->{message};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'IllegalArgument';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{message});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('IllegalArgument');
    if (defined $self->{message}) {
      $xfer += $output->writeFieldBegin('message', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{message});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  package Hbase::AlreadyExists;
  use base qw(Thrift::TException);
  use base qw(Class::Accessor);
  Hbase::AlreadyExists->mk_accessors( qw( message ) );
  
  sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{message} = undef;
    if (UNIVERSAL::isa($vals,'HASH')) {
      if (defined $vals->{message}) {
        $self->{message} = $vals->{message};
      }
    }
    return bless ($self, $classname);
  }
  
  sub getName {
    return 'AlreadyExists';
  }
  
  sub read {
    my ($self, $input) = @_;
    my $xfer  = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin(\$fname);
    while (1)
    {
      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
      if ($ftype == Thrift::TType::STOP) {
        last;
      }
      SWITCH: for($fid)
      {
        /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
          $xfer += $input->readString(\$self->{message});
        } else {
          $xfer += $input->skip($ftype);
        }
        last; };
          $xfer += $input->skip($ftype);
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }
  
  sub write {
    my ($self, $output) = @_;
    my $xfer   = 0;
    $xfer += $output->writeStructBegin('AlreadyExists');
    if (defined $self->{message}) {
      $xfer += $output->writeFieldBegin('message', Thrift::TType::STRING, 1);
      $xfer += $output->writeString($self->{message});
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }
  
  1;
HBASE_TYPES

$fatpacked{"bash-tools/templates/template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BASH-TOOLS_TEMPLATES_TEMPLATE';
  #
  #  Author: Hari Sekhon
  #  Date: [% DATE # 2013-11-03 04:03:58 +0000 (Sun, 03 Nov 2013) %]
  #
  #  [% VIM_TAGS %]
  #
  #  [% URL %]
  #
  #  [% LICENSE %]
  #  
  #  [% MESSAGE %]
  #
  #  [% LINKEDIN %]
  #
  
  package [% NAME %];
  
  $VERSION = "0.1";
  
  use strict;
  use warnings;
  BEGIN {
      use File::Basename;
      use lib dirname(__FILE__) . "/..";
  }
  use HariSekhonUtils;
  use Carp;
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = ( qw (
                  )
  );
  our @EXPORT_OK = ( @EXPORT );
  
  1;
BASH-TOOLS_TEMPLATES_TEMPLATE

$fatpacked{"inc/Module/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'INC_MODULE_INSTALL';
  #line 1
  package Module::Install;
  
  # For any maintainers:
  # The load order for Module::Install is a bit magic.
  # It goes something like this...
  #
  # IF ( host has Module::Install installed, creating author mode ) {
  #     1. Makefile.PL calls "use inc::Module::Install"
  #     2. $INC{inc/Module/Install.pm} set to installed version of inc::Module::Install
  #     3. The installed version of inc::Module::Install loads
  #     4. inc::Module::Install calls "require Module::Install"
  #     5. The ./inc/ version of Module::Install loads
  # } ELSE {
  #     1. Makefile.PL calls "use inc::Module::Install"
  #     2. $INC{inc/Module/Install.pm} set to ./inc/ version of Module::Install
  #     3. The ./inc/ version of Module::Install loads
  # }
  
  use 5.006;
  use strict 'vars';
  use Cwd        ();
  use File::Find ();
  use File::Path ();
  
  use vars qw{$VERSION $MAIN};
  BEGIN {
  	# All Module::Install core packages now require synchronised versions.
  	# This will be used to ensure we don't accidentally load old or
  	# different versions of modules.
  	# This is not enforced yet, but will be some time in the next few
  	# releases once we can make sure it won't clash with custom
  	# Module::Install extensions.
  	$VERSION = '1.19';
  
  	# Storage for the pseudo-singleton
  	$MAIN    = undef;
  
  	*inc::Module::Install::VERSION = *VERSION;
  	@inc::Module::Install::ISA     = __PACKAGE__;
  
  }
  
  sub import {
  	my $class = shift;
  	my $self  = $class->new(@_);
  	my $who   = $self->_caller;
  
  	#-------------------------------------------------------------
  	# all of the following checks should be included in import(),
  	# to allow "eval 'require Module::Install; 1' to test
  	# installation of Module::Install. (RT #51267)
  	#-------------------------------------------------------------
  
  	# Whether or not inc::Module::Install is actually loaded, the
  	# $INC{inc/Module/Install.pm} is what will still get set as long as
  	# the caller loaded module this in the documented manner.
  	# If not set, the caller may NOT have loaded the bundled version, and thus
  	# they may not have a MI version that works with the Makefile.PL. This would
  	# result in false errors or unexpected behaviour. And we don't want that.
  	my $file = join( '/', 'inc', split /::/, __PACKAGE__ ) . '.pm';
  	unless ( $INC{$file} ) { die <<"END_DIE" }
  
  Please invoke ${\__PACKAGE__} with:
  
  	use inc::${\__PACKAGE__};
  
  not:
  
  	use ${\__PACKAGE__};
  
  END_DIE
  
  	# This reportedly fixes a rare Win32 UTC file time issue, but
  	# as this is a non-cross-platform XS module not in the core,
  	# we shouldn't really depend on it. See RT #24194 for detail.
  	# (Also, this module only supports Perl 5.6 and above).
  	eval "use Win32::UTCFileTime" if $^O eq 'MSWin32' && $] >= 5.006;
  
  	# If the script that is loading Module::Install is from the future,
  	# then make will detect this and cause it to re-run over and over
  	# again. This is bad. Rather than taking action to touch it (which
  	# is unreliable on some platforms and requires write permissions)
  	# for now we should catch this and refuse to run.
  	if ( -f $0 ) {
  		my $s = (stat($0))[9];
  
  		# If the modification time is only slightly in the future,
  		# sleep briefly to remove the problem.
  		my $a = $s - time;
  		if ( $a > 0 and $a < 5 ) { sleep 5 }
  
  		# Too far in the future, throw an error.
  		my $t = time;
  		if ( $s > $t ) { die <<"END_DIE" }
  
  Your installer $0 has a modification time in the future ($s > $t).
  
  This is known to create infinite loops in make.
  
  Please correct this, then run $0 again.
  
  END_DIE
  	}
  
  
  	# Build.PL was formerly supported, but no longer is due to excessive
  	# difficulty in implementing every single feature twice.
  	if ( $0 =~ /Build.PL$/i ) { die <<"END_DIE" }
  
  Module::Install no longer supports Build.PL.
  
  It was impossible to maintain duel backends, and has been deprecated.
  
  Please remove all Build.PL files and only use the Makefile.PL installer.
  
  END_DIE
  
  	#-------------------------------------------------------------
  
  	# To save some more typing in Module::Install installers, every...
  	# use inc::Module::Install
  	# ...also acts as an implicit use strict.
  	$^H |= strict::bits(qw(refs subs vars));
  
  	#-------------------------------------------------------------
  
  	unless ( -f $self->{file} ) {
  		foreach my $key (keys %INC) {
  			delete $INC{$key} if $key =~ /Module\/Install/;
  		}
  
  		local $^W;
  		require "$self->{path}/$self->{dispatch}.pm";
  		File::Path::mkpath("$self->{prefix}/$self->{author}");
  		$self->{admin} = "$self->{name}::$self->{dispatch}"->new( _top => $self );
  		$self->{admin}->init;
  		@_ = ($class, _self => $self);
  		goto &{"$self->{name}::import"};
  	}
  
  	local $^W;
  	*{"${who}::AUTOLOAD"} = $self->autoload;
  	$self->preload;
  
  	# Unregister loader and worker packages so subdirs can use them again
  	delete $INC{'inc/Module/Install.pm'};
  	delete $INC{'Module/Install.pm'};
  
  	# Save to the singleton
  	$MAIN = $self;
  
  	return 1;
  }
  
  sub autoload {
  	my $self = shift;
  	my $who  = $self->_caller;
  	my $cwd  = Cwd::getcwd();
  	my $sym  = "${who}::AUTOLOAD";
  	$sym->{$cwd} = sub {
  		my $pwd = Cwd::getcwd();
  		if ( my $code = $sym->{$pwd} ) {
  			# Delegate back to parent dirs
  			goto &$code unless $cwd eq $pwd;
  		}
  		unless ($$sym =~ s/([^:]+)$//) {
  			# XXX: it looks like we can't retrieve the missing function
  			# via $$sym (usually $main::AUTOLOAD) in this case.
  			# I'm still wondering if we should slurp Makefile.PL to
  			# get some context or not ...
  			my ($package, $file, $line) = caller;
  			die <<"EOT";
  Unknown function is found at $file line $line.
  Execution of $file aborted due to runtime errors.
  
  If you're a contributor to a project, you may need to install
  some Module::Install extensions from CPAN (or other repository).
  If you're a user of a module, please contact the author.
  EOT
  		}
  		my $method = $1;
  		if ( uc($method) eq $method ) {
  			# Do nothing
  			return;
  		} elsif ( $method =~ /^_/ and $self->can($method) ) {
  			# Dispatch to the root M:I class
  			return $self->$method(@_);
  		}
  
  		# Dispatch to the appropriate plugin
  		unshift @_, ( $self, $1 );
  		goto &{$self->can('call')};
  	};
  }
  
  sub preload {
  	my $self = shift;
  	unless ( $self->{extensions} ) {
  		$self->load_extensions(
  			"$self->{prefix}/$self->{path}", $self
  		);
  	}
  
  	my @exts = @{$self->{extensions}};
  	unless ( @exts ) {
  		@exts = $self->{admin}->load_all_extensions;
  	}
  
  	my %seen;
  	foreach my $obj ( @exts ) {
  		while (my ($method, $glob) = each %{ref($obj) . '::'}) {
  			next unless $obj->can($method);
  			next if $method =~ /^_/;
  			next if $method eq uc($method);
  			$seen{$method}++;
  		}
  	}
  
  	my $who = $self->_caller;
  	foreach my $name ( sort keys %seen ) {
  		local $^W;
  		*{"${who}::$name"} = sub {
  			${"${who}::AUTOLOAD"} = "${who}::$name";
  			goto &{"${who}::AUTOLOAD"};
  		};
  	}
  }
  
  sub new {
  	my ($class, %args) = @_;
  
  	delete $INC{'FindBin.pm'};
  	{
  		# to suppress the redefine warning
  		local $SIG{__WARN__} = sub {};
  		require FindBin;
  	}
  
  	# ignore the prefix on extension modules built from top level.
  	my $base_path = Cwd::abs_path($FindBin::Bin);
  	unless ( Cwd::abs_path(Cwd::getcwd()) eq $base_path ) {
  		delete $args{prefix};
  	}
  	return $args{_self} if $args{_self};
  
  	$base_path = VMS::Filespec::unixify($base_path) if $^O eq 'VMS';
  
  	$args{dispatch} ||= 'Admin';
  	$args{prefix}   ||= 'inc';
  	$args{author}   ||= ($^O eq 'VMS' ? '_author' : '.author');
  	$args{bundle}   ||= 'inc/BUNDLES';
  	$args{base}     ||= $base_path;
  	$class =~ s/^\Q$args{prefix}\E:://;
  	$args{name}     ||= $class;
  	$args{version}  ||= $class->VERSION;
  	unless ( $args{path} ) {
  		$args{path}  = $args{name};
  		$args{path}  =~ s!::!/!g;
  	}
  	$args{file}     ||= "$args{base}/$args{prefix}/$args{path}.pm";
  	$args{wrote}      = 0;
  
  	bless( \%args, $class );
  }
  
  sub call {
  	my ($self, $method) = @_;
  	my $obj = $self->load($method) or return;
          splice(@_, 0, 2, $obj);
  	goto &{$obj->can($method)};
  }
  
  sub load {
  	my ($self, $method) = @_;
  
  	$self->load_extensions(
  		"$self->{prefix}/$self->{path}", $self
  	) unless $self->{extensions};
  
  	foreach my $obj (@{$self->{extensions}}) {
  		return $obj if $obj->can($method);
  	}
  
  	my $admin = $self->{admin} or die <<"END_DIE";
  The '$method' method does not exist in the '$self->{prefix}' path!
  Please remove the '$self->{prefix}' directory and run $0 again to load it.
  END_DIE
  
  	my $obj = $admin->load($method, 1);
  	push @{$self->{extensions}}, $obj;
  
  	$obj;
  }
  
  sub load_extensions {
  	my ($self, $path, $top) = @_;
  
  	my $should_reload = 0;
  	unless ( grep { ! ref $_ and lc $_ eq lc $self->{prefix} } @INC ) {
  		unshift @INC, $self->{prefix};
  		$should_reload = 1;
  	}
  
  	foreach my $rv ( $self->find_extensions($path) ) {
  		my ($file, $pkg) = @{$rv};
  		next if $self->{pathnames}{$pkg};
  
  		local $@;
  		my $new = eval { local $^W; require $file; $pkg->can('new') };
  		unless ( $new ) {
  			warn $@ if $@;
  			next;
  		}
  		$self->{pathnames}{$pkg} =
  			$should_reload ? delete $INC{$file} : $INC{$file};
  		push @{$self->{extensions}}, &{$new}($pkg, _top => $top );
  	}
  
  	$self->{extensions} ||= [];
  }
  
  sub find_extensions {
  	my ($self, $path) = @_;
  
  	my @found;
  	File::Find::find( {no_chdir => 1, wanted => sub {
  		my $file = $File::Find::name;
  		return unless $file =~ m!^\Q$path\E/(.+)\.pm\Z!is;
  		my $subpath = $1;
  		return if lc($subpath) eq lc($self->{dispatch});
  
  		$file = "$self->{path}/$subpath.pm";
  		my $pkg = "$self->{name}::$subpath";
  		$pkg =~ s!/!::!g;
  
  		# If we have a mixed-case package name, assume case has been preserved
  		# correctly.  Otherwise, root through the file to locate the case-preserved
  		# version of the package name.
  		if ( $subpath eq lc($subpath) || $subpath eq uc($subpath) ) {
  			my $content = Module::Install::_read($File::Find::name);
  			my $in_pod  = 0;
  			foreach ( split /\n/, $content ) {
  				$in_pod = 1 if /^=\w/;
  				$in_pod = 0 if /^=cut/;
  				next if ($in_pod || /^=cut/);  # skip pod text
  				next if /^\s*#/;               # and comments
  				if ( m/^\s*package\s+($pkg)\s*;/i ) {
  					$pkg = $1;
  					last;
  				}
  			}
  		}
  
  		push @found, [ $file, $pkg ];
  	}}, $path ) if -d $path;
  
  	@found;
  }
  
  
  
  
  
  #####################################################################
  # Common Utility Functions
  
  sub _caller {
  	my $depth = 0;
  	my $call  = caller($depth);
  	while ( $call eq __PACKAGE__ ) {
  		$depth++;
  		$call = caller($depth);
  	}
  	return $call;
  }
  
  sub _read {
  	local *FH;
  	open( FH, '<', $_[0] ) or die "open($_[0]): $!";
  	binmode FH;
  	my $string = do { local $/; <FH> };
  	close FH or die "close($_[0]): $!";
  	return $string;
  }
  
  sub _readperl {
  	my $string = Module::Install::_read($_[0]);
  	$string =~ s/(?:\015{1,2}\012|\015|\012)/\n/sg;
  	$string =~ s/(\n)\n*__(?:DATA|END)__\b.*\z/$1/s;
  	$string =~ s/\n\n=\w+.+?\n\n=cut\b.+?\n+/\n\n/sg;
  	return $string;
  }
  
  sub _readpod {
  	my $string = Module::Install::_read($_[0]);
  	$string =~ s/(?:\015{1,2}\012|\015|\012)/\n/sg;
  	return $string if $_[0] =~ /\.pod\z/;
  	$string =~ s/(^|\n=cut\b.+?\n+)[^=\s].+?\n(\n=\w+|\z)/$1$2/sg;
  	$string =~ s/\n*=pod\b[^\n]*\n+/\n\n/sg;
  	$string =~ s/\n*=cut\b[^\n]*\n+/\n\n/sg;
  	$string =~ s/^\n+//s;
  	return $string;
  }
  
  sub _write {
  	local *FH;
  	open( FH, '>', $_[0] ) or die "open($_[0]): $!";
  	binmode FH;
  	foreach ( 1 .. $#_ ) {
  		print FH $_[$_] or die "print($_[0]): $!";
  	}
  	close FH or die "close($_[0]): $!";
  }
  
  # _version is for processing module versions (eg, 1.03_05) not
  # Perl versions (eg, 5.8.1).
  sub _version {
  	my $s = shift || 0;
  	my $d =()= $s =~ /(\.)/g;
  	if ( $d >= 2 ) {
  		# Normalise multipart versions
  		$s =~ s/(\.)(\d{1,3})/sprintf("$1%03d",$2)/eg;
  	}
  	$s =~ s/^(\d+)\.?//;
  	my $l = $1 || 0;
  	my @v = map {
  		$_ . '0' x (3 - length $_)
  	} $s =~ /(\d{1,3})\D?/g;
  	$l = $l . '.' . join '', @v if @v;
  	return $l + 0;
  }
  
  sub _cmp {
  	_version($_[1]) <=> _version($_[2]);
  }
  
  # Cloned from Params::Util::_CLASS
  sub _CLASS {
  	(
  		defined $_[0]
  		and
  		! ref $_[0]
  		and
  		$_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s
  	) ? $_[0] : undef;
  }
  
  1;
  
  # Copyright 2008 - 2012 Adam Kennedy.
INC_MODULE_INSTALL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

# nagios: -epn
#
#  Author: Hari Sekhon
#  Date: 2011-08-22 15:56:27 +0000 (Mon, 22 Aug 2011)
#
#  https://github.com/harisekhon/nagios-plugins
#
#  License: see accompanying LICENSE file
#

$DESCRIPTION = "Nagios Plugin to check arbitrary MySQL queries against regex matches or numerical ranges, with perfdata support for graphing

It looks like a similar plugin has now been added to the standard Nagios Plugins collection, although this one still has more features

Only the first row returned is considered for the result so your SQL query should take that in to account

DO NOT ADD a semi-colon to the end of your query in Nagios, although this plugin can handle this fine and it works on the command line, in Nagios the command will end up being prematurely terminated and result in a null critical error that is hard to debug and that this plugin cannot catch since it's raised by the shell before this plugin is executed

Tested on MySQL 5.0, 5.1, 5.5, 5.6, 5.7, 8.0 and MariaDB 5.5, 10.1, 10.2, 10.3
";

# TODO: add retry switch if valid below threshold

$VERSION = "1.2.0";

use strict;
use warnings;
use Time::HiRes;
BEGIN {
    use File::Basename;
    use lib dirname(__FILE__) . "/lib";
}
use HariSekhonUtils;
use DBI;

set_port_default(3306);
set_timeout_max(3600);

my @default_mysql_sockets = ( "/var/lib/mysql/mysql.sock", "/tmp/mysql.sock");
my $mysql_socket;

my $default_message = "query returned";
my $database;
my $epoch;
my $query;
my $field = 1;
my $graph;
my $label;
my $message = $default_message;
my $message_pre;
my $message_printf = 0;
my $message_printf_numeric = 0;
my $no_querytime = 0;
my $output;
my $regex;
my $short;
my $units = "";

env_creds("MYSQL", "MySQL");
env_var("MYSQL_DATABASE", \$database);

%options = (
    %hostoptions,
    %useroptions,
    "d|database=s"  => [ \$database, "MySQL database (\$MYSQL_DATABASE)" ],
    "s|mysql-socket=s" => [ \$mysql_socket,    "MySQL socket file through which to connect (defaults: " . join(", ", @default_mysql_sockets) . ")" ],
    "q|query=s"     => [ \$query,    "MySQL query to execute" ],
    "f|field=s"     => [ \$field,    "Field name / number to check the results of (defaults to '1' for the first field)" ],
    "e|epoch"       => [ \$epoch,    "Subtract result from current time in epoch format from result (useful for timestamp based comparisons)" ],
    "m|message=s"   => [ \$message,  "Message to output after result. Can take a printf string with a single substitution (defaults to '$default_message')" ],
    "n|message-prepend" => [ \$message_pre, "Display message before rather than after result (prepend)" ],
    "o|output=s"    => [ \$output,   "Exact output to expect" ],
    "r|regex=s"     => [ \$regex,    "Regex to match the result against" ],
    "g|graph"       => [ \$graph,    "Perfdata output for graphing" ],
    "l|label=s"     => [ \$label,    "Perfdata label. If not specified uses field name or Undefined if field name doesn't match a known regex of chars" ],
    "U|units=s"     => [ \$units,    "Units of measurement for graphing output (%/s/ms/us/B/KB/MB/TB/c)" ],
    "T|short"       => [ \$short,    "Shorten output, do not output message just result" ],
    "Q|no-querytime" => [ \$no_querytime, "Do not output the mysql query time" ],
    %thresholdoptions,
);
@usage_order = qw/host port user password database mysql-socket query field epoch message message-prepend output regex warning critical graph label units short no-querytime/;

get_options();

if($host){
    $host = validate_host($host) if $host;
    $port = validate_port($port);
} else {
    unless($mysql_socket){
        foreach(@default_mysql_sockets){
            if( -e $_ ){
                vlog2 "found mysql socket '$_'";
                $mysql_socket = $_;
                last;
            }
        }
    }
    unless($mysql_socket){
        usage "host not defined and no mysql socket found, must specify one of --host or --mysql-socket";
    }
    $mysql_socket = validate_filename($mysql_socket, "mysql socket");
}
$user       = validate_user($user);
$password   = validate_password($password) if $password;
$database   = validate_database($database);
$query      = validate_database_query_select_show($query);
$field      = validate_database_fieldname($field);
$regex      = validate_regex($regex) if defined($regex);
$label      = validate_label($label) if($label);
$units      = validate_units($units) if($units);
vlog2("output:    $output") if defined($output);
vlog2("epoch:     on") if $epoch;
validate_thresholds(0, 0, {'positive' => 0});
$message_pre = 1 if($message eq $default_message);
if($message =~ /^[^%]*\%s[^%]*$/){
    $message_printf = 1;
    vlog2("\nenabling printf string format message (only 1 string printf variable detected)");
} elsif($message =~ /^[^%]*\%(?:\d+)?(?:\.\d+)?[fd][^%]*$/){
    $message_printf_numeric = 1;
    vlog2("\nenabling printf numeric format message (only 1 float/int printf variable detected)");
}
$graph = 1 if $label;
$graph = 1 if $units;
if($graph){
    unless($label){
        vlog2("graphing enabled, defaulting label to field: $field");
        $label = "$field";
    }
    $label = validate_label($label);
}

vlog2;
set_timeout();

my $dbh;
if($host){
    vlog2 "connecting to MySQL database on '$host:$port' as '$user'\n";
    $dbh = DBI->connect("DBI:mysql:$database:$host:$port", $user, $password,
                        { Taint      => 1,
                          PrintError => 0,
                          RaiseError => 0 } )
    or quit "CRITICAL", "Couldn't connect to '$host:$port' database '$database' (DBI error: " . DBI->errstr . ")";
} else { # connect through local socket
    vlog2 "connecting to MySQL database via socket '$mysql_socket'\n";
    $dbh = DBI->connect("DBI:mysql:$database", $user, $password, { mysql_socket => $mysql_socket, Taint => 1, PrintError => 0, RaiseError => 0 }) || quit "CRITICAL", "failed to connect to MySQL database through socket: $DBI::errstr";
};
vlog2 "login to database successful\n";

# TODO: add multi record support
sub execute_query{
    my $sql = $_[0];
    defined($dbh) or quit "CRITICAL", "database handle no longer valid while attempting to prepare query ($sql)";
    #DBI->trace("SQL");
    my $sth = $dbh->prepare($sql) or quit "CRITICAL", "failed to prepare query: " . $dbh->errstr . " ($sql)";
    vlog2 "query: $sql";
    my $start = Time::HiRes::time;
    $sth->execute or quit "CRITICAL", "Couldn't execute query: " . $sth->errstr . " (\"$sql\")";
    my $stop  = Time::HiRes::time;
    my $query_time = sprintf("%.4f", $stop - $start);
    vlog2 "query executed in $query_time secs";
    if($sth->rows == 0){
        quit "CRITICAL", "no rows returned by query \"$sql\"";
    }
    my $result;
    if($field =~ /^\d+$/){
        my @data = $sth->fetchrow_array();
        if ($verbose >= 3){
            # Data::Dumper makes this ugly as it dumps this out to dozens of lines of $VAR<N> = 'Y';
            # deferred import of Data::Dumper to here so you don't need to have Data::Dumper installed if not running in debug mode / verbose >= 3
            use Data::Dumper;
            vlog3 "Result Row array:\n" . Dumper(@data);
            # looks nicer and more concise but not as clear in quickly determining field numbers
            #my $row_str = "Result row:  ";
            #vlog3 "Result row:  " . Dumper(@data);
            #foreach(@data){
            #    $row_str .= "$_ " if $_;
            #}
            #vlog3 $row_str
        }
        defined($data[$field-1]) or quit "CRITICAL", "couldn't find field $field in result from query \"$sql\"";
        $result = $data[$field-1];
    } else {
        my $data;
        $data = $sth->fetchrow_hashref();
        if($verbose >= 3){
            # deferred import of Data::Dumper to here so you don't need to have Data::Dumper installed if not running in debug mode / verbose >= 3
            use Data::Dumper;
            vlog3 "Result Row:  " . Dumper($data);
        }
        unless(defined($$data{$field})){
            my $errstr = "couldn't find '$field' field in result from query \"$sql\" (fields returned: ";
            foreach(sort keys %$data){
                $errstr .= "'$_', ";
            }
            $errstr =~ s/, $/)/;
            quit "CRITICAL", $errstr;
        }
        $result = $$data{$field};
    }
    $sth->finish();
    vlog3 "result: $result";
    return ($result, $query_time);
}

my ($result, $query_time) = execute_query($query);
defined($result) or quit "CRITICAL", "no result was received from '$database' database on '$host:$port'";
vlog2;

my $time;
if($epoch){
    isFloat($result) or quit "CRITICAL", "cannot diff result from current epoch time, result is not a number (result: '$result')";
    $time = time;
    vlog3 "epoch time: $time";
    $result = $time - $result;
    vlog2 "result diff: $result";
}

$status = "OK";
if($message_printf){
    $msg   .= sprintf($message, $result);
} elsif($message_printf_numeric and isFloat($result)){
    $msg   .= sprintf($message, $result);
} else {
    $msg   .= "$message " if ($message_pre and not $short);
    $msg   .= "'$result'";
    $msg   .= " $message" unless ($message_pre or $short);
}

if(defined($regex)){
    if($result =~ /$regex/){
        vlog2 "result matched regex $regex\n";
    } else {
        quit "CRITICAL", "$msg (expected regex: '$regex')";
    }
}

if(defined($output)){
    if($result eq $output){
        vlog2 "result matched expected output";
    } else {
        quit "CRITICAL", "$msg (expected: '$output')";
    }
}

if($thresholds{"defined"}){
    #$result =~ /^\d+(?:\.\d+)?$/ or quit "CRITICAL", "result did not match expected thresholds, was not in numeric format (result: '$result')";
    #isFloat($result)
    # Allow for negative numbers
    isFloat($result, 1)
        or quit "CRITICAL", "result did not match expected thresholds, was not in numeric format (result: '$result')";
    check_thresholds($result);
}

$msg .= " | ";
if ($graph and isFloat($result, 1)) {
    $msg .= "'$label'=$result";
    if($units){
        $msg .= $units;
    }
    if($thresholds{"warning"}{"upper"} or $thresholds{"critical"}{"upper"}){
        $msg .= ";" . ( $thresholds{"warning"}{"upper"} ? $thresholds{"warning"}{"upper"} : "" );
        $msg .= ";" . ( $thresholds{"critical"}{"upper"} ? $thresholds{"critical"}{"upper"} : "" );
    }
    $msg .= " ";
}
$msg .= "mysql_query_time=${query_time}s" unless $no_querytime;

vlog2;
quit $status, $msg;
